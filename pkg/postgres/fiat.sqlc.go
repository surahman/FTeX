// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: fiat.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFiatAccount = `-- name: createFiatAccount :exec
INSERT INTO fiat_accounts (client_id, currency)
VALUES ($1, $2)
`

type createFiatAccountParams struct {
	ClientID pgtype.UUID `json:"clientID"`
	Currency Currency    `json:"currency"`
}

// createFiatAccount inserts a fiat account record.
func (q *Queries) createFiatAccount(ctx context.Context, arg *createFiatAccountParams) error {
	_, err := q.db.Exec(ctx, createFiatAccount, arg.ClientID, arg.Currency)
	return err
}

const generalLedgerExternalFiatAccount = `-- name: generalLedgerExternalFiatAccount :one
WITH deposit AS (
    INSERT INTO fiat_general_ledger (
        client_id,
        currency,
        ammount,
        transacted_at,
        tx_id)
    SELECT
        (   SELECT client_id
            FROM users
            WHERE username = 'deposit-fiat'),
        $2,
        -1 * $3,
        now(),
        gen_random_uuid()
    RETURNING tx_id, transacted_at
)
INSERT INTO  fiat_general_ledger (
    client_id,
    currency,
    ammount,
    transacted_at,
    tx_id)
SELECT
    $1,
    $2,
    $3,
    (   SELECT transacted_at
        FROM deposit),
    (   SELECT tx_id
        FROM deposit)
RETURNING tx_id
`

type generalLedgerExternalFiatAccountParams struct {
	ClientID pgtype.UUID    `json:"clientID"`
	Currency Currency       `json:"currency"`
	Ammount  pgtype.Numeric `json:"ammount"`
}

// generalLedgerExternalFiatAccount will create both general ledger entries for fiat accounts inbound deposits.
func (q *Queries) generalLedgerExternalFiatAccount(ctx context.Context, arg *generalLedgerExternalFiatAccountParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, generalLedgerExternalFiatAccount, arg.ClientID, arg.Currency, arg.Ammount)
	var tx_id pgtype.UUID
	err := row.Scan(&tx_id)
	return tx_id, err
}

const generalLedgerInternalFiatAccount = `-- name: generalLedgerInternalFiatAccount :one
WITH deposit AS (
    INSERT INTO fiat_general_ledger (
        client_id,
        currency,
        ammount,
        transacted_at,
        tx_id)
    SELECT
        $4::uuid,
        $5::numeric,
        $1,
        now(),
        gen_random_uuid()
    RETURNING tx_id, transacted_at
)
INSERT INTO  fiat_general_ledger (
    client_id,
    currency,
    ammount,
    transacted_at,
    tx_id)
SELECT
    $2::uuid,
    $1,
    $3::numeric,
    (   SELECT transacted_at
        FROM deposit),
    (   SELECT tx_id
        FROM deposit)
RETURNING tx_id
`

type generalLedgerInternalFiatAccountParams struct {
	Currency           Currency       `json:"currency"`
	DestinationAccount pgtype.UUID    `json:"destinationAccount"`
	CreditAmount       pgtype.Numeric `json:"creditAmount"`
	SourceAccount      pgtype.UUID    `json:"sourceAccount"`
	DebitAmount        pgtype.Numeric `json:"debitAmount"`
}

// generalLedgerEntriesInternalAccount will create both general ledger entries for fiat accounts internal transfers.
func (q *Queries) generalLedgerInternalFiatAccount(ctx context.Context, arg *generalLedgerInternalFiatAccountParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, generalLedgerInternalFiatAccount,
		arg.Currency,
		arg.DestinationAccount,
		arg.CreditAmount,
		arg.SourceAccount,
		arg.DebitAmount,
	)
	var tx_id pgtype.UUID
	err := row.Scan(&tx_id)
	return tx_id, err
}

const rowLockFiatAccount = `-- name: rowLockFiatAccount :one
SELECT balance
FROM fiat_accounts
WHERE client_id=$1 AND currency=$2
LIMIT 1
FOR NO KEY UPDATE
`

type rowLockFiatAccountParams struct {
	ClientID pgtype.UUID `json:"clientID"`
	Currency Currency    `json:"currency"`
}

// rowLockFiatAccount will acquire a row level lock without locks on the foreign keys.
func (q *Queries) rowLockFiatAccount(ctx context.Context, arg *rowLockFiatAccountParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, rowLockFiatAccount, arg.ClientID, arg.Currency)
	var balance pgtype.Numeric
	err := row.Scan(&balance)
	return balance, err
}

const updateBalanceFiatAccount = `-- name: updateBalanceFiatAccount :one
UPDATE fiat_accounts
SET balance=balance + $3, last_tx=$3, last_tx_ts=now()
WHERE client_id=$1 AND currency=$2
RETURNING balance, last_tx, last_tx_ts
`

type updateBalanceFiatAccountParams struct {
	ClientID pgtype.UUID    `json:"clientID"`
	Currency Currency       `json:"currency"`
	LastTx   pgtype.Numeric `json:"lastTx"`
}

type updateBalanceFiatAccountRow struct {
	Balance  pgtype.Numeric     `json:"balance"`
	LastTx   pgtype.Numeric     `json:"lastTx"`
	LastTxTs pgtype.Timestamptz `json:"lastTxTs"`
}

// updateBalanceFiatAccount will add an amount to a fiat accounts balance.
func (q *Queries) updateBalanceFiatAccount(ctx context.Context, arg *updateBalanceFiatAccountParams) (updateBalanceFiatAccountRow, error) {
	row := q.db.QueryRow(ctx, updateBalanceFiatAccount, arg.ClientID, arg.Currency, arg.LastTx)
	var i updateBalanceFiatAccountRow
	err := row.Scan(&i.Balance, &i.LastTx, &i.LastTxTs)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: fiat.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFiatAccount = `-- name: createFiatAccount :exec
INSERT INTO fiat_accounts (client_id, currency)
VALUES ($1, $2)
`

type createFiatAccountParams struct {
	ClientID pgtype.UUID `json:"clientID"`
	Currency Currency    `json:"currency"`
}

// createFiatAccount inserts a fiat account record.
func (q *Queries) createFiatAccount(ctx context.Context, arg createFiatAccountParams) error {
	_, err := q.db.Exec(ctx, createFiatAccount, arg.ClientID, arg.Currency)
	return err
}

const generalLedgerEntryFiatAccount = `-- name: generalLedgerEntryFiatAccount :one
INSERT INTO  fiat_general_ledger (
    client_id,
    currency,
    ammount,
    transacted_at,
    tx_id)
SELECT
    CASE
      WHEN $6::text='deposit' THEN (
        SELECT client_id
        FROM users
        WHERE username = 'deposit-fiat')
      ELSE $1
    END AS client_id,
    $2,
    $3,
    $4,
    CASE
      WHEN length($7::text)=0 THEN gen_random_uuid()
      ELSE $5
    END AS tx_id
RETURNING tx_id
`

type generalLedgerEntryFiatAccountParams struct {
	ClientID     pgtype.UUID        `json:"clientID"`
	Currency     Currency           `json:"currency"`
	Ammount      pgtype.Numeric     `json:"ammount"`
	TransactedAt pgtype.Timestamptz `json:"transactedAt"`
	TxID         pgtype.UUID        `json:"txID"`
	ClientIDStr  string             `json:"clientIDStr"`
	TxIDStr      string             `json:"txIDStr"`
}

// generalLedgerEntryFiatAccount will create general ledger entries.
// [$1] is the Client ID. If <deposit> is specified the <deposit-fiat> Client ID will be looked up.
// [$5] is the TX ID. A random one will be generated if not supplied.
func (q *Queries) generalLedgerEntryFiatAccount(ctx context.Context, arg generalLedgerEntryFiatAccountParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, generalLedgerEntryFiatAccount,
		arg.ClientID,
		arg.Currency,
		arg.Ammount,
		arg.TransactedAt,
		arg.TxID,
		arg.ClientIDStr,
		arg.TxIDStr,
	)
	var tx_id pgtype.UUID
	err := row.Scan(&tx_id)
	return tx_id, err
}

const rowLockFiatAccount = `-- name: rowLockFiatAccount :exec
SELECT
FROM fiat_accounts
WHERE client_id=$1 AND currency=$2
LIMIT 1
FOR NO KEY UPDATE
`

type rowLockFiatAccountParams struct {
	ClientID pgtype.UUID `json:"clientID"`
	Currency Currency    `json:"currency"`
}

// rowLockFiatAccount will acquire a row level lock without locks on the foreign keys.
func (q *Queries) rowLockFiatAccount(ctx context.Context, arg rowLockFiatAccountParams) error {
	_, err := q.db.Exec(ctx, rowLockFiatAccount, arg.ClientID, arg.Currency)
	return err
}

const updateBalanceFiatAccount = `-- name: updateBalanceFiatAccount :one
UPDATE fiat_accounts
SET balance=balance + $3, last_tx=$3, last_tx_ts=now()
WHERE client_id=$1 AND currency=$2
RETURNING balance, last_tx, last_tx_ts
`

type updateBalanceFiatAccountParams struct {
	ClientID pgtype.UUID    `json:"clientID"`
	Currency Currency       `json:"currency"`
	LastTx   pgtype.Numeric `json:"lastTx"`
}

type updateBalanceFiatAccountRow struct {
	Balance  pgtype.Numeric     `json:"balance"`
	LastTx   pgtype.Numeric     `json:"lastTx"`
	LastTxTs pgtype.Timestamptz `json:"lastTxTs"`
}

// updateBalanceFiatAccount will add an amount to a fiat accounts balance.
func (q *Queries) updateBalanceFiatAccount(ctx context.Context, arg updateBalanceFiatAccountParams) (updateBalanceFiatAccountRow, error) {
	row := q.db.QueryRow(ctx, updateBalanceFiatAccount, arg.ClientID, arg.Currency, arg.LastTx)
	var i updateBalanceFiatAccountRow
	err := row.Scan(&i.Balance, &i.LastTx, &i.LastTxTs)
	return i, err
}

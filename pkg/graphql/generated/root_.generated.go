// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql_generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/surahman/FTeX/pkg/models"
	models1 "github.com/surahman/FTeX/pkg/models/postgres"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	FiatDepositResponse() FiatDepositResponseResolver
	Mutation() MutationResolver
	Query() QueryResolver
	FiatDepositRequest() FiatDepositRequestResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	FiatDepositResponse struct {
		Balance     func(childComplexity int) int
		ClientID    func(childComplexity int) int
		Currency    func(childComplexity int) int
		LastTx      func(childComplexity int) int
		TxID        func(childComplexity int) int
		TxTimestamp func(childComplexity int) int
	}

	FiatOpenAccountResponse struct {
		ClientID func(childComplexity int) int
		Currency func(childComplexity int) int
	}

	JWTAuthResponse struct {
		Expires   func(childComplexity int) int
		Threshold func(childComplexity int) int
		Token     func(childComplexity int) int
	}

	Mutation struct {
		DeleteUser   func(childComplexity int, input models.HTTPDeleteUserRequest) int
		DepositFiat  func(childComplexity int, input models.HTTPDepositCurrencyRequest) int
		LoginUser    func(childComplexity int, input models1.UserLoginCredentials) int
		OpenFiat     func(childComplexity int, currency string) int
		RefreshToken func(childComplexity int) int
		RegisterUser func(childComplexity int, input *models1.UserAccount) int
	}

	Query struct {
		Healthcheck func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "FiatDepositResponse.balance":
		if e.complexity.FiatDepositResponse.Balance == nil {
			break
		}

		return e.complexity.FiatDepositResponse.Balance(childComplexity), true

	case "FiatDepositResponse.clientId":
		if e.complexity.FiatDepositResponse.ClientID == nil {
			break
		}

		return e.complexity.FiatDepositResponse.ClientID(childComplexity), true

	case "FiatDepositResponse.currency":
		if e.complexity.FiatDepositResponse.Currency == nil {
			break
		}

		return e.complexity.FiatDepositResponse.Currency(childComplexity), true

	case "FiatDepositResponse.lastTx":
		if e.complexity.FiatDepositResponse.LastTx == nil {
			break
		}

		return e.complexity.FiatDepositResponse.LastTx(childComplexity), true

	case "FiatDepositResponse.txId":
		if e.complexity.FiatDepositResponse.TxID == nil {
			break
		}

		return e.complexity.FiatDepositResponse.TxID(childComplexity), true

	case "FiatDepositResponse.txTimestamp":
		if e.complexity.FiatDepositResponse.TxTimestamp == nil {
			break
		}

		return e.complexity.FiatDepositResponse.TxTimestamp(childComplexity), true

	case "FiatOpenAccountResponse.clientID":
		if e.complexity.FiatOpenAccountResponse.ClientID == nil {
			break
		}

		return e.complexity.FiatOpenAccountResponse.ClientID(childComplexity), true

	case "FiatOpenAccountResponse.currency":
		if e.complexity.FiatOpenAccountResponse.Currency == nil {
			break
		}

		return e.complexity.FiatOpenAccountResponse.Currency(childComplexity), true

	case "JWTAuthResponse.expires":
		if e.complexity.JWTAuthResponse.Expires == nil {
			break
		}

		return e.complexity.JWTAuthResponse.Expires(childComplexity), true

	case "JWTAuthResponse.threshold":
		if e.complexity.JWTAuthResponse.Threshold == nil {
			break
		}

		return e.complexity.JWTAuthResponse.Threshold(childComplexity), true

	case "JWTAuthResponse.token":
		if e.complexity.JWTAuthResponse.Token == nil {
			break
		}

		return e.complexity.JWTAuthResponse.Token(childComplexity), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["input"].(models.HTTPDeleteUserRequest)), true

	case "Mutation.depositFiat":
		if e.complexity.Mutation.DepositFiat == nil {
			break
		}

		args, err := ec.field_Mutation_depositFiat_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DepositFiat(childComplexity, args["input"].(models.HTTPDepositCurrencyRequest)), true

	case "Mutation.loginUser":
		if e.complexity.Mutation.LoginUser == nil {
			break
		}

		args, err := ec.field_Mutation_loginUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LoginUser(childComplexity, args["input"].(models1.UserLoginCredentials)), true

	case "Mutation.openFiat":
		if e.complexity.Mutation.OpenFiat == nil {
			break
		}

		args, err := ec.field_Mutation_openFiat_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OpenFiat(childComplexity, args["currency"].(string)), true

	case "Mutation.refreshToken":
		if e.complexity.Mutation.RefreshToken == nil {
			break
		}

		return e.complexity.Mutation.RefreshToken(childComplexity), true

	case "Mutation.registerUser":
		if e.complexity.Mutation.RegisterUser == nil {
			break
		}

		args, err := ec.field_Mutation_registerUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterUser(childComplexity, args["input"].(*models1.UserAccount)), true

	case "Query.healthcheck":
		if e.complexity.Query.Healthcheck == nil {
			break
		}

		return e.complexity.Query.Healthcheck(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputDeleteUserRequest,
		ec.unmarshalInputFiatDepositRequest,
		ec.unmarshalInputUserAccount,
		ec.unmarshalInputUserLoginCredentials,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/auth.graphqls", Input: `# JWT Authorization Response.
type JWTAuthResponse {
    token: String!
    expires: Int64!
    threshold: Int64!
}
`, BuiltIn: false},
	{Name: "../schema/fiat.graphqls", Input: `# FiatOpenAccountResponse is the response returned
type FiatOpenAccountResponse {
    clientID: String!
    currency: String!
}

# FiatDepositResponse is the response to a Fiat currency deposit from an external source.
type FiatDepositResponse {
    txId: String!
    clientId: String!
    txTimestamp: String!
    balance: String!
    lastTx: String!
    currency: String!
}

# FiatDepositRequest is a request to deposit Fiat currency from an external source.
input FiatDepositRequest {
    amount: Float!
    currency: String!
}

# Requests that might alter the state of data in the database.
extend type Mutation {
    # openFiat is a request to open an account if it does not already exist.
    openFiat(currency: String!): FiatOpenAccountResponse!

    # depositFiat is a request to deposit Fiat currency from an external source.
    depositFiat(input: FiatDepositRequest!): FiatDepositResponse!
}
`, BuiltIn: false},
	{Name: "../schema/healthcheck.graphqls", Input: `type Query {
    healthcheck: String!
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphqls", Input: `scalar Int32
scalar Int64
`, BuiltIn: false},
	{Name: "../schema/user.graphqls", Input: `# User account information.
input UserAccount {
    firstname: String!
    lastname: String!
    email: String!
    userLoginCredentials: UserLoginCredentials!
}

# Login credentials.
input UserLoginCredentials {
    username: String!
    password: String!
}

# User account deletion request.
input DeleteUserRequest {
    username: String!
    password: String!
    confirmation: String!
}

# Requests that might alter the state of data in the database.
type Mutation {
    # Send a user registration request and receive a JWT authorization token in response.
    registerUser(input: UserAccount): JWTAuthResponse!

    # Send a user account deletion request.
    deleteUser(input: DeleteUserRequest!): String!

    # Send a user login request And receive a JWT authorization token in response. This has no side effects but is a
    # mutation to force sequential execution. This stops operations such as delete and refresh from being run in
    # parallel with a login.
    loginUser(input: UserLoginCredentials!): JWTAuthResponse!

    # Refreshes a users JWT if it is within the refresh time window.
    refreshToken: JWTAuthResponse!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

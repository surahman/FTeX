// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql_generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/surahman/FTeX/pkg/models"
	models1 "github.com/surahman/FTeX/pkg/models/postgres"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	FiatOpenAccountResponse struct {
		ClientID func(childComplexity int) int
		Currency func(childComplexity int) int
	}

	JWTAuthResponse struct {
		Expires   func(childComplexity int) int
		Threshold func(childComplexity int) int
		Token     func(childComplexity int) int
	}

	Mutation struct {
		DeleteUser   func(childComplexity int, input models.HTTPDeleteUserRequest) int
		LoginUser    func(childComplexity int, input models1.UserLoginCredentials) int
		OpenFiat     func(childComplexity int, currency string) int
		RefreshToken func(childComplexity int) int
		RegisterUser func(childComplexity int, input *models1.UserAccount) int
	}

	Query struct {
		Healthcheck func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "FiatOpenAccountResponse.clientID":
		if e.complexity.FiatOpenAccountResponse.ClientID == nil {
			break
		}

		return e.complexity.FiatOpenAccountResponse.ClientID(childComplexity), true

	case "FiatOpenAccountResponse.currency":
		if e.complexity.FiatOpenAccountResponse.Currency == nil {
			break
		}

		return e.complexity.FiatOpenAccountResponse.Currency(childComplexity), true

	case "JWTAuthResponse.expires":
		if e.complexity.JWTAuthResponse.Expires == nil {
			break
		}

		return e.complexity.JWTAuthResponse.Expires(childComplexity), true

	case "JWTAuthResponse.threshold":
		if e.complexity.JWTAuthResponse.Threshold == nil {
			break
		}

		return e.complexity.JWTAuthResponse.Threshold(childComplexity), true

	case "JWTAuthResponse.token":
		if e.complexity.JWTAuthResponse.Token == nil {
			break
		}

		return e.complexity.JWTAuthResponse.Token(childComplexity), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["input"].(models.HTTPDeleteUserRequest)), true

	case "Mutation.loginUser":
		if e.complexity.Mutation.LoginUser == nil {
			break
		}

		args, err := ec.field_Mutation_loginUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LoginUser(childComplexity, args["input"].(models1.UserLoginCredentials)), true

	case "Mutation.openFiat":
		if e.complexity.Mutation.OpenFiat == nil {
			break
		}

		args, err := ec.field_Mutation_openFiat_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OpenFiat(childComplexity, args["currency"].(string)), true

	case "Mutation.refreshToken":
		if e.complexity.Mutation.RefreshToken == nil {
			break
		}

		return e.complexity.Mutation.RefreshToken(childComplexity), true

	case "Mutation.registerUser":
		if e.complexity.Mutation.RegisterUser == nil {
			break
		}

		args, err := ec.field_Mutation_registerUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterUser(childComplexity, args["input"].(*models1.UserAccount)), true

	case "Query.healthcheck":
		if e.complexity.Query.Healthcheck == nil {
			break
		}

		return e.complexity.Query.Healthcheck(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputDeleteUserRequest,
		ec.unmarshalInputUserAccount,
		ec.unmarshalInputUserLoginCredentials,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/auth.graphqls", Input: `# JWT Authorization Response.
type JWTAuthResponse {
    token: String!
    expires: Int64!
    threshold: Int64!
}
`, BuiltIn: false},
	{Name: "../schema/fiat.graphqls", Input: `# FiatOpenAccountResponse is the response returned
type FiatOpenAccountResponse {
    clientID: String!
    currency: String!
}

# Requests that might alter the state of data in the database.
extend type Mutation {
    # Open a Fiat account if it does not already exist.
    openFiat(currency: String!): FiatOpenAccountResponse!
}
`, BuiltIn: false},
	{Name: "../schema/healthcheck.graphqls", Input: `type Query {
    healthcheck: String!
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphqls", Input: `scalar Int32
scalar Int64
`, BuiltIn: false},
	{Name: "../schema/user.graphqls", Input: `# User account information.
input UserAccount {
    firstname: String!
    lastname: String!
    email: String!
    userLoginCredentials: UserLoginCredentials!
}

# Login credentials.
input UserLoginCredentials {
    username: String!
    password: String!
}

# User account deletion request.
input DeleteUserRequest {
    username: String!
    password: String!
    confirmation: String!
}

# Requests that might alter the state of data in the database.
type Mutation {
    # Send a user registration request and receive a JWT authorization token in response.
    registerUser(input: UserAccount): JWTAuthResponse!

    # Send a user account deletion request.
    deleteUser(input: DeleteUserRequest!): String!

    # Send a user login request And receive a JWT authorization token in response. This has no side effects but is a
    # mutation to force sequential execution. This stops operations such as delete and refresh from being run in
    # parallel with a login.
    loginUser(input: UserLoginCredentials!): JWTAuthResponse!

    # Refreshes a users JWT if it is within the refresh time window.
    refreshToken: JWTAuthResponse!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

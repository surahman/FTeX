
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/surahman/FTeX/pkg/auth/auth.go (82.7%)</option>

				<option value="file1">github.com/surahman/FTeX/pkg/auth/config.go (100.0%)</option>

				<option value="file2">github.com/surahman/FTeX/pkg/auth/errors.go (87.5%)</option>

				<option value="file3">github.com/surahman/FTeX/pkg/auth/test_data.go (100.0%)</option>

				<option value="file4">github.com/surahman/FTeX/pkg/common/common.go (85.0%)</option>

				<option value="file5">github.com/surahman/FTeX/pkg/common/crypto.go (97.8%)</option>

				<option value="file6">github.com/surahman/FTeX/pkg/common/fiat.go (95.7%)</option>

				<option value="file7">github.com/surahman/FTeX/pkg/common/healthcheck.go (100.0%)</option>

				<option value="file8">github.com/surahman/FTeX/pkg/common/users.go (97.2%)</option>

				<option value="file9">github.com/surahman/FTeX/pkg/configloader/config_loader.go (86.7%)</option>

				<option value="file10">github.com/surahman/FTeX/pkg/configloader/test_data.go (100.0%)</option>

				<option value="file11">github.com/surahman/FTeX/pkg/constants/constants.go (100.0%)</option>

				<option value="file12">github.com/surahman/FTeX/pkg/graphql/config.go (100.0%)</option>

				<option value="file13">github.com/surahman/FTeX/pkg/graphql/graphql.go (10.7%)</option>

				<option value="file14">github.com/surahman/FTeX/pkg/graphql/resolvers/authorization.go (100.0%)</option>

				<option value="file15">github.com/surahman/FTeX/pkg/graphql/resolvers/common.resolvers.go (100.0%)</option>

				<option value="file16">github.com/surahman/FTeX/pkg/graphql/resolvers/crypto.resolvers.go (98.8%)</option>

				<option value="file17">github.com/surahman/FTeX/pkg/graphql/resolvers/fiat.resolvers.go (99.0%)</option>

				<option value="file18">github.com/surahman/FTeX/pkg/graphql/resolvers/handlers.go (90.0%)</option>

				<option value="file19">github.com/surahman/FTeX/pkg/graphql/resolvers/healthcheck.resolvers.go (100.0%)</option>

				<option value="file20">github.com/surahman/FTeX/pkg/graphql/resolvers/test_data.go (100.0%)</option>

				<option value="file21">github.com/surahman/FTeX/pkg/graphql/resolvers/user.resolvers.go (100.0%)</option>

				<option value="file22">github.com/surahman/FTeX/pkg/graphql/test_data.go (100.0%)</option>

				<option value="file23">github.com/surahman/FTeX/pkg/logger/config.go (100.0%)</option>

				<option value="file24">github.com/surahman/FTeX/pkg/logger/logger.go (66.7%)</option>

				<option value="file25">github.com/surahman/FTeX/pkg/logger/test_data.go (100.0%)</option>

				<option value="file26">github.com/surahman/FTeX/pkg/postgres/config.go (100.0%)</option>

				<option value="file27">github.com/surahman/FTeX/pkg/postgres/crypto.sqlc.go (82.4%)</option>

				<option value="file28">github.com/surahman/FTeX/pkg/postgres/errors.go (94.1%)</option>

				<option value="file29">github.com/surahman/FTeX/pkg/postgres/fiat.sqlc.go (84.2%)</option>

				<option value="file30">github.com/surahman/FTeX/pkg/postgres/models_sqlc.go (100.0%)</option>

				<option value="file31">github.com/surahman/FTeX/pkg/postgres/postgres.go (83.0%)</option>

				<option value="file32">github.com/surahman/FTeX/pkg/postgres/postgres_sqlc.go (100.0%)</option>

				<option value="file33">github.com/surahman/FTeX/pkg/postgres/querier_mocks.go (18.8%)</option>

				<option value="file34">github.com/surahman/FTeX/pkg/postgres/queries_crypto.go (74.6%)</option>

				<option value="file35">github.com/surahman/FTeX/pkg/postgres/queries_fiat.go (90.3%)</option>

				<option value="file36">github.com/surahman/FTeX/pkg/postgres/queries_users.go (94.4%)</option>

				<option value="file37">github.com/surahman/FTeX/pkg/postgres/test_data.go (100.0%)</option>

				<option value="file38">github.com/surahman/FTeX/pkg/postgres/transactions.go (86.7%)</option>

				<option value="file39">github.com/surahman/FTeX/pkg/postgres/udf.sqlc.go (100.0%)</option>

				<option value="file40">github.com/surahman/FTeX/pkg/postgres/users.sqlc.go (95.8%)</option>

				<option value="file41">github.com/surahman/FTeX/pkg/quotes/config.go (100.0%)</option>

				<option value="file42">github.com/surahman/FTeX/pkg/quotes/errors.go (100.0%)</option>

				<option value="file43">github.com/surahman/FTeX/pkg/quotes/quotes.go (78.7%)</option>

				<option value="file44">github.com/surahman/FTeX/pkg/quotes/quotes_mocks.go (52.9%)</option>

				<option value="file45">github.com/surahman/FTeX/pkg/quotes/test_data.go (100.0%)</option>

				<option value="file46">github.com/surahman/FTeX/pkg/redis/config.go (100.0%)</option>

				<option value="file47">github.com/surahman/FTeX/pkg/redis/errors.go (100.0%)</option>

				<option value="file48">github.com/surahman/FTeX/pkg/redis/redis.go (87.5%)</option>

				<option value="file49">github.com/surahman/FTeX/pkg/redis/test_data.go (100.0%)</option>

				<option value="file50">github.com/surahman/FTeX/pkg/rest/config.go (100.0%)</option>

				<option value="file51">github.com/surahman/FTeX/pkg/rest/handlers/authorization.go (100.0%)</option>

				<option value="file52">github.com/surahman/FTeX/pkg/rest/handlers/crypto.go (93.3%)</option>

				<option value="file53">github.com/surahman/FTeX/pkg/rest/handlers/fiat.go (90.9%)</option>

				<option value="file54">github.com/surahman/FTeX/pkg/rest/handlers/healthcheck.go (100.0%)</option>

				<option value="file55">github.com/surahman/FTeX/pkg/rest/handlers/users.go (84.6%)</option>

				<option value="file56">github.com/surahman/FTeX/pkg/rest/rest.go (6.0%)</option>

				<option value="file57">github.com/surahman/FTeX/pkg/rest/test_data.go (100.0%)</option>

				<option value="file58">github.com/surahman/FTeX/pkg/validator/errors.go (100.0%)</option>

				<option value="file59">github.com/surahman/FTeX/pkg/validator/validator.go (100.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package auth

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gofrs/uuid"
        "github.com/golang-jwt/jwt/v5"
        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
)

// Mock Auth interface stub generation.
//go:generate mockgen -destination=../mocks/mock_auth.go -package=mocks github.com/surahman/FTeX/pkg/auth Auth

// Auth is the interface through which the authorization operations can be accessed. Created to support mock testing.
type Auth interface {
        // HashPassword will take a plaintext string and generate a hashed representation of it.
        HashPassword(string) (string, error)

        // CheckPassword will take the plaintext and hashed passwords as input, in that order, and verify if they match.
        CheckPassword(string, string) error

        // GenerateJWT will create a valid JSON Web Token and return it in a JWT Authorization Response structure.
        GenerateJWT(uuid.UUID) (*models.JWTAuthResponse, error)

        // ValidateJWT will take the JSON Web Token and validate it. It will extract and return the username and expiration
        // time (Unix timestamp) or an error if validation fails.
        ValidateJWT(string) (uuid.UUID, int64, error)

        // RefreshJWT will take a valid JSON Web Token, and if valid and expiring soon, issue a fresh valid JWT with the time
        // extended in JWT Authorization Response structure.
        RefreshJWT(string) (*models.JWTAuthResponse, error)

        // RefreshThreshold returns the time before the end of the JSON Web Tokens validity interval that a JWT can be
        // refreshed in.
        RefreshThreshold() int64

        // EncryptToString will generate an encrypted base64 encoded character from the plaintext.
        EncryptToString([]byte) (string, error)

        // DecryptFromString will decrypt an encrypted base64 encoded character from the ciphertext.
        DecryptFromString(string) ([]byte, error)

        // TokenInfoFromGinCtx extracts the clientID and expiration deadline stored from a JWT in the Gin context.
        TokenInfoFromGinCtx(ctx *gin.Context) (uuid.UUID, int64, error)
}

// Check to ensure the Auth interface has been implemented.
var _ Auth = &amp;authImpl{}

// authImpl implements the Auth interface and contains the logic for authorization functionality.
type authImpl struct {
        cryptoSecret []byte
        conf         *config
        logger       *logger.Logger
}

// NewAuth will create a new Authorization configuration by loading it.
func NewAuth(fs *afero.Fs, logger *logger.Logger) (Auth, error) <span class="cov7" title="6">{
        if fs == nil || logger == nil </span><span class="cov5" title="3">{
                return nil, errors.New("nil file system or logger supplied")
        }</span>

        <span class="cov5" title="3">return newAuthImpl(fs, logger)</span>
}

// newAuthImpl will create a new authImpl configuration and load it from disk.
func newAuthImpl(fs *afero.Fs, logger *logger.Logger) (a *authImpl, err error) <span class="cov5" title="3">{
        a = &amp;authImpl{conf: newConfig(), logger: logger}
        if err = a.conf.Load(*fs); err != nil </span><span class="cov1" title="1">{
                a.logger.Error("failed to load Authorization configurations from disk", zap.Error(err))

                return nil, err
        }</span>

        <span class="cov3" title="2">a.cryptoSecret = []byte(a.conf.General.CryptoSecret)

        return</span>
}

// HashPassword hashes a password using the Bcrypt algorithm to avoid plaintext storage.
func (a *authImpl) HashPassword(plaintext string) (hashed string, err error) <span class="cov3" title="2">{
        var bytes []byte

        if bytes, err = bcrypt.GenerateFromPassword([]byte(plaintext), a.conf.General.BcryptCost); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">hashed = string(bytes)

        return</span>
}

// CheckPassword checks a hashed password against a plaintext password using the Bcrypt algorithm.
func (a *authImpl) CheckPassword(hashed, plaintext string) (err error) <span class="cov5" title="3">{
        if err = bcrypt.CompareHashAndPassword([]byte(hashed), []byte(plaintext)); err != nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov3" title="2">return</span>
}

// jwtClaim is used internally by the JWT generation and validation routines.
type jwtClaim struct {
        ClientID uuid.UUID `json:"clientId" yaml:"clientId"`
        jwt.RegisteredClaims
}

// GenerateJWT creates a payload consisting of the JWT with the Client ID and expiration time.
func (a *authImpl) GenerateJWT(clientID uuid.UUID) (*models.JWTAuthResponse, error) <span class="cov8" title="7">{
        claims := &amp;jwtClaim{
                ClientID: clientID,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer: a.conf.JWTConfig.Issuer,
                        ExpiresAt: jwt.NewNumericDate(
                                time.
                                        Now().
                                        Add(time.Duration(a.conf.JWTConfig.ExpirationDuration) * time.Second).UTC()),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        tokenString, err := token.SignedString([]byte(a.conf.JWTConfig.Key))
        if err != nil </span><span class="cov0" title="0">{
                msg := "failed to generate signed jwt"
                a.logger.Warn(msg, zap.Error(err))

                return nil, fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov8" title="7">authResponse := &amp;models.JWTAuthResponse{
                Token:     tokenString,
                Expires:   claims.ExpiresAt.Unix(),
                Threshold: a.conf.JWTConfig.RefreshThreshold,
        }

        return authResponse, nil</span>
}

// ValidateJWT will validate a signed JWT and extracts the Client ID and unix expiration timestamp from it.
func (a *authImpl) ValidateJWT(signedToken string) (uuid.UUID, int64, error) <span class="cov10" title="11">{
        token, err := jwt.ParseWithClaims(signedToken, &amp;jwtClaim{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov9" title="9">{
                return []byte(a.conf.JWTConfig.Key), nil
        }</span>)
        <span class="cov10" title="11">if err != nil </span><span class="cov6" title="4">{
                msg := "failed to parse token"
                a.logger.Warn(msg, zap.Error(err))

                return uuid.UUID{}, -1, fmt.Errorf(msg+" %w", err)
        }</span>

        // Cast token claim to JWT.
        <span class="cov8" title="7">claims, ok := token.Claims.(*jwtClaim)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                msg := "failed to extract jwt data"
                a.logger.Warn(msg, zap.Error(err))

                return uuid.UUID{}, -1, fmt.Errorf(msg+" %w", err)
        }</span>

        // Check for errors and compare the expiration time in Unix format.
        <span class="cov8" title="7">expiration, err := claims.GetExpirationTime()
        if err != nil || expiration.Unix() &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                return uuid.UUID{}, -1, errors.New("token has expired")
        }</span>

        // Check the issuer is correct.
        <span class="cov8" title="7">issuer, err := claims.GetIssuer()
        if err != nil || issuer != a.conf.JWTConfig.Issuer </span><span class="cov1" title="1">{
                return uuid.UUID{}, -1, errors.New("unauthorized issuer")
        }</span>

        // Return the username and the unix expiration timestamp.
        <span class="cov7" title="6">return claims.ClientID, claims.ExpiresAt.Unix(), nil</span>
}

// RefreshJWT will extend a valid JWTs lease by generating a fresh valid JWT.
func (a *authImpl) RefreshJWT(token string) (authResponse *models.JWTAuthResponse, err error) <span class="cov3" title="2">{
        var clientID uuid.UUID

        if clientID, _, err = a.ValidateJWT(token); err != nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="1">if authResponse, err = a.GenerateJWT(clientID); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">return</span>
}

// RefreshThreshold is the seconds before expiration that a JWT can be refreshed in.
func (a *authImpl) RefreshThreshold() int64 <span class="cov1" title="1">{
        return a.conf.JWTConfig.RefreshThreshold
}</span>

// encryptAES256 employs Authenticated Encryption with Associated Data using Galois/Counter mode and returns the cipher
// as a Base64 encoded string to be used in URIs.
func (a *authImpl) encryptAES256(data []byte) (cipherStr string, cipherBytes []byte, err error) <span class="cov3" title="2">{
        var (
                cipherBlock cipher.Block
                gcm         cipher.AEAD
        )

        if cipherBlock, err = aes.NewCipher(a.cryptoSecret); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">if gcm, err = cipher.NewGCM(cipherBlock); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">nonce := make([]byte, gcm.NonceSize())
        if _, err = io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Encrypt to a cipher text.
        <span class="cov3" title="2">cipherBytes = gcm.Seal(nonce, nonce, data, nil)

        // Convert to Base64 URL encoded string for use in URLs.
        cipherStr = base64.URLEncoding.EncodeToString(cipherBytes)

        return</span>
}

// decryptAES256 employs Authenticated Encryption with Associated Data using Galois/Counter mode and returns the
// decrypted plaintext bytes.
func (a *authImpl) decryptAES256(data []byte) (cipherBytes []byte, err error) <span class="cov3" title="2">{
        var (
                cipherBlock cipher.Block
                gcm         cipher.AEAD
                nonceSize   int
        )

        if cipherBlock, err = aes.NewCipher(a.cryptoSecret); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">if gcm, err = cipher.NewGCM(cipherBlock); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">if nonceSize = gcm.NonceSize(); nonceSize &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("bad nonce size")
        }</span>

        // Extract the nonce and cipher blocks from the data.
        <span class="cov3" title="2">nonce, cipherText := data[:nonceSize], data[nonceSize:]

        // Decrypt cipher text.
        cipherBytes, err = gcm.Open(nil, nonce, cipherText, nil)

        return</span>
}

// EncryptToString will generate an encrypted base64 encoded character from the plaintext.
func (a *authImpl) EncryptToString(plaintext []byte) (ciphertext string, err error) <span class="cov1" title="1">{
        ciphertext, _, err = a.encryptAES256(plaintext)

        return
}</span>

// DecryptFromString will decrypt an encrypted base64 encoded character from the ciphertext.
func (a *authImpl) DecryptFromString(ciphertext string) (plaintext []byte, err error) <span class="cov1" title="1">{
        var bytes []byte

        if bytes, err = base64.URLEncoding.DecodeString(ciphertext); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">return a.decryptAES256(bytes)</span>
}

// testConfigurationImpl creates an authImpl configuration for testing.
func testConfigurationImpl(zapLogger *logger.Logger, expDuration, refThreshold int64) *authImpl <span class="cov8" title="7">{
        auth := &amp;authImpl{
                conf:   &amp;config{},
                logger: zapLogger,
        }
        auth.conf.JWTConfig.Key = "encryption key for test suite"
        auth.conf.JWTConfig.Issuer = "issuer for test suite"
        auth.conf.JWTConfig.ExpirationDuration = expDuration
        auth.conf.JWTConfig.RefreshThreshold = refThreshold
        auth.conf.General.BcryptCost = 4
        auth.cryptoSecret = []byte("*****crypto key for testing*****")

        return auth
}</span>

// TestAuth is a basic test Auth struct to be used in test suites.
func TestAuth(zapLogger *logger.Logger, expDuration, refThreshold int64) Auth <span class="cov0" title="0">{
        return testConfigurationImpl(zapLogger, expDuration, refThreshold)
}</span>

// TokenInfoFromGinCtx extracts the clientID and expiration deadline stored from a JWT in the Gin context.
func (a *authImpl) TokenInfoFromGinCtx(ctx *gin.Context) (uuid.UUID, int64, error) <span class="cov7" title="5">{
        var (
                expiresAt int64
                clientID  uuid.UUID
        )
        // Extract clientID.
        rawClientID, ok := ctx.Get(constants.ClientIDCtxKey())
        if !ok </span><span class="cov1" title="1">{
                return clientID, expiresAt, errors.New("unable to locate clientID")
        }</span>

        <span class="cov6" title="4">clientID, ok = rawClientID.(uuid.UUID)
        if !ok </span><span class="cov1" title="1">{
                return clientID, expiresAt, errors.New("unable to parse clientID")
        }</span>

        // Extract expiration deadline.
        <span class="cov5" title="3">expiresAt = ctx.GetInt64(constants.ExpiresAtCtxKey())
        if expiresAt == 0 </span><span class="cov3" title="2">{
                return clientID, expiresAt, errors.New("failed to locate expiration deadline")
        }</span>

        <span class="cov1" title="1">return clientID, expiresAt, nil</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package auth

import (
        "fmt"

        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/configloader"
        "github.com/surahman/FTeX/pkg/constants"
)

// Config contains all the configurations for authentication.
type config struct {
        JWTConfig jwtConfig     `json:"jwt,omitempty"     mapstructure:"jwt"     validate:"required" yaml:"jwt,omitempty"`
        General   generalConfig `json:"general,omitempty" mapstructure:"general" validate:"required" yaml:"general,omitempty"`
}

// jwtConfig contains the configurations for JWT creation and verification.
//
//nolint:lll
type jwtConfig struct {
        Key                string `json:"key,omitempty"                mapstructure:"key"                validate:"required,min=8,max=256"                     yaml:"key,omitempty"`
        Issuer             string `json:"issuer,omitempty"             mapstructure:"issuer"             validate:"required"                                   yaml:"issuer,omitempty"`
        ExpirationDuration int64  `json:"expirationDuration,omitempty" mapstructure:"expirationDuration" validate:"required,min=60,gtefield=RefreshThreshold"  yaml:"expirationDuration,omitempty"`
        RefreshThreshold   int64  `json:"refreshThreshold,omitempty"   mapstructure:"refreshThreshold"   validate:"required,min=1,ltefield=ExpirationDuration" yaml:"refreshThreshold,omitempty"`
}

// generalConfig contains the configurations for general encryption.
//
//nolint:lll
type generalConfig struct {
        BcryptCost   int    `json:"bcryptCost,omitempty"   mapstructure:"bcryptCost"   validate:"required,min=4,max=31" yaml:"bcryptCost,omitempty"`
        CryptoSecret string `json:"cryptoSecret,omitempty" mapstructure:"cryptoSecret" validate:"required,len=32"       yaml:"cryptoSecret,omitempty"`
}

// newConfig creates a blank configuration struct for the authorization.
func newConfig() *config <span class="cov4" title="3">{
        return &amp;config{}
}</span>

// Load will attempt to load configurations from a file on a file system.
func (cfg *config) Load(fs afero.Fs) error <span class="cov10" title="16">{
        if err := configloader.Load(
                fs,
                cfg,
                constants.AuthFileName(),
                constants.AuthPrefix(),
                "yaml"); err != nil </span><span class="cov9" title="12">{
                return fmt.Errorf("authorization config loading failed: %w", err)
        }</span>

        <span class="cov5" title="4">return nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package auth

import (
        "errors"
)

// Error is the base error type. The builder pattern is used to add specialization codes to the errors.
type Error struct {
        Message string
        Code    int
}

// Check to ensure the error interface is implemented.
var _ error = &amp;Error{}

// Error get human readable error message.
func (e *Error) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// Is will return whether the input err is an instance of expected error.
func (e *Error) Is(err error) bool <span class="cov10" title="5">{
        var target *Error
        if !errors.As(err, &amp;target) </span><span class="cov7" title="3">{
                return false
        }</span>

        <span class="cov4" title="2">return e.Code == target.Code</span>
}

// NewError is a base error message with no special code.
func NewError(message string) *Error <span class="cov10" title="5">{
        return &amp;Error{Message: message, Code: 0}
}</span>

// SetStatus configures the error status/code.
func (e *Error) SetStatus(status int) *Error <span class="cov7" title="3">{
        e.Code = status

        return e
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">package auth

// configTestData will return a map of test data containing valid and invalid Authorization configs.
//
//nolint:lll
func configTestData() map[string]string <span class="cov8" title="1">{
        return map[string]string{

                "empty": ``,

                "valid": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "no_issuer": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "bcrypt_cost_below_4": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 2
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "bcrypt_cost_above_31": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 32
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "jwt_expiration_below_60s": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 59
  refreshThreshold: 40
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "jwt_key_below_8": `
jwt:
  key: kYzJdnp
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "jwt_key_above_256": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9UkYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9UkYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9UkYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9UkYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "low_refresh_threshold": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 0
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "refresh_threshold_gt_expiration": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 601
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$`,

                "crypto_key_too_short": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z`,

                "crypto_key_too_long": `
jwt:
  key: kYzJdnpm6Lj2E7AobZ35RE2itZ2ws82U5tcxrVmeQq1gA4mUfzYQ9t9U
  issuer: FTeX, Inc.
  expirationDuration: 600
  refreshThreshold: 60
general:
  bcryptCost: 8
  cryptoSecret: Xp2s5v8y/B?E(H+MbQeShVmYq3t6w9z$*`,
        }
}</span>
</pre>

		<pre class="file" id="file4" style="display: none">package common

import (
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/shopspring/decimal"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/redis"
        "go.uber.org/zap"
)

// HTTPGetCachedOffer will retrieve and then evict an offer from the Redis cache.
func HTTPGetCachedOffer(cache redis.Redis, logger *logger.Logger, offerID string) (
        models.HTTPExchangeOfferResponse, int, string, error) <span class="cov8" title="25">{
        var (
                err   error
                offer models.HTTPExchangeOfferResponse
        )

        // Retrieve the offer from Redis.
        if err = cache.Get(offerID, &amp;offer); err != nil </span><span class="cov5" title="6">{
                var redisErr *redis.Error

                // If we have a valid Redis package error AND the error is that the key is not found.
                if errors.As(err, &amp;redisErr) &amp;&amp; redisErr.Is(redis.ErrCacheMiss) </span><span class="cov2" title="2">{
                        return offer, http.StatusRequestTimeout, "Currency exchange rate offer has expired", fmt.Errorf("%w", err)
                }</span>

                <span class="cov4" title="4">logger.Warn("unknown error occurred whilst retrieving currency offer from Redis", zap.Error(err))

                return offer, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)</span>
        }

        // Remove the offer from Redis.
        <span class="cov8" title="19">if err = cache.Del(offerID); err != nil </span><span class="cov5" title="6">{
                var redisErr *redis.Error

                // Not a Redis custom error OR not a cache miss for the key (has already expired and could not be deleted).
                if !errors.As(err, &amp;redisErr) || !redisErr.Is(redis.ErrCacheMiss) </span><span class="cov4" title="4">{
                        logger.Warn("unknown error occurred whilst retrieving currency offer from Redis", zap.Error(err))

                        return offer, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>
        }

        <span class="cov7" title="15">return offer, http.StatusOK, "", nil</span>
}

// HTTPTransactionInfoPaginatedRequest will generate the month bounds and record limits using supplied query
// parameters.
func HTTPTransactionInfoPaginatedRequest(auth auth.Auth, monthStr, yearStr, timezoneStr string, pageSize int32) (
        pgtype.Timestamptz, pgtype.Timestamptz, string, error) <span class="cov6" title="12">{
        var (
                startYear      int64
                startMonth     int64
                endYear        int64
                endMonth       int64
                startTime      time.Time
                endTime        time.Time
                pageCursor     string
                periodStartStr string
                periodEndStr   string
                periodStart    pgtype.Timestamptz
                periodEnd      pgtype.Timestamptz
                err            error
        )

        // Generate timestamps.

        // Configure empty timezone to Zulu/UTC.
        if len(timezoneStr) == 0 </span><span class="cov1" title="1">{
                timezoneStr = "+00:00"
        }</span>

        // Extract year and month.
        <span class="cov6" title="12">if startYear, err = strconv.ParseInt(yearStr, 10, 32); err != nil </span><span class="cov0" title="0">{
                return periodStart, periodEnd, pageCursor, fmt.Errorf("invalid year")
        }</span>

        <span class="cov6" title="12">if startMonth, err = strconv.ParseInt(monthStr, 10, 32); err != nil </span><span class="cov0" title="0">{
                return periodStart, periodEnd, pageCursor, fmt.Errorf("invalid month")
        }</span>

        // Setup end year and month.
        <span class="cov6" title="12">endYear = startYear
        endMonth = startMonth + 1

        if endMonth == 13 </span><span class="cov1" title="1">{ //nolint:gomnd
                endMonth = 1
                endYear++
        }</span>

        // Prepare Postgres timestamps.
        <span class="cov6" title="12">periodStartStr = fmt.Sprintf(constants.MonthFormatString(), startYear, startMonth, timezoneStr)
        if startTime, err = time.Parse(time.RFC3339, periodStartStr); err != nil </span><span class="cov1" title="1">{
                return periodStart, periodEnd, pageCursor, fmt.Errorf("start date parse failure %w", err)
        }</span>

        <span class="cov6" title="11">if err = periodStart.Scan(startTime); err != nil </span><span class="cov0" title="0">{
                return periodStart, periodEnd, pageCursor, fmt.Errorf("invalid start date %w", err)
        }</span>

        <span class="cov6" title="11">periodEndStr = fmt.Sprintf(constants.MonthFormatString(), endYear, endMonth, timezoneStr)
        if endTime, err = time.Parse(time.RFC3339, periodEndStr); err != nil </span><span class="cov0" title="0">{
                return periodStart, periodEnd, pageCursor, fmt.Errorf("end date parse failure %w", err)
        }</span>

        <span class="cov6" title="11">if err = periodEnd.Scan(endTime); err != nil </span><span class="cov0" title="0">{
                return periodStart, periodEnd, pageCursor, fmt.Errorf("end start date %w", err)
        }</span>

        // Prepare page cursor.
        <span class="cov6" title="11">if pageCursor, err = HTTPTransactionGeneratePageCursor(auth, periodStartStr, periodEndStr, pageSize); err != nil </span><span class="cov0" title="0">{
                return periodStart, periodEnd, pageCursor, fmt.Errorf("failed to encrypt page cursor %w", err)
        }</span>

        <span class="cov6" title="11">return periodStart, periodEnd, pageCursor, nil</span>
}

// HTTPTransactionGeneratePageCursor will generate the encrypted page cursor.
//
//nolint:wrapcheck
func HTTPTransactionGeneratePageCursor(auth auth.Auth, periodStartStr, periodEndStr string, offset int32) (
        string, error) <span class="cov8" title="25">{
        return auth.EncryptToString([]byte(fmt.Sprintf("%s,%s,%d", periodStartStr, periodEndStr, offset)))
}</span>

// HTTPTransactionUnpackPageCursor will unpack an encrypted page cursor to its component parts.
func HTTPTransactionUnpackPageCursor(auth auth.Auth, pageCursor string) (
        pgtype.Timestamptz, string, pgtype.Timestamptz, string, int32, error) <span class="cov7" title="14">{
        var (
                startPGTS pgtype.Timestamptz
                endPGTS   pgtype.Timestamptz
                buffer    []byte
                err       error
        )

        if buffer, err = auth.DecryptFromString(pageCursor); err != nil </span><span class="cov0" title="0">{
                return startPGTS, "", endPGTS, "", -1, fmt.Errorf("failed to decrypt page cursor %w", err)
        }</span>

        <span class="cov7" title="14">components := strings.Split(string(buffer), ",")
        if len(components) != 3 </span><span class="cov1" title="1">{ //nolint:gomnd
                return startPGTS, "", endPGTS, "", -1, fmt.Errorf("decrypted page curror is invalid")
        }</span>

        <span class="cov7" title="13">offset, err := strconv.ParseInt(components[2], 10, 32)
        if err != nil </span><span class="cov1" title="1">{
                return startPGTS, "", endPGTS, "", -1, fmt.Errorf("failed to parse offset %w", err)
        }</span>

        // Prepare Postgres timestamps.
        <span class="cov6" title="12">startTime, err := time.Parse(time.RFC3339, components[0])
        if err != nil </span><span class="cov0" title="0">{
                return startPGTS, "", endPGTS, "", -1, fmt.Errorf("start date parse failure %w", err)
        }</span>

        <span class="cov6" title="12">if err = startPGTS.Scan(startTime); err != nil </span><span class="cov0" title="0">{
                return startPGTS, "", endPGTS, "", -1, fmt.Errorf("invalid start date %w", err)
        }</span>

        <span class="cov6" title="12">endTime, err := time.Parse(time.RFC3339, components[1])
        if err != nil </span><span class="cov0" title="0">{
                return startPGTS, "", endPGTS, "", -1, fmt.Errorf("end date parse failure %w", err)
        }</span>

        <span class="cov6" title="12">if err = endPGTS.Scan(endTime); err != nil </span><span class="cov0" title="0">{
                return startPGTS, "", endPGTS, "", -1, fmt.Errorf("end start date %w", err)
        }</span>

        <span class="cov6" title="12">return startPGTS, components[0], endPGTS, components[1], int32(offset), nil</span>
}

// HTTPPaginatedTxParams contains the HTTP request as well as the database query parameters.
type HTTPPaginatedTxParams struct {
        // HTTP request input parameters.
        PageSizeStr   string
        PageCursorStr string
        TimezoneStr   string
        MonthStr      string
        YearStr       string

        // Postgres query parameters.
        Offset      int32
        PageSize    int32
        NextPage    string
        PeriodStart pgtype.Timestamptz
        PeriodEnd   pgtype.Timestamptz
}

// HTTPTxParseQueryParams will parse the HTTP request input parameters in database query parameters for the
// paginated Fiat/Crypto transactions requests. It will update the pageCursor to the one required for the
// subsequent query.
func HTTPTxParseQueryParams(auth auth.Auth, logger *logger.Logger, params *HTTPPaginatedTxParams) (int, error) <span class="cov7" title="16">{
        var (
                err            error
                periodStartStr string
                periodEndStr   string
        )

        // Prepare page size.
        if len(params.PageSizeStr) &gt; 0 </span><span class="cov5" title="7">{
                var pageSize int64

                if pageSize, err = strconv.ParseInt(params.PageSizeStr, 10, 32); err != nil </span><span class="cov1" title="1">{
                        return http.StatusBadRequest, fmt.Errorf("invalid page size")
                }</span>

                <span class="cov5" title="6">params.PageSize = int32(pageSize)</span>
        }

        <span class="cov7" title="15">if params.PageSize &lt; 1 </span><span class="cov3" title="3">{
                params.PageSize = 10
        }</span>

        // Decrypt values from page cursor, if present. Otherwise, prepare values using query strings.
        <span class="cov7" title="15">if len(params.PageCursorStr) &gt; 0 </span><span class="cov6" title="11">{
                if params.PeriodStart, periodStartStr, params.PeriodEnd, periodEndStr, params.Offset, err =
                        HTTPTransactionUnpackPageCursor(auth, params.PageCursorStr); err != nil </span><span class="cov0" title="0">{
                        return http.StatusBadRequest, fmt.Errorf("invalid next page")
                }</span>

                // Prepare next page cursor. Adjust offset to move along to next record set.
                <span class="cov6" title="11">if params.NextPage, err = HTTPTransactionGeneratePageCursor(
                        auth, periodStartStr, periodEndStr, params.Offset+params.PageSize); err != nil </span><span class="cov0" title="0">{
                        logger.Info("failed to encrypt currency paginated transactions next page cursor", zap.Error(err))

                        return http.StatusInternalServerError, fmt.Errorf(constants.RetryMessageString())
                }</span>
        } else<span class="cov4" title="4"> {
                if params.PeriodStart, params.PeriodEnd, params.NextPage, err =
                        HTTPTransactionInfoPaginatedRequest(auth,
                                params.MonthStr, params.YearStr, params.TimezoneStr, params.PageSize); err != nil </span><span class="cov0" title="0">{
                        logger.Info("failed to prepare time periods for paginated currency transaction details", zap.Error(err))

                        return http.StatusInternalServerError, fmt.Errorf(constants.RetryMessageString())
                }</span>
        }

        <span class="cov7" title="15">return 0, nil</span>
}

// HTTPValidateOfferRequest will validate an offer request by checking the amount and Fiat currencies are valid.
func HTTPValidateOfferRequest(debitAmount decimal.Decimal, precision int32, fiatCurrencies ...string) (
        []postgres.Currency, error) <span class="cov9" title="31">{
        var (
                err              error
                parsedCurrencies = make([]postgres.Currency, len(fiatCurrencies))
        )

        // Validate the source Fiat currency.
        for idx, fiatCurrencyCode := range fiatCurrencies </span><span class="cov10" title="43">{
                if err = parsedCurrencies[idx].Scan(fiatCurrencyCode); err != nil || !parsedCurrencies[idx].Valid() </span><span class="cov5" title="7">{
                        return parsedCurrencies, fmt.Errorf("invalid Fiat currency %s", fiatCurrencyCode)
                }</span>
        }

        // Check for correct decimal places in source amount.
        <span class="cov8" title="24">if !debitAmount.Equal(debitAmount.Truncate(precision)) || debitAmount.IsNegative() </span><span class="cov2" title="2">{
                return parsedCurrencies, fmt.Errorf("invalid source amount %s", debitAmount.String())
        }</span>

        <span class="cov8" title="22">return parsedCurrencies, nil</span>
}

// HTTPTxDetails will retrieve the Cryptocurrency journal entries for a specified transaction.
func HTTPTxDetails(db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID, txID string) (
        []any, int, string, error) <span class="cov5" title="7">{
        var (
                cryptoEntries []postgres.CryptoJournal
                fiatEntries   []postgres.FiatJournal
                transactionID uuid.UUID
                err           error
        )

        // Extract and validate the transactionID.
        if transactionID, err = uuid.FromString(txID); err != nil </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, "invalid transaction ID", fmt.Errorf("%w", err)
        }</span>

        <span class="cov5" title="6">if fiatEntries, err = db.FiatTxDetails(clientID, transactionID); err != nil </span><span class="cov2" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack Fiat account balance transactionID error", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, balanceErr.Code, balanceErr.Message, fmt.Errorf("%w", err)</span>
        }

        <span class="cov4" title="4">if cryptoEntries, err = db.CryptoTxDetails(clientID, transactionID); err != nil </span><span class="cov2" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack Crypto account balance transactionID error", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, balanceErr.Code, balanceErr.Message, fmt.Errorf("%w", err)</span>
        }

        // Collate journal entries from both Crypto and Fiat for this transaction.
        <span class="cov2" title="2">journalEntries := make([]any, 0, len(cryptoEntries)+len(fiatEntries))

        for _, item := range fiatEntries </span><span class="cov2" title="2">{
                journalEntries = append(journalEntries, item)
        }</span>

        <span class="cov2" title="2">for _, item := range cryptoEntries </span><span class="cov2" title="2">{
                journalEntries = append(journalEntries, item)
        }</span>

        <span class="cov2" title="2">if len(journalEntries) == 0 </span><span class="cov1" title="1">{
                return nil, http.StatusNotFound, "transaction id not found", errors.New("transaction id not found")
        }</span>

        <span class="cov1" title="1">return journalEntries, 0, "", nil</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package common

import (
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gofrs/uuid"
        "github.com/rs/xid"
        "github.com/shopspring/decimal"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/quotes"
        "github.com/surahman/FTeX/pkg/redis"
        "go.uber.org/zap"
)

// HTTPCryptoOpen opens a Crypto account.
func HTTPCryptoOpen(db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID, ticker string) (
        int, string, error) <span class="cov4" title="3">{
        var err error

        if err = db.CryptoCreateAccount(clientID, ticker); err != nil </span><span class="cov3" title="2">{
                var createErr *postgres.Error
                if !errors.As(err, &amp;createErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack open Crypto account error", zap.Error(err))

                        return http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return createErr.Code, createErr.Message, fmt.Errorf("%w", err)</span>
        }

        <span class="cov1" title="1">return 0, "", nil</span>
}

// HTTPCryptoBalance retrieves a balance for a specific Crypto account.
func HTTPCryptoBalance(db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID, ticker string) (
        *postgres.CryptoAccount, int, string, any, error) <span class="cov5" title="4">{
        var (
                accDetails postgres.CryptoAccount
                err        error
        )

        // Validate the ticker.
        if len(ticker) &lt; 1 || len(ticker) &gt; 6 </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, constants.InvalidCurrencyString(), ticker,
                        errors.New(constants.InvalidCurrencyString())
        }</span>

        <span class="cov4" title="3">if accDetails, err = db.CryptoBalance(clientID, ticker); err != nil </span><span class="cov3" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack Crypto account balance currency error", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, balanceErr.Code, balanceErr.Message, nil, fmt.Errorf("%w", err)</span>
        }

        <span class="cov1" title="1">return &amp;accDetails, 0, "", nil, nil</span>
}

// HTTPCryptoOffer will request the conversion rate, prepare the price quote, and store it in the Redis cache.
func HTTPCryptoOffer(auth auth.Auth, cache redis.Redis, logger *logger.Logger, quotes quotes.Quotes,
        clientID uuid.UUID, source, destination string, sourceAmount decimal.Decimal, isPurchase bool) (
        models.HTTPExchangeOfferResponse, int, string, error) <span class="cov9" title="12">{
        var (
                err          error
                offer        models.HTTPExchangeOfferResponse
                offerID      = xid.New().String()
                precision    = constants.DecimalPlacesFiat()
                fiatCurrency = source
        )

        // Configure precision and fiat tickers for Crypto sale.
        if !isPurchase </span><span class="cov6" title="6">{
                precision = constants.DecimalPlacesCrypto()
                fiatCurrency = destination
        }</span>

        // Validate the Fiat currency and source amount.
        <span class="cov9" title="12">if _, err = HTTPValidateOfferRequest(sourceAmount, precision, fiatCurrency); err != nil </span><span class="cov3" title="2">{
                return offer, http.StatusBadRequest, constants.InvalidRequestString(), fmt.Errorf("%w", err)
        }</span>

        // Compile exchange rate offer.
        <span class="cov8" title="10">if offer.Rate, offer.Amount, err = quotes.CryptoConversion(
                source, destination, sourceAmount, isPurchase, nil); err != nil </span><span class="cov3" title="2">{
                logger.Warn("failed to retrieve quote for Cryptocurrency purchase/sale offer", zap.Error(err))

                return offer, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
        }</span>

        // Check to make sure there is a valid Cryptocurrency amount.
        <span class="cov7" title="8">if !offer.Amount.GreaterThan(decimal.NewFromFloat(0)) </span><span class="cov3" title="2">{
                msg := "cryptocurrency purchase/sale amount is too small"

                return offer, http.StatusBadRequest, msg, errors.New(msg)
        }</span>

        <span class="cov6" title="6">offer.PriceQuote.ClientID = clientID
        offer.SourceAcc = source
        offer.DestinationAcc = destination
        offer.DebitAmount = sourceAmount
        offer.Expires = time.Now().Add(constants.FiatOfferTTL()).Unix()
        offer.IsCryptoPurchase = isPurchase
        offer.IsCryptoSale = !isPurchase

        // Encrypt offer ID before returning to client.
        if offer.OfferID, err = auth.EncryptToString([]byte(offerID)); err != nil </span><span class="cov3" title="2">{
                msg := "failed to encrypt offer ID for Cryptocurrency purchase/sale offer"
                logger.Warn(msg, zap.Error(err))

                return offer, http.StatusInternalServerError, constants.RetryMessageString(), errors.New(msg)
        }</span>

        // Store the offer in Redis.
        <span class="cov5" title="4">if err = cache.Set(offerID, &amp;offer, constants.FiatOfferTTL()); err != nil </span><span class="cov3" title="2">{
                msg := "failed to store Cryptocurrency purchase/sale offer in cache"
                logger.Warn(msg, zap.Error(err))

                return offer, http.StatusInternalServerError, constants.RetryMessageString(), errors.New(msg)
        }</span>

        <span class="cov3" title="2">return offer, 0, "", nil</span>
}

// HTTPExchangeCrypto will complete a Cryptocurrency exchange.
func HTTPExchangeCrypto(auth auth.Auth, cache redis.Redis, db postgres.Postgres, logger *logger.Logger,
        clientID uuid.UUID, offerID string) (models.HTTPCryptoTransferResponse, int, string, error) <span class="cov8" title="9">{
        var (
                err          error
                offer        models.HTTPExchangeOfferResponse
                receipt      models.HTTPCryptoTransferResponse
                cryptoTicker string
                fiatTicker   string
                cryptoAmount decimal.Decimal
                fiatAmount   decimal.Decimal
                precision    = constants.DecimalPlacesCrypto()
                transferFunc = db.CryptoPurchase
                fiatCurrency []postgres.Currency
        )

        // Extract Offer ID from request.
        </span><span class="cov8" title="9">{
                var rawOfferID []byte
                if rawOfferID, err = auth.DecryptFromString(offerID); err != nil </span><span class="cov1" title="1">{
                        logger.Warn("failed to decrypt Offer ID for Crypto transfer request", zap.Error(err))

                        return receipt, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov7" title="8">offerID = string(rawOfferID)</span>
        }

        // Retrieve the offer from Redis. Once retrieved, the entry must be removed from the cache to block re-use of
        // the offer. If a database update fails below this point the user will need to re-request an offer.
        <span class="cov7" title="8">{
                var (
                        status int
                        msg    string
                )
                if offer, status, msg, err = HTTPGetCachedOffer(cache, logger, offerID); err != nil </span><span class="cov3" title="2">{
                        return receipt, status, msg, fmt.Errorf("%w", err)
                }</span>
        }

        // Verify that offer is a Crypto offer.
        <span class="cov6" title="6">if !(offer.IsCryptoSale || offer.IsCryptoPurchase) </span><span class="cov1" title="1">{
                msg := "invalid Cryptocurrency exchange offer"

                return receipt, http.StatusBadRequest, msg, errors.New(msg)
        }</span>

        // Verify that the client IDs match.
        <span class="cov6" title="5">if clientID != offer.ClientID </span><span class="cov1" title="1">{
                msg := "clientID mismatch with the Crypto Offer stored in Redis"
                logger.Warn(msg,
                        zap.Strings("Requester &amp; Offer Client IDs", []string{clientID.String(), offer.ClientID.String()}))

                return receipt, http.StatusInternalServerError, constants.RetryMessageString(), errors.New(msg)
        }</span>

        // Configure transaction parameters. Default action should be to purchase a Cryptocurrency using Fiat.
        <span class="cov5" title="4">fiatTicker = offer.SourceAcc
        fiatAmount = offer.DebitAmount
        cryptoTicker = offer.DestinationAcc
        cryptoAmount = offer.Amount

        if offer.IsCryptoSale </span><span class="cov4" title="3">{
                cryptoTicker = offer.SourceAcc
                cryptoAmount = offer.DebitAmount
                fiatTicker = offer.DestinationAcc
                fiatAmount = offer.Amount
                precision = constants.DecimalPlacesCrypto()
                transferFunc = db.CryptoSell
        }</span>

        // Get Fiat currency code.
        <span class="cov5" title="4">if fiatCurrency, err = HTTPValidateOfferRequest(
                offer.Amount, precision, fiatTicker); err != nil </span><span class="cov1" title="1">{
                msg := "failed to extract Fiat currency from Crypto exchange offer"
                logger.Warn(msg, zap.Error(err))

                return receipt, http.StatusBadRequest, msg, fmt.Errorf("%w", err)
        }</span>

        // Execute transfer.
        <span class="cov4" title="3">if receipt.FiatTxReceipt, receipt.CryptoTxReceipt, err =
                transferFunc(clientID, fiatCurrency[0], fiatAmount, cryptoTicker, cryptoAmount); err != nil </span><span class="cov1" title="1">{
                return receipt, http.StatusInternalServerError, err.Error(), fmt.Errorf("%w", err)
        }</span>

        <span class="cov3" title="2">return receipt, 0, "", nil</span>
}

// cryptoBalancePaginatedRequest will convert the encrypted URL query parameter for the ticker and the record
// limit and covert them to a string and integer record limit. The tickerStr is the encrypted pageCursor passed in.
func cryptoBalancePaginatedRequest(auth auth.Auth, tickerStr, limitStr string) (string, int32, error) <span class="cov10" title="16">{
        var (
                ticker    string
                decrypted []byte
                err       error
                limit     int64
        )

        // Decrypt currency ticker string.
        decrypted = []byte("BTC")

        if len(tickerStr) &gt; 0 </span><span class="cov9" title="13">{
                if decrypted, err = auth.DecryptFromString(tickerStr); err != nil </span><span class="cov1" title="1">{
                        return ticker, -1, fmt.Errorf("failed to decrypt next ticker")
                }</span>
        }

        <span class="cov9" title="15">ticker = string(decrypted)

        // Convert record limit to int and set base bound for bad input.
        if len(limitStr) &gt; 0 </span><span class="cov9" title="14">{
                if limit, err = strconv.ParseInt(limitStr, 10, 32); err != nil </span><span class="cov1" title="1">{
                        return ticker, -1, fmt.Errorf("failed to parse record limit")
                }</span>
        }

        <span class="cov9" title="14">if limit &lt; 1 </span><span class="cov4" title="3">{
                limit = 10
        }</span>

        <span class="cov9" title="14">return ticker, int32(limit), nil</span>
}

// HTTPCryptoBalancePaginated retrieves a page of data from the Cryptocurrency account balances and prepares a link to
// the next page of data.
func HTTPCryptoBalancePaginated(auth auth.Auth, db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID,
        pageCursor, pageSizeStr string, isREST bool) (models.HTTPCryptoDetailsPaginated, int, string, error) <span class="cov7" title="8">{
        var (
                ticker        string
                err           error
                pageSize      int32
                nextPage      string
                cryptoDetails models.HTTPCryptoDetailsPaginated
        )

        // Extract and assemble the page cursor and page size.
        if ticker, pageSize, err = cryptoBalancePaginatedRequest(auth, pageCursor, pageSizeStr); err != nil </span><span class="cov3" title="2">{
                return cryptoDetails, http.StatusBadRequest, "invalid page cursor or page size", fmt.Errorf("%w", err)
        }</span>

        <span class="cov6" title="6">if cryptoDetails.AccountBalances, err = db.CryptoBalancesPaginated(clientID, ticker, pageSize+1); err != nil </span><span class="cov3" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack Crypto account balance error", zap.Error(err))

                        return cryptoDetails, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return cryptoDetails, balanceErr.Code, balanceErr.Message, fmt.Errorf("%w", err)</span>
        }

        // Generate the next page link by pulling the last item returned if the page size is N + 1 of the requested.
        <span class="cov5" title="4">if len(cryptoDetails.AccountBalances) &gt; int(pageSize) </span><span class="cov3" title="2">{
                // Generate next page link.
                if nextPage, err =
                        auth.EncryptToString([]byte(cryptoDetails.AccountBalances[pageSize].Ticker)); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to encrypt Cryptocurrency ticker for use as cursor", zap.Error(err))

                        return cryptoDetails, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                // Remove last element.
                <span class="cov3" title="2">cryptoDetails.AccountBalances = cryptoDetails.AccountBalances[:pageSize]

                // Generate naked next page link for REST.
                if isREST </span><span class="cov1" title="1">{
                        cryptoDetails.Links.NextPage = fmt.Sprintf(constants.NextPageRESTFormatString(), nextPage, pageSize)
                }</span> else<span class="cov1" title="1"> {
                        cryptoDetails.Links.PageCursor = nextPage
                }</span>
        }

        <span class="cov5" title="4">return cryptoDetails, 0, "", nil</span>
}

// HTTPCryptoTransactionsPaginated will retrieve a page of Cryptocurrency transactions based on a time range.
func HTTPCryptoTransactionsPaginated(auth auth.Auth, db postgres.Postgres, logger *logger.Logger,
        params *HTTPPaginatedTxParams, clientID uuid.UUID, ticker string, isREST bool) (
        models.HTTPCryptoTransactionsPaginated, int, string, error) <span class="cov7" title="7">{
        var (
                err          error
                httpCode     int
                monthStrLen  = len(params.MonthStr)
                transactions models.HTTPCryptoTransactionsPaginated
        )

        // Check for required parameters.
        if len(params.PageCursorStr) == 0 &amp;&amp; (monthStrLen &lt; 1 || monthStrLen &gt; 2 || len(params.YearStr) != 4) </span><span class="cov1" title="1">{
                msg := "missing required parameters"

                return transactions, http.StatusBadRequest, msg, errors.New(msg)
        }</span>

        // Decrypt values from page cursor, if present. Otherwise, prepare values using query strings.
        <span class="cov6" title="6">if httpCode, err = HTTPTxParseQueryParams(auth, logger, params); err != nil </span><span class="cov0" title="0">{
                return transactions, httpCode, err.Error(), fmt.Errorf("%w", err)
        }</span>

        // Retrieve transaction details page.
        <span class="cov6" title="6">if transactions.TransactionDetails, err = db.CryptoTransactionsPaginated(
                clientID, ticker, params.PageSize+1, params.Offset, params.PeriodStart, params.PeriodEnd); err != nil </span><span class="cov3" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack transactions request error", zap.Error(err))

                        return transactions, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return transactions, balanceErr.Code, balanceErr.Message, fmt.Errorf("%w", err)</span>
        }

        <span class="cov5" title="4">if len(transactions.TransactionDetails) == 0 </span><span class="cov1" title="1">{
                msg := "no transactions"

                return transactions, http.StatusRequestedRangeNotSatisfiable, msg, errors.New(msg)
        }</span>

        // Generate naked next page link. The params will have had the nextPage link generated in the prior methods called.
        <span class="cov4" title="3">if isREST </span><span class="cov3" title="2">{
                params.NextPage = fmt.Sprintf(constants.NextPageRESTFormatString(), params.NextPage, params.PageSize)
        }</span>

        // Check if there are further pages of data. If not, set the next link to be empty.
        <span class="cov4" title="3">if len(transactions.TransactionDetails) &gt; int(params.PageSize) </span><span class="cov3" title="2">{
                transactions.TransactionDetails = transactions.TransactionDetails[:int(params.PageSize)]
        }</span> else<span class="cov1" title="1"> {
                params.NextPage = ""
        }</span>

        // Setup next page or cursor link depending on REST or GraphQL request type.
        <span class="cov4" title="3">if isREST </span><span class="cov3" title="2">{
                transactions.Links.NextPage = params.NextPage
        }</span> else<span class="cov1" title="1"> {
                transactions.Links.PageCursor = params.NextPage
        }</span>

        <span class="cov4" title="3">return transactions, 0, "", nil</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package common

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gofrs/uuid"
        "github.com/rs/xid"
        "github.com/shopspring/decimal"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/quotes"
        "github.com/surahman/FTeX/pkg/redis"
        "github.com/surahman/FTeX/pkg/validator"
        "go.uber.org/zap"
)

// HTTPFiatOpen opens a Fiat account.
func HTTPFiatOpen(db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID, currency string) (
        int, string, error) <span class="cov5" title="4">{
        var (
                pgCurrency postgres.Currency
                err        error
        )

        // Extract and validate the currency.
        if err = pgCurrency.Scan(currency); err != nil || !pgCurrency.Valid() </span><span class="cov1" title="1">{
                return http.StatusBadRequest, constants.InvalidCurrencyString(), fmt.Errorf("%w", err)
        }</span>

        <span class="cov4" title="3">if err = db.FiatCreateAccount(clientID, pgCurrency); err != nil </span><span class="cov3" title="2">{
                var createErr *postgres.Error
                if !errors.As(err, &amp;createErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack open Fiat account error", zap.Error(err))

                        return http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return createErr.Code, createErr.Message, fmt.Errorf("%w", err)</span>
        }

        <span class="cov1" title="1">return 0, "", nil</span>
}

// HTTPFiatDeposit deposits a valid amount into a Fiat account.
func HTTPFiatDeposit(db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID,
        request *models.HTTPDepositCurrencyRequest) (*postgres.FiatAccountTransferResult, int, string, any, error) <span class="cov7" title="7">{
        var (
                pgCurrency      postgres.Currency
                err             error
                transferReceipt *postgres.FiatAccountTransferResult
        )

        if err = validator.ValidateStruct(request); err != nil </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, constants.ValidationString(), err.Error(), fmt.Errorf("%w", err)
        }</span>

        // Extract and validate the currency.
        <span class="cov6" title="6">if err = pgCurrency.Scan(request.Currency); err != nil || !pgCurrency.Valid() </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, constants.InvalidCurrencyString(), request.Currency, fmt.Errorf("%w", err)
        }</span>

        // Check for correct decimal places.
        <span class="cov6" title="5">if !request.Amount.Equal(request.Amount.Truncate(constants.DecimalPlacesFiat())) || request.Amount.IsNegative() </span><span class="cov3" title="2">{
                return nil, http.StatusBadRequest, "invalid amount", request.Amount, fmt.Errorf("%w", err)
        }</span>

        <span class="cov4" title="3">if transferReceipt, err = db.FiatExternalTransfer(context.Background(),
                &amp;postgres.FiatTransactionDetails{
                        ClientID: clientID,
                        Currency: pgCurrency,
                        Amount:   request.Amount}); err != nil </span><span class="cov3" title="2">{
                var createErr *postgres.Error
                if !errors.As(err, &amp;createErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack deposit Fiat account error", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, createErr.Code, createErr.Message, nil, fmt.Errorf("%w", err)</span>
        }

        <span class="cov1" title="1">return transferReceipt, 0, "", nil, nil</span>
}

// HTTPFiatOffer retrieves an exchange rate offer from a quote provider and stores it in the Redis session cache.
func HTTPFiatOffer(auth auth.Auth, cache redis.Redis, logger *logger.Logger, quotes quotes.Quotes, clientID uuid.UUID,
        request *models.HTTPExchangeOfferRequest) (*models.HTTPExchangeOfferResponse, int, string, any, error) <span class="cov6" title="6">{
        var (
                err     error
                offer   models.HTTPExchangeOfferResponse
                offerID = xid.New().String()
        )

        if err = validator.ValidateStruct(request); err != nil </span><span class="cov0" title="0">{
                return nil, http.StatusBadRequest, constants.ValidationString(), err.Error(), fmt.Errorf("%w", err)
        }</span>

        // Extract and validate the currency.
        <span class="cov6" title="6">if _, err = HTTPValidateOfferRequest(request.SourceAmount, constants.DecimalPlacesFiat(),
                request.SourceCurrency, request.DestinationCurrency); err != nil </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, constants.InvalidRequestString(), err.Error(), fmt.Errorf("%w", err)
        }</span>

        // Compile exchange rate offer.
        <span class="cov6" title="5">if offer.Rate, offer.Amount, err = quotes.FiatConversion(
                request.SourceCurrency, request.DestinationCurrency, request.SourceAmount, nil); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to retrieve quote for Fiat currency conversion", zap.Error(err))

                return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
        }</span>

        // Check to make sure there is a valid Fiat amount.
        <span class="cov5" title="4">if !offer.Amount.GreaterThan(decimal.NewFromFloat(0)) </span><span class="cov1" title="1">{
                msg := "fiat currency purchase/sale amount is too small"

                return nil, http.StatusBadRequest, msg, nil, errors.New(msg)
        }</span>

        <span class="cov4" title="3">offer.ClientID = clientID
        offer.SourceAcc = request.SourceCurrency
        offer.DestinationAcc = request.DestinationCurrency
        offer.DebitAmount = request.SourceAmount
        offer.Expires = time.Now().Add(constants.FiatOfferTTL()).Unix()

        // Encrypt offer ID before returning to client.
        if offer.OfferID, err = auth.EncryptToString([]byte(offerID)); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to encrypt offer ID for Fiat conversion", zap.Error(err))

                return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
        }</span>

        // Store the offer in Redis.
        <span class="cov3" title="2">if err = cache.Set(offerID, &amp;offer, constants.FiatOfferTTL()); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to store Fiat conversion offer in cache", zap.Error(err))

                return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
        }</span>

        <span class="cov1" title="1">return &amp;offer, 0, "", nil, nil</span>
}

// HTTPFiatTransfer will retrieve an offer from the session cache, validate it, then update the database.
func HTTPFiatTransfer(auth auth.Auth, cache redis.Redis, db postgres.Postgres, logger *logger.Logger,
        clientID uuid.UUID, request *models.HTTPTransferRequest) (*models.HTTPFiatTransferResponse, int, string, any, error) <span class="cov9" title="12">{
        var (
                err              error
                offer            models.HTTPExchangeOfferResponse
                receipt          models.HTTPFiatTransferResponse
                offerID          string
                parsedCurrencies []postgres.Currency
        )

        if err = validator.ValidateStruct(request); err != nil </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, constants.ValidationString(), err.Error(), fmt.Errorf("%w", err)
        }</span>

        // Extract Offer ID from request.
        <span class="cov8" title="11">{
                var rawOfferID []byte
                if rawOfferID, err = auth.DecryptFromString(request.OfferID); err != nil </span><span class="cov1" title="1">{
                        logger.Warn("failed to decrypt Offer ID for Fiat transfer request", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
                }</span>

                <span class="cov8" title="10">offerID = string(rawOfferID)</span>
        }

        // Retrieve the offer from Redis. Once retrieved, the entry must be removed from the cache to block re-use of the
        // offer. If a database update fails below this point the user will need to re-request an offer.
        <span class="cov8" title="10">{
                var (
                        httpStatus int
                        httpMsg    string
                )
                if offer, httpStatus, httpMsg, err = HTTPGetCachedOffer(cache, logger, offerID); err != nil </span><span class="cov4" title="3">{
                        return nil, httpStatus, httpMsg, nil, fmt.Errorf("%w", err)
                }</span>
        }

        // Verify that the client IDs match.
        <span class="cov7" title="7">if clientID != offer.ClientID </span><span class="cov1" title="1">{
                logger.Warn("clientID mismatch with Fiat Offer stored in Redis",
                        zap.Strings("Requester &amp; Offer Client IDs", []string{clientID.String(), offer.ClientID.String()}))

                return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
        }</span>

        // Verify the offer is for a Fiat exchange.
        <span class="cov6" title="6">if offer.IsCryptoPurchase || offer.IsCryptoSale </span><span class="cov3" title="2">{
                return nil, http.StatusBadRequest, "invalid Fiat currency exchange offer", nil, fmt.Errorf("%w", err)
        }</span>

        // Get currency codes.
        <span class="cov5" title="4">if parsedCurrencies, err = HTTPValidateOfferRequest(
                offer.Amount, constants.DecimalPlacesFiat(), offer.SourceAcc, offer.DestinationAcc); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to extract source and destination currencies from Fiat exchange offer",
                        zap.Error(err))

                return nil, http.StatusBadRequest, err.Error(), nil, fmt.Errorf("%w", err)
        }</span>

        // Execute exchange.
        <span class="cov4" title="3">srcTxDetails := &amp;postgres.FiatTransactionDetails{
                ClientID: offer.ClientID,
                Currency: parsedCurrencies[0],
                Amount:   offer.DebitAmount,
        }
        dstTxDetails := &amp;postgres.FiatTransactionDetails{
                ClientID: offer.ClientID,
                Currency: parsedCurrencies[1],
                Amount:   offer.Amount,
        }

        if receipt.SrcTxReceipt, receipt.DstTxReceipt, err = db.
                FiatInternalTransfer(context.Background(), srcTxDetails, dstTxDetails); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to complete internal Fiat transfer", zap.Error(err))

                return nil, http.StatusBadRequest, "please check you have both currency accounts and enough funds.",
                        nil, fmt.Errorf("%w", err)
        }</span>

        <span class="cov3" title="2">return &amp;receipt, 0, "", nil, nil</span>
}

// HTTPFiatBalance retrieves the account balance for a specific Fiat currency.
func HTTPFiatBalance(db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID, ticker string) (
        *postgres.FiatAccount, int, string, any, error) <span class="cov5" title="4">{
        var (
                accDetails postgres.FiatAccount
                currency   postgres.Currency
                err        error
        )

        // Extract and validate the currency.
        if err = currency.Scan(ticker); err != nil || !currency.Valid() </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, constants.InvalidCurrencyString(), ticker, fmt.Errorf("%w", err)
        }</span>

        <span class="cov4" title="3">if accDetails, err = db.FiatBalance(clientID, currency); err != nil </span><span class="cov3" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack Fiat account balance currency error", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, balanceErr.Code, balanceErr.Message, nil, fmt.Errorf("%w", err)</span>
        }

        <span class="cov1" title="1">return &amp;accDetails, 0, "", nil, nil</span>
}

// HTTPFiatBalancePaginatedRequest will convert the encrypted URL query parameter for the currency and the record limit
// and covert them to a currency and integer record limit. The currencyStr is the encrypted pageCursor passed in.
func HTTPFiatBalancePaginatedRequest(auth auth.Auth, currencyStr, limitStr string) (postgres.Currency, int32, error) <span class="cov10" title="16">{
        var (
                currency  postgres.Currency
                decrypted []byte
                err       error
                limit     int64
        )

        // Decrypt currency string and covert to currency struct.
        decrypted = []byte("AED")

        if len(currencyStr) &gt; 0 </span><span class="cov8" title="10">{
                if decrypted, err = auth.DecryptFromString(currencyStr); err != nil </span><span class="cov1" title="1">{
                        return currency, -1, fmt.Errorf("failed to decrypt next currency")
                }</span>
        }

        <span class="cov9" title="15">if err = currency.Scan(string(decrypted)); err != nil </span><span class="cov0" title="0">{
                return currency, -1, fmt.Errorf("failed to parse currency")
        }</span>

        // Convert record limit to int and set base bound for bad input.
        <span class="cov9" title="15">if len(limitStr) &gt; 0 </span><span class="cov8" title="11">{
                if limit, err = strconv.ParseInt(limitStr, 10, 32); err != nil </span><span class="cov0" title="0">{
                        return currency, -1, fmt.Errorf("failed to parse record limit")
                }</span>
        }

        <span class="cov9" title="15">if limit &lt; 1 </span><span class="cov6" title="5">{
                limit = 10
        }</span>

        <span class="cov9" title="15">return currency, int32(limit), nil</span>
}

// HTTPFiatBalancePaginated will retrieve a page of all Fiat account balances.
func HTTPFiatBalancePaginated(auth auth.Auth, db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID,
        pageCursorStr, pageSizeStr string, isREST bool) (*models.HTTPFiatDetailsPaginated, int, string, error) <span class="cov7" title="8">{
        var (
                accDetails models.HTTPFiatDetailsPaginated
                currency   postgres.Currency
                err        error
                nextPage   string
                pageSize   int32
        )

        // Extract and assemble the page cursor and page size.
        if currency, pageSize, err = HTTPFiatBalancePaginatedRequest(auth, pageCursorStr, pageSizeStr); err != nil </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, "invalid page cursor or page size", fmt.Errorf("%w", err)
        }</span>

        <span class="cov7" title="7">if accDetails.AccountBalances, err = db.FiatBalancePaginated(clientID, currency, pageSize+1); err != nil </span><span class="cov3" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack Fiat account balance currency error", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, balanceErr.Code, balanceErr.Message, fmt.Errorf("%w", err)</span>
        }

        // Generate the next page link by pulling the last item returned if the page size is N + 1 of the requested.
        <span class="cov6" title="5">if len(accDetails.AccountBalances) &gt; int(pageSize) </span><span class="cov4" title="3">{
                // Generate next page link.
                if nextPage, err = auth.EncryptToString([]byte(accDetails.AccountBalances[pageSize].Currency)); err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to encrypt Fiat currency for use as cursor", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), fmt.Errorf("%w", err)
                }</span>

                // Remove last element.
                <span class="cov3" title="2">accDetails.AccountBalances = accDetails.AccountBalances[:pageSize]

                // Generate naked next page link for REST.
                if isREST </span><span class="cov3" title="2">{
                        accDetails.Links.NextPage = fmt.Sprintf(constants.NextPageRESTFormatString(), nextPage, pageSize)
                }</span> else<span class="cov0" title="0"> {
                        accDetails.Links.PageCursor = nextPage
                }</span>
        }

        <span class="cov5" title="4">return &amp;accDetails, 0, "", nil</span>
}

// HTTPFiatTransactionsPaginated will retrieve a page of all Fiat transactions for a specific account and period.
//
//nolint:cyclop
func HTTPFiatTransactionsPaginated(auth auth.Auth, db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID,
        ticker string, params *HTTPPaginatedTxParams, isREST bool) (
        *models.HTTPFiatTransactionsPaginated, int, string, any, error) <span class="cov7" title="7">{
        var (
                journalEntries models.HTTPFiatTransactionsPaginated
                currency       postgres.Currency
                err            error
        )

        // Extract and validate the currency.
        if err = currency.Scan(ticker); err != nil || !currency.Valid() </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, constants.InvalidCurrencyString(), ticker, fmt.Errorf("%w", err)
        }</span>

        // Check for required parameters.
        <span class="cov6" title="6">if len(params.PageCursorStr) == 0 &amp;&amp; (len(params.MonthStr) == 0 || len(params.YearStr) == 0) </span><span class="cov1" title="1">{
                return nil, http.StatusBadRequest, "missing required parameters", nil, fmt.Errorf("%w", err)
        }</span>

        // Decrypt values from page cursor, if present. Otherwise, prepare values using query strings.
        <span class="cov6" title="5">httpCode, err := HTTPTxParseQueryParams(auth, logger, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, httpCode, err.Error(), nil, fmt.Errorf("%w", err)
        }</span>

        // Retrieve transaction details page.
        <span class="cov6" title="5">if journalEntries.TransactionDetails, err = db.FiatTransactionsPaginated(
                clientID, currency, params.PageSize+1, params.Offset, params.PeriodStart, params.PeriodEnd); err != nil </span><span class="cov3" title="2">{
                var balanceErr *postgres.Error
                if !errors.As(err, &amp;balanceErr) </span><span class="cov1" title="1">{
                        logger.Info("failed to unpack Fiat transactions request error", zap.Error(err))

                        return nil, http.StatusInternalServerError, constants.RetryMessageString(), nil, fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, balanceErr.Code, balanceErr.Message, nil, fmt.Errorf("%w", err)</span>
        }

        <span class="cov4" title="3">if len(journalEntries.TransactionDetails) == 0 </span><span class="cov1" title="1">{
                return nil, http.StatusRequestedRangeNotSatisfiable, "no transactions", nil, fmt.Errorf("%w", err)
        }</span>

        // Generate naked next page link for REST.
        <span class="cov3" title="2">if isREST </span><span class="cov3" title="2">{
                params.NextPage = fmt.Sprintf(constants.NextPageRESTFormatString(), params.NextPage, params.PageSize)
        }</span>

        // Check if there are further pages of data. If not, set the next link to be empty.
        <span class="cov3" title="2">if len(journalEntries.TransactionDetails) &gt; int(params.PageSize) </span><span class="cov1" title="1">{
                journalEntries.TransactionDetails = journalEntries.TransactionDetails[:int(params.PageSize)]
        }</span> else<span class="cov1" title="1"> {
                params.NextPage = ""
        }</span>

        // Setup next page or cursor link depending on REST or GraphQL request type.
        <span class="cov3" title="2">if isREST </span><span class="cov3" title="2">{
                journalEntries.Links.NextPage = params.NextPage
        }</span> else<span class="cov0" title="0"> {
                journalEntries.Links.PageCursor = params.NextPage
        }</span>

        <span class="cov3" title="2">return &amp;journalEntries, 0, "", nil, nil</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package common

import (
        "errors"
        "net/http"

        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/redis"
        "go.uber.org/zap"
)

// HTTPHealthcheck checks if the service is healthy by pinging the data tier comprised of Postgres and Redis.
func HTTPHealthcheck(db postgres.Postgres, cache redis.Redis, logger *logger.Logger) (int, string, error) <span class="cov10" title="3">{
        // Database health.
        if err := db.Healthcheck(); err != nil </span><span class="cov1" title="1">{
                msg := "healthcheck failed, Postgres database could not be pinged"
                logger.Warn(msg, zap.Error(err))

                return http.StatusServiceUnavailable, msg, errors.New(msg)
        }</span>

        // Cache health.
        <span class="cov6" title="2">if err := cache.Healthcheck(); err != nil </span><span class="cov1" title="1">{
                msg := "healthcheck failed, Redis cache could not be pinged"
                logger.Warn(msg, zap.Error(err))

                return http.StatusServiceUnavailable, msg, errors.New(msg)
        }</span>

        <span class="cov1" title="1">return http.StatusOK, "healthy", nil</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package common

import (
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        modelsPostgres "github.com/surahman/FTeX/pkg/models/postgres"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/validator"
        "go.uber.org/zap"
)

// HTTPGenerateTestUsers will generate a number of test users for testing.
func HTTPGenerateTestUsers() map[string]*modelsPostgres.UserAccount <span class="cov1" title="1">{
        users := make(map[string]*modelsPostgres.UserAccount)
        username := "username%d"
        password := "user-password-%d"
        firstname := "firstname-%d"
        lastname := "lastname-%d"
        email := "user%d@email-address.com"

        for idx := 1; idx &lt; 5; idx++ </span><span class="cov7" title="4">{
                uname := fmt.Sprintf(username, idx)
                users[uname] = &amp;modelsPostgres.UserAccount{
                        UserLoginCredentials: modelsPostgres.UserLoginCredentials{
                                Username: username,
                                Password: password,
                        },
                        FirstName: firstname,
                        LastName:  lastname,
                        Email:     email,
                }
        }</span>

        <span class="cov1" title="1">return users</span>
}

// HTTPRegisterUser will create a row in the database's users' table corresponding to a new user.
func HTTPRegisterUser(auth auth.Auth, db postgres.Postgres, logger *logger.Logger, user *modelsPostgres.UserAccount) (
        *models.JWTAuthResponse, string, int, any, error) <span class="cov7" title="5">{
        var (
                authToken *models.JWTAuthResponse
                clientID  uuid.UUID
                err       error
        )

        if err = validator.ValidateStruct(user); err != nil </span><span class="cov1" title="1">{
                return nil, constants.ValidationString(), http.StatusBadRequest, fmt.Errorf("%w", err), fmt.Errorf("%w", err)
        }</span>

        <span class="cov7" title="4">if user.Password, err = auth.HashPassword(user.Password); err != nil </span><span class="cov1" title="1">{
                logger.Error("failure hashing password", zap.Error(err))

                return nil, constants.RetryMessageString(), http.StatusInternalServerError, nil, fmt.Errorf("%w", err)
        }</span>

        <span class="cov5" title="3">if clientID, err = db.UserRegister(user); err != nil </span><span class="cov1" title="1">{
                var registerErr *postgres.Error
                if !errors.As(err, &amp;registerErr) </span><span class="cov0" title="0">{
                        logger.Warn("failed to extract create user account error", zap.Error(err))

                        return nil, constants.RetryMessageString(), http.StatusInternalServerError, nil, fmt.Errorf("%w", err)
                }</span>

                <span class="cov1" title="1">return nil, err.Error(), registerErr.Code, nil, fmt.Errorf("%w", err)</span>
        }

        <span class="cov4" title="2">if authToken, err = auth.GenerateJWT(clientID); err != nil </span><span class="cov1" title="1">{
                logger.Error("failure generating JWT during account creation", zap.Error(err))

                return nil, err.Error(), http.StatusInternalServerError, nil, fmt.Errorf("%w", err)
        }</span>

        <span class="cov1" title="1">return authToken, "", 0, nil, nil</span>
}

// HTTPLoginUser will complete a login request for a user.
func HTTPLoginUser(auth auth.Auth, db postgres.Postgres, logger *logger.Logger,
        loginRequest *modelsPostgres.UserLoginCredentials) (*models.JWTAuthResponse, string, int, any, error) <span class="cov7" title="5">{
        var (
                err            error
                authToken      *models.JWTAuthResponse
                clientID       uuid.UUID
                hashedPassword string
        )

        if err = validator.ValidateStruct(loginRequest); err != nil </span><span class="cov1" title="1">{
                return nil, constants.ValidationString(), http.StatusBadRequest, fmt.Errorf("%w", err), fmt.Errorf("%w", err)
        }</span>

        <span class="cov7" title="4">if clientID, hashedPassword, err = db.UserCredentials(loginRequest.Username); err != nil </span><span class="cov1" title="1">{
                return nil, "invalid credentials", http.StatusForbidden, nil, fmt.Errorf("%w", err)
        }</span>

        <span class="cov5" title="3">if err = auth.CheckPassword(hashedPassword, loginRequest.Password); err != nil </span><span class="cov1" title="1">{
                return nil, "invalid username or password", http.StatusForbidden, nil, fmt.Errorf("%w", err)
        }</span>

        <span class="cov4" title="2">if authToken, err = auth.GenerateJWT(clientID); err != nil </span><span class="cov1" title="1">{
                logger.Error("failure generating JWT during login", zap.Error(err))

                return nil, err.Error(), http.StatusInternalServerError, nil, fmt.Errorf("%w", err)
        }</span>

        <span class="cov1" title="1">return authToken, "", 0, nil, nil</span>
}

// HTTPRefreshLogin validates a JWT token and issues a fresh token.
func HTTPRefreshLogin(auth auth.Auth, db postgres.Postgres, logger *logger.Logger,
        clientID uuid.UUID, expiresAt int64) (*models.JWTAuthResponse, string, int, error) <span class="cov7" title="5">{
        var (
                err         error
                freshToken  *models.JWTAuthResponse
                accountInfo modelsPostgres.User
        )

        if accountInfo, err = db.UserGetInfo(clientID); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to read user record for a valid JWT",
                        zap.String("username", accountInfo.Username), zap.Error(err))

                return nil, constants.RetryMessageString(), http.StatusInternalServerError, fmt.Errorf("%w", err)
        }</span>

        <span class="cov7" title="4">if accountInfo.IsDeleted </span><span class="cov1" title="1">{
                logger.Warn("attempt to refresh a JWT for a deleted user", zap.String("clientID", accountInfo.Username))

                return nil, "invalid token", http.StatusForbidden, fmt.Errorf("%w", err)
        }</span>

        // Do not refresh tokens that are outside the refresh threshold. Tokens could expire during the execution of
        // this handler, but expired ones would be rejected during token validation. Thus, it is not necessary to
        // re-check expiration.
        <span class="cov5" title="3">if expiresAt-time.Now().Unix() &gt; auth.RefreshThreshold() </span><span class="cov1" title="1">{
                return nil, fmt.Sprintf("JWT is still valid for more than %d seconds", auth.RefreshThreshold()),
                        http.StatusNotExtended, fmt.Errorf("%w", err)
        }</span>

        <span class="cov4" title="2">if freshToken, err = auth.GenerateJWT(clientID); err != nil </span><span class="cov1" title="1">{
                logger.Error("failure generating JWT during token refresh", zap.Error(err))

                return nil, err.Error(), http.StatusInternalServerError, fmt.Errorf("%w", err)
        }</span>

        <span class="cov1" title="1">return freshToken, "", 0, nil</span>
}

// HTTPDeleteUser validates a JWT token and issues a fresh token.
func HTTPDeleteUser(auth auth.Auth, db postgres.Postgres, logger *logger.Logger, clientID uuid.UUID,
        deleteRequest *models.HTTPDeleteUserRequest) (string, int, any, error) <span class="cov10" title="8">{
        var (
                err         error
                userAccount modelsPostgres.User
        )

        if err = validator.ValidateStruct(deleteRequest); err != nil </span><span class="cov1" title="1">{
                return constants.ValidationString(), http.StatusBadRequest, fmt.Errorf("%w", err), fmt.Errorf("%w", err)
        }</span>

        // Get user account information to validate against.
        <span class="cov9" title="7">if userAccount, err = db.UserGetInfo(clientID); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to read user record during an account deletion request",
                        zap.String("clientID", clientID.String()), zap.Error(err))

                return constants.RetryMessageString(), http.StatusInternalServerError, nil, fmt.Errorf("%w", err)
        }</span>

        // Validate if the user account is already deleted.
        <span class="cov8" title="6">if userAccount.Username != deleteRequest.Username </span><span class="cov1" title="1">{
                return "invalid deletion request", http.StatusForbidden, nil, fmt.Errorf("%w", err)
        }</span>

        // Check the confirmation message.
        <span class="cov7" title="5">if fmt.Sprintf(constants.DeleteUserAccountConfirmation(), userAccount.Username) != deleteRequest.Confirmation </span><span class="cov1" title="1">{
                msg := "incorrect or incomplete deletion request confirmation"

                return msg, http.StatusBadRequest, nil, errors.New(msg)
        }</span>

        // Check to make sure the account is not already deleted.
        <span class="cov7" title="4">if userAccount.IsDeleted </span><span class="cov1" title="1">{
                logger.Warn("attempt to delete an already deleted user account", zap.String("username", userAccount.Username))

                msg := "user account is already deleted"

                return msg, http.StatusForbidden, nil, errors.New(msg)
        }</span>

        <span class="cov5" title="3">if err = auth.CheckPassword(userAccount.Password, deleteRequest.Password); err != nil </span><span class="cov1" title="1">{
                msg := "invalid user credentials"

                return msg, http.StatusForbidden, nil, errors.New(msg)
        }</span>

        // Mark the account as deleted.
        <span class="cov4" title="2">if err = db.UserDelete(clientID); err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to mark a user record as deleted", zap.String("username", userAccount.Username), zap.Error(err))

                return constants.RetryMessageString(), http.StatusInternalServerError, nil, errors.New(constants.RetryMessageString())
        }</span>

        <span class="cov1" title="1">return "", 0, nil, nil</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package configloader

import (
        "github.com/spf13/afero"
        "github.com/spf13/viper"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/validator"
)

// Load will load configurations stored in a file system into a configuration container struct.
func Load[T any](fs afero.Fs, cfg *T, filename, prefix, format string) (err error) <span class="cov10" title="12">{
        viper.SetFs(fs)
        viper.SetConfigName(filename)
        viper.SetConfigType(format)
        viper.AddConfigPath(constants.EtcDir())
        viper.AddConfigPath(constants.HomeDir())
        viper.AddConfigPath(constants.BaseDir())

        viper.SetEnvPrefix(prefix)
        viper.AutomaticEnv()

        if err = viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="12">if err = viper.Unmarshal(cfg); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="12">if err = validator.ValidateStruct(cfg); err != nil </span><span class="cov8" title="8">{
                return
        }</span>

        <span class="cov6" title="4">return</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package configloader

// configTestData will return a map of test data containing valid and invalid test configs.
func configTestData() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "empty": ``,
                "valid": `
parentLevel1:
  childOne: childOne_key
  childTwo: 999
  childThree: true
parentLevel2:
  childOne: 5
  childTwo: true
  childThree: "abcdef"`,
                "valid - required": `
parentLevel1:
  childOne: childOne_key
  childTwo: 999
parentLevel2:
  childOne: 5
  childThree: "abcdef"`,
                "invalid - no lvl 1": `
parentLevel2:
  childOne: 5
  childTwo: true
  childThree: "abcdef"`,
                "invalid - no lvl1 child1": `
parentLevel1:
  childTwo: 999
  childThree: true
parentLevel2:
  childOne: 5
  childTwo: true
  childThree: "abcdef"`,
                "invalid - lvl1 child1 below threshold": `
parentLevel1:
  childOne: childOne_key
  childTwo: 9
  childThree: true
parentLevel2:
  childOne: 5
  childTwo: true
  childThree: "abcdef"`,
                "invalid - lvl2 no child1": `
parentLevel1:
  childOne: childOne_key
  childTwo: 999
  childThree: true
parentLevel2:
  childTwo: true
  childThree: "abcdef"`,
                "invalid - lvl2 child1 below threshold": `
parentLevel1:
  childOne: childOne_key
  childTwo: 999
  childThree: true
parentLevel2:
  childOne: 2
  childTwo: true
  childThree: "abcdef"`,
                "invalid - lvl2 no child3": `
parentLevel1:
  childOne: childOne_key
  childTwo: 999
  childThree: true
parentLevel2:
  childOne: 5
  childTwo: true`,
                "invalid - lvl2 child3 below threshold": `
parentLevel1:
  childOne: childOne_key
  childTwo: 999
  childThree: true
parentLevel2:
  childOne: 5
  childTwo: true
  childThree: "ab"`,
        }
}</span>
</pre>

		<pre class="file" id="file11" style="display: none">package constants

import (
        "time"
)

const (
        // Configuration file directories.
        configEtcDir  = "/etc/FTeX.conf/"
        configHomeDir = "$HOME/.FTeX/"
        configBaseDir = "./configs/"

        // Configuration file names.
        loggerConfigFileName   = "LoggerConfig.yaml"
        postgresConfigFileName = "PostgresConfig.yaml"
        redisConfigFileName    = "RedisConfig.yaml"
        quotesConfigFileName   = "QuotesConfig.yaml"
        authConfigFileName     = "AuthConfig.yaml"
        restConfigFileName     = "HTTPRESTConfig.yaml"
        graphqlConfigFileName  = "HTTPGraphQLConfig.yaml"

        // Environment variables.
        githubCIKey    = "GITHUB_ACTIONS_CI"
        loggerPrefix   = "LOGGER"
        postgresPrefix = "POSTGRES"
        redisPrefix    = "REDIS"
        quotesPrefix   = "QUOTES"
        authPrefix     = "AUTH"
        restPrefix     = "REST"
        graphQLPrefix  = "GRAPHQL"

        // Miscellaneous.
        postgresDSN                   = "user=%s password=%s host=%s port=%d dbname=%s connect_timeout=%d sslmode=disable"
        testDatabaseName              = "ftex_db_test"
        deleteUserAccountConfirmation = "I understand the consequences, delete my user account %s"
        fiatDecimalPlaces             = int32(2)
        cryptoDecimalPlaces           = int32(8)
        fiatOfferTTL                  = 2 * time.Minute
        cryptoOfferTTL                = 2 * time.Minute
        monthFormatString             = "%d-%02d-01T00:00:00%s" // YYYY-MM-DDTHH:MM:SS+HH:MM (last section is +/- timezone.)
        nextPageRESTFormatString      = "?pageCursor=%s&amp;pageSize=%d"
        specialAccountFiat            = "fiat-currencies"
        specialAccountCrypto          = "crypto-currencies"
        invalidRequestString          = "invalid request"
        validationSting               = "validation"
        invalidCurrencyString         = "invalid currency"
        retryMessageString            = "please retry your request later"
        clientIDCtxKey                = "ftex-client-id-context-key"
        expiresAtCtxKey               = "ftex-expires-at-context-key"
)

var (
        twoSecondDuration   = 2 * time.Second
        threeSecondDuration = 3 * time.Second
)

// EtcDir returns the configuration directory in Etc.
func EtcDir() string <span class="cov1" title="1">{
        return configEtcDir
}</span>

// HomeDir returns the configuration directory in users home.
func HomeDir() string <span class="cov1" title="1">{
        return configHomeDir
}</span>

// BaseDir returns the configuration base directory in the root of the application.
func BaseDir() string <span class="cov1" title="1">{
        return configBaseDir
}</span>

// GithubCIKey is the key for the environment variable expected to be present in the GH CI runner.
func GithubCIKey() string <span class="cov1" title="1">{
        return githubCIKey
}</span>

// LoggerFileName returns the Zap logger configuration file name.
func LoggerFileName() string <span class="cov1" title="1">{
        return loggerConfigFileName
}</span>

// LoggerPrefix returns the environment variable prefix for the Zap logger.
func LoggerPrefix() string <span class="cov1" title="1">{
        return loggerPrefix
}</span>

// PostgresFileName returns the Postgres configuration file name.
func PostgresFileName() string <span class="cov1" title="1">{
        return postgresConfigFileName
}</span>

// PostgresPrefix returns the environment variable prefix for Postgres.
func PostgresPrefix() string <span class="cov1" title="1">{
        return postgresPrefix
}</span>

// PostgresDSN returns the format string for the Postgres Data Source Name used to connect to the database.
func PostgresDSN() string <span class="cov1" title="1">{
        return postgresDSN
}</span>

// TestDatabaseName returns the name of the database used in test suites.
func TestDatabaseName() string <span class="cov1" title="1">{
        return testDatabaseName
}</span>

// RedisFileName returns the Redis server configuration file name.
func RedisFileName() string <span class="cov1" title="1">{
        return redisConfigFileName
}</span>

// RedisPrefix returns the environment variable prefix for the Redis server.
func RedisPrefix() string <span class="cov1" title="1">{
        return redisPrefix
}</span>

// QuotesFileName returns the quotes configuration file name.
func QuotesFileName() string <span class="cov1" title="1">{
        return quotesConfigFileName
}</span>

// QuotesPrefix returns the environment variable prefix for the quotes.
func QuotesPrefix() string <span class="cov1" title="1">{
        return quotesPrefix
}</span>

// AuthFileName returns the authentication configuration file name.
func AuthFileName() string <span class="cov1" title="1">{
        return authConfigFileName
}</span>

// AuthPrefix returns the environment variable prefix for authentication.
func AuthPrefix() string <span class="cov1" title="1">{
        return authPrefix
}</span>

// HTTPRESTFileName returns the HTTP REST endpoint configuration file name.
func HTTPRESTFileName() string <span class="cov1" title="1">{
        return restConfigFileName
}</span>

// HTTPRESTPrefix returns the environment variable prefix for the HTTP REST endpoint.
func HTTPRESTPrefix() string <span class="cov1" title="1">{
        return restPrefix
}</span>

// DeleteUserAccountConfirmation is the format string template confirmation message used to delete a user account.
func DeleteUserAccountConfirmation() string <span class="cov1" title="1">{
        return deleteUserAccountConfirmation
}</span>

// DecimalPlacesFiat the number of decimal places Fiat currency can have.
func DecimalPlacesFiat() int32 <span class="cov1" title="1">{
        return fiatDecimalPlaces
}</span>

// DecimalPlacesCrypto the number of decimal places Cryptocurrency can have.
func DecimalPlacesCrypto() int32 <span class="cov1" title="1">{
        return cryptoDecimalPlaces
}</span>

// FiatOfferTTL is the time duration that a Fiat conversion rate offer will be valid for.
func FiatOfferTTL() time.Duration <span class="cov1" title="1">{
        return fiatOfferTTL
}</span>

// CryptoOfferTTL is the time duration that a Crypto conversion rate offer will be valid for.
func CryptoOfferTTL() time.Duration <span class="cov1" title="1">{
        return cryptoOfferTTL
}</span>

// MonthFormatString is the base RFC3339 format string for a configurable month, year, and timezone.
func MonthFormatString() string <span class="cov10" title="6">{
        return monthFormatString
}</span>

// NextPageRESTFormatString is the format for the naked next page link for REST requests responses.
func NextPageRESTFormatString() string <span class="cov1" title="1">{
        return nextPageRESTFormatString
}</span>

// HTTPGraphQLFileName returns the HTTP GraphQL endpoint configuration file name.
func HTTPGraphQLFileName() string <span class="cov1" title="1">{
        return graphqlConfigFileName
}</span>

// HTTPGraphQLPrefix returns the environment variable prefix for the HTTP GraphQL endpoint.
func HTTPGraphQLPrefix() string <span class="cov1" title="1">{
        return graphQLPrefix
}</span>

// SpecialAccountFiat special purpose account for Fiat currency related operations in the database.
func SpecialAccountFiat() string <span class="cov1" title="1">{
        return specialAccountFiat
}</span>

// SpecialAccountCrypto special purpose account for Cryptocurrency related operations in the database.
func SpecialAccountCrypto() string <span class="cov1" title="1">{
        return specialAccountCrypto
}</span>

// InvalidRequestString is the error string message for an invalid request.
func InvalidRequestString() string <span class="cov1" title="1">{
        return invalidRequestString
}</span>

// ValidationString is the error message for a struct validation failure.
func ValidationString() string <span class="cov1" title="1">{
        return validationSting
}</span>

// InvalidCurrencyString is the error message for an invalid currency.
func InvalidCurrencyString() string <span class="cov1" title="1">{
        return invalidCurrencyString
}</span>

// RetryMessageString is the error message requesting a retry.
func RetryMessageString() string <span class="cov1" title="1">{
        return retryMessageString
}</span>

// TwoSeconds is a two-second time duration.
func TwoSeconds() time.Duration <span class="cov1" title="1">{
        return twoSecondDuration
}</span>

// ThreeSeconds is a three-second time duration.
func ThreeSeconds() time.Duration <span class="cov1" title="1">{
        return threeSecondDuration
}</span>

// ClientIDCtxKey is the key used to store a clientID in a context.
func ClientIDCtxKey() string <span class="cov1" title="1">{
        return clientIDCtxKey
}</span>

// ExpiresAtCtxKey is the key used to store an expiration deadline in a context.
func ExpiresAtCtxKey() string <span class="cov1" title="1">{
        return expiresAtCtxKey
}</span>
</pre>

		<pre class="file" id="file12" style="display: none">package graphql

import (
        "fmt"
        "time"

        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/configloader"
        "github.com/surahman/FTeX/pkg/constants"
)

// config is the configuration container for the HTTP REST endpoint.
//
//nolint:lll
type config struct {
        Server        serverConfig        `json:"server,omitempty"        mapstructure:"server"        validate:"required" yaml:"server,omitempty"`
        Authorization authorizationConfig `json:"authorization,omitempty" mapstructure:"authorization" validate:"required" yaml:"authorization,omitempty"`
}

// serverConfig contains the configurations for the HTTP REST server.
//
//nolint:lll
type serverConfig struct {
        BasePath          string        `json:"basePath,omitempty"          mapstructure:"basePath"          validate:"required"          yaml:"basePath,omitempty"`
        PlaygroundPath    string        `json:"playgroundPath,omitempty"    mapstructure:"playgroundPath"    validate:"required"          yaml:"playgroundPath,omitempty"`
        QueryPath         string        `json:"queryPath,omitempty"         mapstructure:"queryPath"         validate:"required"          yaml:"queryPath,omitempty"`
        PortNumber        int           `json:"portNumber,omitempty"        mapstructure:"portNumber"        validate:"required,min=1000" yaml:"portNumber,omitempty"`
        ShutdownDelay     time.Duration `json:"shutdownDelay,omitempty"     mapstructure:"shutdownDelay"     validate:"required,min=0"    yaml:"shutdownDelay,omitempty"`
        ReadTimeout       time.Duration `json:"readTimeout,omitempty"       mapstructure:"readTimeout"       validate:"required,min=1"    yaml:"readTimeout,omitempty"`
        WriteTimeout      time.Duration `json:"writeTimeout,omitempty"      mapstructure:"writeTimeout"      validate:"required,min=1"    yaml:"writeTimeout,omitempty"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout,omitempty" mapstructure:"readHeaderTimeout" validate:"required,min=1"    yaml:"readHeaderTimeout,omitempty"`
}

// authorizationConfig contains the configurations for request authorization.
type authorizationConfig struct {
        HeaderKey string `json:"headerKey,omitempty" mapstructure:"headerKey" validate:"required" yaml:"headerKey,omitempty"`
}

// newConfig creates a blank configuration struct for the authorization.
func newConfig() *config <span class="cov1" title="1">{
        return &amp;config{}
}</span>

// Load will attempt to load configurations from a file on a file system.
func (cfg *config) Load(fs afero.Fs) error <span class="cov10" title="13">{
        if err := configloader.Load(
                fs,
                cfg,
                constants.HTTPGraphQLFileName(),
                constants.HTTPGraphQLPrefix(),
                "yaml"); err != nil </span><span class="cov9" title="10">{
                return fmt.Errorf("rest config loading failed: %w", err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package graphql

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"

        "github.com/gin-gonic/gin"
        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/auth"
        graphql "github.com/surahman/FTeX/pkg/graphql/resolvers"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/quotes"
        "github.com/surahman/FTeX/pkg/redis"
        "go.uber.org/zap"
)

// Generate the GraphQL Go code for resolvers.
//go:generate go run github.com/99designs/gqlgen generate

// Server is the HTTP GraphQL server.
type Server struct {
        auth   auth.Auth
        cache  redis.Redis
        db     postgres.Postgres
        quotes quotes.Quotes
        conf   *config
        logger *logger.Logger
        router *gin.Engine
        wg     *sync.WaitGroup
}

// NewServer will create a new GraphQL server instance in a non-running state.
func NewServer(fs *afero.Fs, auth auth.Auth, postgres postgres.Postgres, redis redis.Redis, quotes quotes.Quotes,
        logger *logger.Logger, wg *sync.WaitGroup) (server *Server, err error) <span class="cov8" title="1">{
        // Load configurations.
        conf := newConfig()
        if err = conf.Load(*fs); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return &amp;Server{
                        conf:   conf,
                        auth:   auth,
                        cache:  redis,
                        db:     postgres,
                        quotes: quotes,
                        logger: logger,
                        wg:     wg,
                },
                err</span>
}

// initialize will configure the HTTP server routes.
func (s *Server) initialize() <span class="cov0" title="0">{
        s.router = gin.Default()

        // Endpoint configurations
        api := s.router.Group(s.conf.Server.BasePath)
        api.Use(graphql.GinContextToContextMiddleware())
        api.POST(s.conf.Server.QueryPath,
                graphql.QueryHandler(s.conf.Authorization.HeaderKey, s.auth, s.cache, s.db, s.quotes, s.logger))
        api.GET(s.conf.Server.PlaygroundPath, graphql.PlaygroundHandler(s.conf.Server.BasePath, s.conf.Server.QueryPath))
}</span>

// Run brings the HTTP GraphQL service up.
func (s *Server) Run() <span class="cov0" title="0">{
        // Indicate to bootstrapping thread to wait for completion.
        defer s.wg.Done()

        // Configure routes.
        s.initialize()

        // Create server.
        srv := &amp;http.Server{
                ReadTimeout:       s.conf.Server.ReadTimeout,
                WriteTimeout:      s.conf.Server.WriteTimeout,
                ReadHeaderTimeout: s.conf.Server.ReadHeaderTimeout,
                Addr:              fmt.Sprintf(":%d", s.conf.Server.PortNumber),
                Handler:           s.router,
        }

        // Error channel for failed server start.
        serverErr := make(chan error, 1)

        // Wait for interrupt signal to gracefully shut down the server.
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        // Start HTTP listener.
        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        serverErr &lt;- err
                }</span>
        }()

        // Check for server start failure or shutdown signal.
        <span class="cov0" title="0">select </span>{
        case err := &lt;-serverErr:<span class="cov0" title="0">
                s.logger.Error(fmt.Sprintf("GraphQL server failed to listen on port %d", s.conf.Server.PortNumber), zap.Error(err))

                return</span>
        case &lt;-quit:<span class="cov0" title="0">
                s.logger.Info("Shutting down GraphQL server...", zap.Duration("waiting", s.conf.Server.ShutdownDelay))</span>
        }

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), s.conf.Server.ShutdownDelay)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                s.logger.Panic("Failed to shutdown GraphQL server", zap.Error(err))
        }</span>

        // 5 second wait to exit.
        <span class="cov0" title="0">&lt;-ctx.Done()

        s.logger.Info("GraphQL server exited")</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">package graphql

import (
        "context"
        "errors"
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/postgres"
        "go.uber.org/zap"
)

type GinContextKey struct{}

// GinContextFromContext will extract the Gin context from the context passed in.
func GinContextFromContext(ctx context.Context, logger *logger.Logger) (*gin.Context, error) <span class="cov10" title="139">{
        ctxValue := ctx.Value(GinContextKey{})
        if ctxValue == nil </span><span class="cov2" title="2">{
                logger.Error("could not retrieve gin.Context")

                return nil, errors.New("malformed request: authorization information not found")
        }</span>

        <span class="cov9" title="137">ginContext, ok := ctxValue.(*gin.Context)
        if !ok </span><span class="cov2" title="2">{
                logger.Error("gin.Context has wrong type")

                return nil, errors.New("malformed request: authorization information malformed")
        }</span>

        <span class="cov9" title="135">return ginContext, nil</span>
}

// AuthorizationCheck will validate the JWT payload for valid authorization information.
func AuthorizationCheck(ctx context.Context, auth auth.Auth, db postgres.Postgres, logger *logger.Logger,
        authHeaderKey string) (uuid.UUID, int64, error) <span class="cov9" title="136">{
        var (
                clientID   uuid.UUID
                expiresAt  int64
                err        error
                isDeleted  bool
                ginContext *gin.Context
        )

        if ginContext, err = GinContextFromContext(ctx, logger); err != nil </span><span class="cov2" title="2">{
                return clientID, -1, err
        }</span>

        <span class="cov9" title="134">tokenString := ginContext.GetHeader(authHeaderKey)
        if tokenString == "" </span><span class="cov1" title="1">{
                return clientID, -1, errors.New("request does not contain an access token")
        }</span>

        <span class="cov9" title="133">if clientID, expiresAt, err = auth.ValidateJWT(tokenString); err != nil </span><span class="cov6" title="19">{
                return clientID, expiresAt, fmt.Errorf("failed to validate JWT %w", err)
        }</span>

        // Check for user deleted status.
        <span class="cov9" title="114">if isDeleted, err = db.UserIsDeleted(clientID); err != nil </span><span class="cov1" title="1">{
                logger.Error("unable to retrieve client account status", zap.Error(err))

                return clientID, expiresAt, errors.New(constants.RetryMessageString())
        }</span>

        <span class="cov9" title="113">if isDeleted </span><span class="cov6" title="18">{
                return clientID, expiresAt, errors.New("request contains invalid or expired authorization token")
        }</span>

        <span class="cov9" title="95">return clientID, expiresAt, nil</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
        "context"

        graphql_generated "github.com/surahman/FTeX/pkg/graphql/generated"
        "github.com/surahman/FTeX/pkg/models"
)

// DebitAmount is the resolver for the debitAmount field.
func (r *offerResponseResolver) DebitAmount(ctx context.Context, obj *models.HTTPExchangeOfferResponse) (float64, error) <span class="cov6" title="4">{
        return obj.DebitAmount.InexactFloat64(), nil
}</span>

// ClientID is the resolver for the ClientID field.
func (r *priceQuoteResolver) ClientID(ctx context.Context, obj *models.PriceQuote) (string, error) <span class="cov6" title="4">{
        return obj.ClientID.String(), nil
}</span>

// Rate is the resolver for the Rate field.
func (r *priceQuoteResolver) Rate(ctx context.Context, obj *models.PriceQuote) (float64, error) <span class="cov6" title="4">{
        return obj.Rate.InexactFloat64(), nil
}</span>

// Amount is the resolver for the Amount field.
func (r *priceQuoteResolver) Amount(ctx context.Context, obj *models.PriceQuote) (float64, error) <span class="cov6" title="4">{
        return obj.Amount.InexactFloat64(), nil
}</span>

// OfferResponse returns graphql_generated.OfferResponseResolver implementation.
func (r *Resolver) OfferResponse() graphql_generated.OfferResponseResolver <span class="cov5" title="3">{
        return &amp;offerResponseResolver{r}
}</span>

// PriceQuote returns graphql_generated.PriceQuoteResolver implementation.
func (r *Resolver) PriceQuote() graphql_generated.PriceQuoteResolver <span class="cov10" title="9">{ return &amp;priceQuoteResolver{r} }</span>

type offerResponseResolver struct{ *Resolver }
type priceQuoteResolver struct{ *Resolver }
</pre>

		<pre class="file" id="file16" style="display: none">package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
        "context"
        "errors"
        "fmt"
        "strconv"

        "github.com/gofrs/uuid"
        "github.com/shopspring/decimal"
        "github.com/surahman/FTeX/pkg/common"
        "github.com/surahman/FTeX/pkg/constants"
        graphql_generated "github.com/surahman/FTeX/pkg/graphql/generated"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
)

// Balance is the resolver for the balance field.
func (r *cryptoAccountResolver) Balance(ctx context.Context, obj *postgres.CryptoAccount) (float64, error) <span class="cov7" title="29">{
        return obj.Balance.InexactFloat64(), nil
}</span>

// LastTx is the resolver for the lastTx field.
func (r *cryptoAccountResolver) LastTx(ctx context.Context, obj *postgres.CryptoAccount) (float64, error) <span class="cov7" title="29">{
        return obj.LastTx.InexactFloat64(), nil
}</span>

// LastTxTs is the resolver for the lastTxTs field.
func (r *cryptoAccountResolver) LastTxTs(ctx context.Context, obj *postgres.CryptoAccount) (string, error) <span class="cov7" title="29">{
        return obj.LastTxTs.Time.String(), nil
}</span>

// CreatedAt is the resolver for the createdAt field.
func (r *cryptoAccountResolver) CreatedAt(ctx context.Context, obj *postgres.CryptoAccount) (string, error) <span class="cov7" title="29">{
        return obj.CreatedAt.Time.String(), nil
}</span>

// ClientID is the resolver for the clientID field.
func (r *cryptoAccountResolver) ClientID(ctx context.Context, obj *postgres.CryptoAccount) (string, error) <span class="cov7" title="29">{
        return obj.ClientID.String(), nil
}</span>

// Amount is the resolver for the amount field.
func (r *cryptoJournalResolver) Amount(ctx context.Context, obj *postgres.CryptoJournal) (float64, error) <span class="cov5" title="9">{
        return obj.Amount.InexactFloat64(), nil
}</span>

// TransactedAt is the resolver for the transactedAt field.
func (r *cryptoJournalResolver) TransactedAt(ctx context.Context, obj *postgres.CryptoJournal) (string, error) <span class="cov5" title="9">{
        return obj.TransactedAt.Time.String(), nil
}</span>

// ClientID is the resolver for the clientID field.
func (r *cryptoJournalResolver) ClientID(ctx context.Context, obj *postgres.CryptoJournal) (string, error) <span class="cov5" title="9">{
        return obj.ClientID.String(), nil
}</span>

// TxID is the resolver for the txID field.
func (r *cryptoJournalResolver) TxID(ctx context.Context, obj *postgres.CryptoJournal) (string, error) <span class="cov5" title="9">{
        return obj.TxID.String(), nil
}</span>

// Transactions is the resolver for the transactions field.
func (r *cryptoTransactionsPaginatedResolver) Transactions(ctx context.Context, obj *models.HTTPCryptoTransactionsPaginated) ([]postgres.CryptoJournal, error) <span class="cov3" title="3">{
        return obj.TransactionDetails, nil
}</span>

// OpenCrypto is the resolver for the openCrypto field.
func (r *mutationResolver) OpenCrypto(ctx context.Context, ticker string) (*models.CryptoOpenAccountResponse, error) <span class="cov3" title="4">{
        var (
                clientID   uuid.UUID
                errMessage string
                err        error
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov2" title="2">if _, errMessage, err = common.HTTPCryptoOpen(r.db, r.logger, clientID, ticker); err != nil </span><span class="cov1" title="1">{
                return nil, errors.New(errMessage)
        }</span>

        <span class="cov1" title="1">return &amp;models.CryptoOpenAccountResponse{ClientID: clientID.String(), Ticker: ticker}, nil</span>
}

// OfferCrypto is the resolver for the offerCrypto field.
func (r *mutationResolver) OfferCrypto(ctx context.Context, input models.HTTPCryptoOfferRequest) (*models.HTTPExchangeOfferResponse, error) <span class="cov5" title="11">{
        var (
                clientID      uuid.UUID
                err           error
                offer         models.HTTPExchangeOfferResponse
                statusMessage string
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov5" title="9">if offer, _, statusMessage, err = common.HTTPCryptoOffer(r.auth, r.cache, r.logger, r.quotes,
                clientID, input.SourceCurrency, input.DestinationCurrency, input.SourceAmount, *input.IsPurchase); err != nil </span><span class="cov4" title="7">{
                if statusMessage == constants.InvalidRequestString() </span><span class="cov3" title="3">{
                        statusMessage = err.Error()
                }</span>

                <span class="cov4" title="7">return nil, errors.New(statusMessage)</span>
        }

        <span class="cov2" title="2">offer.ClientID = clientID

        return &amp;offer, nil</span>
}

// ExchangeCrypto is the resolver for the exchangeCrypto field.
func (r *mutationResolver) ExchangeCrypto(ctx context.Context, offerID string) (*models.HTTPCryptoTransferResponse, error) <span class="cov3" title="5">{
        var (
                clientID      uuid.UUID
                err           error
                receipt       models.HTTPCryptoTransferResponse
                statusMessage string
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov3" title="3">if receipt, _, statusMessage, err = common.HTTPExchangeCrypto(r.auth, r.cache, r.db, r.logger, clientID, offerID); err != nil </span><span class="cov1" title="1">{
                return nil, errors.New(statusMessage)
        }</span>

        <span class="cov2" title="2">return &amp;receipt, nil</span>
}

// BalanceCrypto is the resolver for the balanceCrypto field.
func (r *queryResolver) BalanceCrypto(ctx context.Context, ticker string) (*postgres.CryptoAccount, error) <span class="cov3" title="5">{
        var (
                accDetails  *postgres.CryptoAccount
                clientID    uuid.UUID
                err         error
                httpMessage string
                payload     any
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov3" title="3">if accDetails, _, httpMessage, payload, err =
                common.HTTPCryptoBalance(r.db, r.logger, clientID, ticker); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("%s: %v", httpMessage, payload)
        }</span>

        <span class="cov1" title="1">return accDetails, nil</span>
}

// BalanceAllCrypto is the resolver for the balanceAllCrypto field.
func (r *queryResolver) BalanceAllCrypto(ctx context.Context, pageCursor *string, pageSize *int32) (*models.HTTPCryptoDetailsPaginated, error) <span class="cov5" title="10">{
        var (
                accDetails  models.HTTPCryptoDetailsPaginated
                clientID    uuid.UUID
                err         error
                httpMessage string
        )

        if pageSize == nil </span><span class="cov3" title="3">{
                pageSize = new(int32)
        }</span>

        <span class="cov5" title="10">if pageCursor == nil </span><span class="cov3" title="3">{
                pageCursor = new(string)
        }</span>

        <span class="cov5" title="10">if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov4" title="8">if accDetails, _, httpMessage, err = common.HTTPCryptoBalancePaginated(r.auth, r.db, r.logger,
                clientID, *pageCursor, strconv.Itoa(int(*pageSize)), false); err != nil </span><span class="cov3" title="4">{
                return nil, errors.New(httpMessage)
        }</span>

        <span class="cov3" title="4">return &amp;accDetails, nil</span>
}

// TransactionDetailsCrypto is the resolver for the transactionDetailsCrypto field.
func (r *queryResolver) TransactionDetailsCrypto(ctx context.Context, transactionID string) ([]interface{}, error) <span class="cov3" title="5">{
        var (
                journalEntries []any
                clientID       uuid.UUID
                err            error
                httpMessage    string
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov3" title="3">if journalEntries, _, httpMessage, err = common.HTTPTxDetails(r.db, r.logger, clientID, transactionID); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New(httpMessage)
        }</span>

        <span class="cov1" title="1">return journalEntries, nil</span>
}

// TransactionDetailsAllCrypto is the resolver for the transactionDetailsAllCrypto field.
func (r *queryResolver) TransactionDetailsAllCrypto(ctx context.Context, input models.CryptoPaginatedTxDetailsRequest) (*models.HTTPCryptoTransactionsPaginated, error) <span class="cov4" title="8">{
        var (
                journalEntries models.HTTPCryptoTransactionsPaginated
                clientID       uuid.UUID
                err            error
                params         common.HTTPPaginatedTxParams
                httpMessage    string
                payload        any
        )

        if input.PageSize == nil </span><span class="cov0" title="0">{
                input.PageSize = new(string)
        }</span>
        <span class="cov4" title="8">params.PageSizeStr = *input.PageSize

        if input.PageCursor == nil </span><span class="cov1" title="1">{
                input.PageCursor = new(string)
        }</span>
        <span class="cov4" title="8">params.PageCursorStr = *input.PageCursor

        if input.Timezone == nil </span><span class="cov4" title="7">{
                input.Timezone = new(string)
        }</span>
        <span class="cov4" title="8">params.TimezoneStr = *input.Timezone

        if input.Month == nil </span><span class="cov4" title="7">{
                input.Month = new(string)
        }</span>
        <span class="cov4" title="8">params.MonthStr = *input.Month

        if input.Year == nil </span><span class="cov4" title="7">{
                input.Year = new(string)
        }</span>
        <span class="cov4" title="8">params.YearStr = *input.Year

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov4" title="6">if journalEntries, _, httpMessage, err = common.HTTPCryptoTransactionsPaginated(r.auth, r.db,
                r.logger, &amp;params, clientID, input.Ticker, false); err != nil </span><span class="cov3" title="4">{

                return nil, fmt.Errorf("%s: %v", httpMessage, payload)
        }</span>

        <span class="cov2" title="2">return &amp;journalEntries, nil</span>
}

// SourceAmount is the resolver for the sourceAmount field.
func (r *cryptoOfferRequestResolver) SourceAmount(ctx context.Context, obj *models.HTTPCryptoOfferRequest, data float64) error <span class="cov5" title="12">{
        obj.SourceAmount = decimal.NewFromFloat(data)

        return nil
}</span>

// CryptoAccount returns graphql_generated.CryptoAccountResolver implementation.
func (r *Resolver) CryptoAccount() graphql_generated.CryptoAccountResolver <span class="cov10" title="140">{
        return &amp;cryptoAccountResolver{r}
}</span>

// CryptoJournal returns graphql_generated.CryptoJournalResolver implementation.
func (r *Resolver) CryptoJournal() graphql_generated.CryptoJournalResolver <span class="cov7" title="32">{
        return &amp;cryptoJournalResolver{r}
}</span>

// CryptoTransactionsPaginated returns graphql_generated.CryptoTransactionsPaginatedResolver implementation.
func (r *Resolver) CryptoTransactionsPaginated() graphql_generated.CryptoTransactionsPaginatedResolver <span class="cov2" title="2">{
        return &amp;cryptoTransactionsPaginatedResolver{r}
}</span>

// CryptoOfferRequest returns graphql_generated.CryptoOfferRequestResolver implementation.
func (r *Resolver) CryptoOfferRequest() graphql_generated.CryptoOfferRequestResolver <span class="cov5" title="11">{
        return &amp;cryptoOfferRequestResolver{r}
}</span>

type cryptoAccountResolver struct{ *Resolver }
type cryptoJournalResolver struct{ *Resolver }
type cryptoTransactionsPaginatedResolver struct{ *Resolver }
type cryptoOfferRequestResolver struct{ *Resolver }
</pre>

		<pre class="file" id="file17" style="display: none">package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
        "context"
        "errors"
        "fmt"
        "strconv"

        "github.com/gofrs/uuid"
        "github.com/shopspring/decimal"
        "github.com/surahman/FTeX/pkg/common"
        graphql_generated "github.com/surahman/FTeX/pkg/graphql/generated"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
)

// Currency is the resolver for the currency field.
func (r *fiatAccountResolver) Currency(ctx context.Context, obj *postgres.FiatAccount) (string, error) <span class="cov6" title="29">{
        return string(obj.Currency), nil
}</span>

// Balance is the resolver for the balance field.
func (r *fiatAccountResolver) Balance(ctx context.Context, obj *postgres.FiatAccount) (float64, error) <span class="cov6" title="29">{
        return obj.Balance.InexactFloat64(), nil
}</span>

// LastTx is the resolver for the lastTx field.
func (r *fiatAccountResolver) LastTx(ctx context.Context, obj *postgres.FiatAccount) (float64, error) <span class="cov6" title="29">{
        return obj.LastTx.InexactFloat64(), nil
}</span>

// LastTxTs is the resolver for the lastTxTs field.
func (r *fiatAccountResolver) LastTxTs(ctx context.Context, obj *postgres.FiatAccount) (string, error) <span class="cov6" title="29">{
        return obj.LastTxTs.Time.String(), nil
}</span>

// CreatedAt is the resolver for the createdAt field.
func (r *fiatAccountResolver) CreatedAt(ctx context.Context, obj *postgres.FiatAccount) (string, error) <span class="cov6" title="29">{
        return obj.CreatedAt.Time.String(), nil
}</span>

// ClientID is the resolver for the clientID field.
func (r *fiatAccountResolver) ClientID(ctx context.Context, obj *postgres.FiatAccount) (string, error) <span class="cov6" title="28">{
        return obj.ClientID.String(), nil
}</span>

// TxID is the resolver for the txId field.
func (r *fiatDepositResponseResolver) TxID(ctx context.Context, obj *postgres.FiatAccountTransferResult) (string, error) <span class="cov2" title="2">{
        return obj.TxID.String(), nil
}</span>

// ClientID is the resolver for the clientId field.
func (r *fiatDepositResponseResolver) ClientID(ctx context.Context, obj *postgres.FiatAccountTransferResult) (string, error) <span class="cov2" title="2">{
        return obj.ClientID.String(), nil
}</span>

// TxTimestamp is the resolver for the txTimestamp field.
func (r *fiatDepositResponseResolver) TxTimestamp(ctx context.Context, obj *postgres.FiatAccountTransferResult) (string, error) <span class="cov2" title="2">{
        return obj.TxTS.Time.String(), nil
}</span>

// Balance is the resolver for the balance field.
func (r *fiatDepositResponseResolver) Balance(ctx context.Context, obj *postgres.FiatAccountTransferResult) (string, error) <span class="cov2" title="2">{
        return obj.Balance.String(), nil
}</span>

// LastTx is the resolver for the lastTx field.
func (r *fiatDepositResponseResolver) LastTx(ctx context.Context, obj *postgres.FiatAccountTransferResult) (string, error) <span class="cov2" title="2">{
        return obj.LastTx.String(), nil
}</span>

// Currency is the resolver for the currency field.
func (r *fiatDepositResponseResolver) Currency(ctx context.Context, obj *postgres.FiatAccountTransferResult) (string, error) <span class="cov2" title="2">{
        return string(obj.Currency), nil
}</span>

// SourceReceipt is the resolver for the sourceReceipt field.
func (r *fiatExchangeTransferResponseResolver) SourceReceipt(ctx context.Context, obj *models.HTTPFiatTransferResponse) (*postgres.FiatAccountTransferResult, error) <span class="cov3" title="4">{
        return obj.SrcTxReceipt, nil
}</span>

// DestinationReceipt is the resolver for the destinationReceipt field.
func (r *fiatExchangeTransferResponseResolver) DestinationReceipt(ctx context.Context, obj *models.HTTPFiatTransferResponse) (*postgres.FiatAccountTransferResult, error) <span class="cov2" title="2">{
        return obj.DstTxReceipt, nil
}</span>

// Currency is the resolver for the currency field.
func (r *fiatJournalResolver) Currency(ctx context.Context, obj *postgres.FiatJournal) (string, error) <span class="cov4" title="9">{
        return string(obj.Currency), nil
}</span>

// Amount is the resolver for the amount field.
func (r *fiatJournalResolver) Amount(ctx context.Context, obj *postgres.FiatJournal) (float64, error) <span class="cov4" title="9">{
        return obj.Amount.InexactFloat64(), nil
}</span>

// TransactedAt is the resolver for the transactedAt field.
func (r *fiatJournalResolver) TransactedAt(ctx context.Context, obj *postgres.FiatJournal) (string, error) <span class="cov4" title="9">{
        return obj.TransactedAt.Time.String(), nil
}</span>

// ClientID is the resolver for the clientID field.
func (r *fiatJournalResolver) ClientID(ctx context.Context, obj *postgres.FiatJournal) (string, error) <span class="cov4" title="9">{
        return obj.ClientID.String(), nil
}</span>

// TxID is the resolver for the txID field.
func (r *fiatJournalResolver) TxID(ctx context.Context, obj *postgres.FiatJournal) (string, error) <span class="cov4" title="9">{
        return obj.TxID.String(), nil
}</span>

// Transactions is the resolver for the transactions field.
func (r *fiatTransactionsPaginatedResolver) Transactions(ctx context.Context, obj *models.HTTPFiatTransactionsPaginated) ([]postgres.FiatJournal, error) <span class="cov2" title="3">{
        return obj.TransactionDetails, nil
}</span>

// OpenFiat is the resolver for the openFiat field.
func (r *mutationResolver) OpenFiat(ctx context.Context, currency string) (*models.FiatOpenAccountResponse, error) <span class="cov3" title="5">{
        var (
                clientID   uuid.UUID
                errMessage string
                err        error
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov2" title="3">if _, errMessage, err = common.HTTPFiatOpen(r.db, r.logger, clientID, currency); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New(errMessage)
        }</span>

        <span class="cov1" title="1">return &amp;models.FiatOpenAccountResponse{ClientID: clientID.String(), Currency: currency}, nil</span>
}

// DepositFiat is the resolver for the depositFiat field.
func (r *mutationResolver) DepositFiat(ctx context.Context, input models.HTTPDepositCurrencyRequest) (*postgres.FiatAccountTransferResult, error) <span class="cov4" title="6">{
        var (
                clientID        uuid.UUID
                err             error
                httpMessage     string
                transferReceipt *postgres.FiatAccountTransferResult
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov3" title="4">if transferReceipt, _, httpMessage, _, err =
                common.HTTPFiatDeposit(r.db, r.logger, clientID, &amp;input); err != nil </span><span class="cov2" title="3">{

                return nil, errors.New(httpMessage)
        }</span>

        <span class="cov1" title="1">return transferReceipt, nil</span>
}

// ExchangeOfferFiat is the resolver for the exchangeOfferFiat field.
func (r *mutationResolver) ExchangeOfferFiat(ctx context.Context, input models.HTTPExchangeOfferRequest) (*models.HTTPExchangeOfferResponse, error) <span class="cov5" title="11">{
        var (
                clientID    uuid.UUID
                err         error
                httpMessage string
                payload     any
                offer       *models.HTTPExchangeOfferResponse
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov4" title="9">if offer, _, httpMessage, payload, err =
                common.HTTPFiatOffer(r.auth, r.cache, r.logger, r.quotes, clientID, &amp;input); err != nil </span><span class="cov4" title="8">{

                return nil, fmt.Errorf("%s: %v", httpMessage, payload)
        }</span>

        <span class="cov1" title="1">return offer, nil</span>
}

// ExchangeTransferFiat is the resolver for the exchangeTransferFiat field.
func (r *mutationResolver) ExchangeTransferFiat(ctx context.Context, offerID string) (*models.HTTPFiatTransferResponse, error) <span class="cov5" title="11">{
        var (
                err         error
                clientID    uuid.UUID
                httpMessage string
                payload     any
                receipt     *models.HTTPFiatTransferResponse
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov4" title="9">if receipt, _, httpMessage, payload, err = common.HTTPFiatTransfer(r.auth, r.cache, r.db, r.logger,
                clientID, &amp;models.HTTPTransferRequest{OfferID: offerID}); err != nil </span><span class="cov4" title="7">{
                return nil, fmt.Errorf("%s: %v", httpMessage, payload)
        }</span>

        <span class="cov2" title="2">return receipt, nil</span>
}

// BalanceFiat is the resolver for the balanceFiat field.
func (r *queryResolver) BalanceFiat(ctx context.Context, currencyCode string) (*postgres.FiatAccount, error) <span class="cov4" title="6">{
        var (
                accDetails  *postgres.FiatAccount
                clientID    uuid.UUID
                err         error
                httpMessage string
                payload     any
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov3" title="4">if accDetails, _, httpMessage, payload, err =
                common.HTTPFiatBalance(r.db, r.logger, clientID, currencyCode); err != nil </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("%s: %v", httpMessage, payload)
        }</span>

        <span class="cov1" title="1">return accDetails, nil</span>
}

// BalanceAllFiat is the resolver for the balanceAllFiat field.
func (r *queryResolver) BalanceAllFiat(ctx context.Context, pageCursor *string, pageSize *int32) (*models.HTTPFiatDetailsPaginated, error) <span class="cov5" title="10">{
        var (
                accDetails  *models.HTTPFiatDetailsPaginated
                clientID    uuid.UUID
                err         error
                httpMessage string
        )

        if pageSize == nil </span><span class="cov2" title="3">{
                pageSize = new(int32)
        }</span>

        <span class="cov5" title="10">if pageCursor == nil </span><span class="cov2" title="3">{
                pageCursor = new(string)
        }</span>

        <span class="cov5" title="10">if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov4" title="8">if accDetails, _, httpMessage, err = common.HTTPFiatBalancePaginated(r.auth, r.db, r.logger,
                clientID, *pageCursor, strconv.Itoa(int(*pageSize)), false); err != nil </span><span class="cov3" title="4">{
                return nil, errors.New(httpMessage)
        }</span>

        <span class="cov3" title="4">return accDetails, nil</span>
}

// TransactionDetailsFiat is the resolver for the transactionDetailsFiat field.
func (r *queryResolver) TransactionDetailsFiat(ctx context.Context, transactionID string) ([]interface{}, error) <span class="cov3" title="5">{
        var (
                journalEntries []any
                clientID       uuid.UUID
                err            error
                httpMessage    string
        )

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov2" title="3">if journalEntries, _, httpMessage, err = common.HTTPTxDetails(r.db, r.logger, clientID, transactionID); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New(httpMessage)
        }</span>

        <span class="cov1" title="1">return journalEntries, nil</span>
}

// TransactionDetailsAllFiat is the resolver for the transactionDetailsAllFiat field.
func (r *queryResolver) TransactionDetailsAllFiat(ctx context.Context, input models.FiatPaginatedTxDetailsRequest) (*models.HTTPFiatTransactionsPaginated, error) <span class="cov4" title="9">{
        var (
                journalEntries *models.HTTPFiatTransactionsPaginated
                clientID       uuid.UUID
                err            error
                params         common.HTTPPaginatedTxParams
                httpMessage    string
                payload        any
        )

        if input.PageSize == nil </span><span class="cov0" title="0">{
                input.PageSize = new(string)
        }</span>
        <span class="cov4" title="9">params.PageSizeStr = *input.PageSize

        if input.PageCursor == nil </span><span class="cov1" title="1">{
                input.PageCursor = new(string)
        }</span>
        <span class="cov4" title="9">params.PageCursorStr = *input.PageCursor

        if input.Timezone == nil </span><span class="cov4" title="8">{
                input.Timezone = new(string)
        }</span>
        <span class="cov4" title="9">params.TimezoneStr = *input.Timezone

        if input.Month == nil </span><span class="cov4" title="8">{
                input.Month = new(string)
        }</span>
        <span class="cov4" title="9">params.MonthStr = *input.Month

        if input.Year == nil </span><span class="cov4" title="8">{
                input.Year = new(string)
        }</span>
        <span class="cov4" title="9">params.YearStr = *input.Year

        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return nil, errors.New("authorization failure")
        }</span>

        <span class="cov4" title="7">if journalEntries, _, httpMessage, payload, err = common.HTTPFiatTransactionsPaginated(r.auth, r.db,
                r.logger, clientID, input.Currency, &amp;params, false); err != nil </span><span class="cov3" title="5">{

                return nil, fmt.Errorf("%s: %v", httpMessage, payload)
        }</span>

        <span class="cov2" title="2">return journalEntries, nil</span>
}

// Amount is the resolver for the amount field.
func (r *fiatDepositRequestResolver) Amount(ctx context.Context, obj *models.HTTPDepositCurrencyRequest, data float64) error <span class="cov4" title="6">{
        obj.Amount = decimal.NewFromFloat(data)

        return nil
}</span>

// SourceAmount is the resolver for the sourceAmount field.
func (r *fiatExchangeOfferRequestResolver) SourceAmount(ctx context.Context, obj *models.HTTPExchangeOfferRequest, data float64) error <span class="cov5" title="12">{
        obj.SourceAmount = decimal.NewFromFloat(data)

        return nil
}</span>

// FiatAccount returns graphql_generated.FiatAccountResolver implementation.
func (r *Resolver) FiatAccount() graphql_generated.FiatAccountResolver <span class="cov10" title="168">{
        return &amp;fiatAccountResolver{r}
}</span>

// FiatDepositResponse returns graphql_generated.FiatDepositResponseResolver implementation.
func (r *Resolver) FiatDepositResponse() graphql_generated.FiatDepositResponseResolver <span class="cov4" title="6">{
        return &amp;fiatDepositResponseResolver{r}
}</span>

// FiatExchangeTransferResponse returns graphql_generated.FiatExchangeTransferResponseResolver implementation.
func (r *Resolver) FiatExchangeTransferResponse() graphql_generated.FiatExchangeTransferResponseResolver <span class="cov3" title="4">{
        return &amp;fiatExchangeTransferResponseResolver{r}
}</span>

// FiatJournal returns graphql_generated.FiatJournalResolver implementation.
func (r *Resolver) FiatJournal() graphql_generated.FiatJournalResolver <span class="cov7" title="40">{
        return &amp;fiatJournalResolver{r}
}</span>

// FiatTransactionsPaginated returns graphql_generated.FiatTransactionsPaginatedResolver implementation.
func (r *Resolver) FiatTransactionsPaginated() graphql_generated.FiatTransactionsPaginatedResolver <span class="cov2" title="2">{
        return &amp;fiatTransactionsPaginatedResolver{r}
}</span>

// FiatDepositRequest returns graphql_generated.FiatDepositRequestResolver implementation.
func (r *Resolver) FiatDepositRequest() graphql_generated.FiatDepositRequestResolver <span class="cov4" title="6">{
        return &amp;fiatDepositRequestResolver{r}
}</span>

// FiatExchangeOfferRequest returns graphql_generated.FiatExchangeOfferRequestResolver implementation.
func (r *Resolver) FiatExchangeOfferRequest() graphql_generated.FiatExchangeOfferRequestResolver <span class="cov5" title="11">{
        return &amp;fiatExchangeOfferRequestResolver{r}
}</span>

type fiatAccountResolver struct{ *Resolver }
type fiatDepositResponseResolver struct{ *Resolver }
type fiatExchangeTransferResponseResolver struct{ *Resolver }
type fiatJournalResolver struct{ *Resolver }
type fiatTransactionsPaginatedResolver struct{ *Resolver }
type fiatDepositRequestResolver struct{ *Resolver }
type fiatExchangeOfferRequestResolver struct{ *Resolver }
</pre>

		<pre class="file" id="file18" style="display: none">package graphql

import (
        "context"
        "fmt"

        "github.com/99designs/gqlgen/graphql/handler"
        "github.com/99designs/gqlgen/graphql/playground"
        "github.com/gin-gonic/gin"
        "github.com/surahman/FTeX/pkg/auth"
        graphql_generated "github.com/surahman/FTeX/pkg/graphql/generated"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/quotes"
        "github.com/surahman/FTeX/pkg/redis"
)

// QueryHandler is the endpoint through which GraphQL can be accessed.
func QueryHandler(authHeaderKey string, auth auth.Auth, cache redis.Redis, db postgres.Postgres,
        quotes quotes.Quotes, logger *logger.Logger) gin.HandlerFunc <span class="cov10" title="143">{
        gqlHandler := handler.NewDefaultServer(graphql_generated.NewExecutableSchema(
                graphql_generated.Config{
                        Resolvers: &amp;Resolver{
                                authHeaderKey: authHeaderKey,
                                auth:          auth,
                                cache:         cache,
                                db:            db,
                                quotes:        quotes,
                                logger:        logger,
                        },
                },
        ))

        return func(c *gin.Context) </span><span class="cov9" title="142">{
                gqlHandler.ServeHTTP(c.Writer, c.Request)
        }</span>
}

// PlaygroundHandler is the endpoint through which the GraphQL playground can be accessed.
func PlaygroundHandler(baseURL, queryURL string) gin.HandlerFunc <span class="cov1" title="1">{
        h := playground.Handler("GraphQL", fmt.Sprintf("/%s%s", baseURL, queryURL))

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                h.ServeHTTP(c.Writer, c.Request)
        }</span>
}

// GinContextToContextMiddleware is middleware that will place the Gin context into a context for the GraphQL resolvers.
func GinContextToContextMiddleware() gin.HandlerFunc <span class="cov9" title="130">{
        return func(c *gin.Context) </span><span class="cov9" title="130">{
                ctx := context.WithValue(c.Request.Context(), GinContextKey{}, c)
                c.Request = c.Request.WithContext(ctx)
                c.Next()
        }</span>
}
</pre>

		<pre class="file" id="file19" style="display: none">package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
        "context"

        "github.com/surahman/FTeX/pkg/common"
        graphql_generated "github.com/surahman/FTeX/pkg/graphql/generated"
)

// Healthcheck is the resolver for the healthcheck field.
func (r *queryResolver) Healthcheck(ctx context.Context) (string, error) <span class="cov3" title="3">{
        _, httpMsg, err := common.HTTPHealthcheck(r.db, r.cache, r.logger)

        return httpMsg, err
}</span>

// Query returns graphql_generated.QueryResolver implementation.
func (r *Resolver) Query() graphql_generated.QueryResolver <span class="cov10" title="61">{ return &amp;queryResolver{r} }</span>

type queryResolver struct{ *Resolver }
</pre>

		<pre class="file" id="file20" style="display: none">package graphql

// getHealthcheckQuery is the health check query.
func getHealthcheckQuery() string <span class="cov8" title="1">{
        return `{
                "query": "query { healthcheck() }"
        }`
}</span>

// getUsersQuery is a map of test user mutations and queries.
//
//nolint:lll
func getUsersQuery() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "register": `{
                "query": "mutation { registerUser(input: { firstname: \"%s\", lastname:\"%s\", email: \"%s\", userLoginCredentials: { username:\"%s\", password: \"%s\" } }) { token, expires, threshold }}"
                }`,

                "login": `{
                "query": "mutation { loginUser(input: { username:\"%s\", password: \"%s\" }) { token, expires, threshold }}"
                }`,

                "refresh": `{
                "query": "mutation { refreshToken() { token expires threshold }}"
                }`,

                "delete": `{
            "query": "mutation { deleteUser(input: { username: \"%s\" password: \"%s\" confirmation:\"I understand the consequences, delete my user account %s\" })}"
                }`,
        }
}</span>

// getFiatQuery is a map of test Fiat mutations and queries.
//
//nolint:lll
func getFiatQuery() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "openFiat": `{
                "query": "mutation { openFiat(currency: \"%s\") { clientID, currency }}"
                }`,

                "depositFiat": `{
                "query": "mutation { depositFiat(input: { amount:%f, currency: \"%s\" }) { txId, clientId, txTimestamp, balance, lastTx, currency } }"
                }`,

                "exchangeOfferFiat": `{
                "query": "mutation { exchangeOfferFiat(input: { sourceCurrency:\"%s\" destinationCurrency: \"%s\" sourceAmount: %f }) { priceQuote{ clientID, sourceAcc, destinationAcc, rate, amount }, debitAmount, offerID, expires } }"
                }`,

                "exchangeTransferFiat": `{
                "query": "mutation { exchangeTransferFiat(offerID: \"%s\") { sourceReceipt { txId, clientId, txTimestamp, balance, lastTx, currency }, destinationReceipt { txId, clientId, txTimestamp, balance, lastTx, currency } } }"
                }`,

                "balanceFiat": `{
                "query": "query { balanceFiat(currencyCode: \"%s\") { currency, balance, lastTx, lastTxTs, createdAt, clientID } }"
                }`,

                "balanceAllFiat": `{
                "query": "query { balanceAllFiat( pageCursor: \"%s\", pageSize: %d ) { accountBalances { currency, balance, lastTx, lastTxTs, createdAt, clientID }, links { pageCursor } } }"
                }`,

                "balanceAllFiatNoParams": `{
                "query": "query { balanceAllFiat { accountBalances { currency, balance, lastTx, lastTxTs, createdAt, clientID }, links { pageCursor } } }"
                }`,

                "transactionDetailsFiat": `{
                "query": "query { transactionDetailsFiat( transactionID: \"%s\") }"
                }`,

                "transactionDetailsAllFiatInit": `{
                "query": "query { transactionDetailsAllFiat(input: { currency: \"%s\", pageSize:\"%d\", timezone:\"%s\", month: \"%d\", year:\"%d\" }) { transactions { currency, amount, transactedAt, clientID, txID }, links { pageCursor } } }"
                }`,

                "transactionDetailsAllFiatSubsequent": `{
                "query": "query { transactionDetailsAllFiat(input: { currency: \"%s\", pageSize:\"%d\", pageCursor:\"%s\" }) { transactions { currency, amount, transactedAt, clientID, txID }, links { pageCursor } } }"
                }`,
        }
}</span>

// getCryptoQuery is a map of test Crypto mutations and queries.
//
//nolint:lll
func getCryptoQuery() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "openCrypto": `{
                "query": "mutation { openCrypto(ticker: \"%s\") { clientID, ticker } }"
                }`,

                "offerCrypto": `{
                "query": "mutation { offerCrypto(input: { sourceAmount: %f, sourceCurrency:\"%s\", destinationCurrency:\"%s\", isPurchase: %t, }) { priceQuote { clientID, sourceAcc, destinationAcc, rate, amount }, debitAmount, offerID, expires } }"
                }`,

                "exchangeCrypto": `{
                "query": "mutation { exchangeCrypto(offerID: \"%s\") { fiatTxReceipt{ currency, amount, transactedAt, clientID, txID, }, cryptoTxReceipt{ ticker, amount, transactedAt, clientID, txID, }, } }"
                }`,

                "balanceCrypto": `{
                "query": "query { balanceCrypto(ticker: \"%s\") { ticker, balance, lastTx, lastTxTs, createdAt, clientID } }"
                }`,

                "balanceAllCrypto": `{
                "query": "query { balanceAllCrypto( pageCursor: \"%s\", pageSize: %d ) { accountBalances { ticker, balance, lastTx, lastTxTs, createdAt, clientID }, links { pageCursor } } }"
                }`,

                "balanceAllCryptoNoParams": `{
                "query": "query { balanceAllCrypto { accountBalances { ticker, balance, lastTx, lastTxTs, createdAt, clientID }, links { pageCursor } } }"
                }`,

                "transactionDetailsCrypto": `{
                "query": "query { transactionDetailsCrypto(transactionID: \"%s\") }"
                }`,

                "transactionDetailsAllCryptoInit": `{
                "query": "query { transactionDetailsAllCrypto(input: { ticker: \"%s\", pageSize:\"%d\", timezone:\"%s\", month: \"%d\", year:\"%d\" }) { transactions { ticker, amount, transactedAt, clientID, txID }, links { pageCursor } } }"
                }`,

                "transactionDetailsAllCryptoSubsequent": `{
                "query": "query { transactionDetailsAllCrypto(input: { ticker: \"%s\", pageSize:\"%d\", pageCursor:\"%s\" }) { transactions { ticker, amount, transactedAt, clientID, txID }, links { pageCursor } } }"
                }`,
        }
}</span>
</pre>

		<pre class="file" id="file21" style="display: none">package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
        "context"
        "errors"
        "fmt"

        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/common"
        graphql_generated "github.com/surahman/FTeX/pkg/graphql/generated"
        "github.com/surahman/FTeX/pkg/models"
        modelsPostgres "github.com/surahman/FTeX/pkg/models/postgres"
        "github.com/surahman/FTeX/pkg/validator"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input *modelsPostgres.UserAccount) (*models.JWTAuthResponse, error) <span class="cov4" title="5">{
        var (
                authToken *models.JWTAuthResponse
                err       error
                httpMsg   string
                payload   any
        )

        if authToken, httpMsg, _, payload, err = common.HTTPRegisterUser(r.auth, r.db, r.logger, input); err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("%s: %v", httpMsg, payload)
        }</span>

        <span class="cov1" title="1">return authToken, nil</span>
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, input models.HTTPDeleteUserRequest) (string, error) <span class="cov5" title="10">{
        var (
                clientID uuid.UUID
                err      error
                httpMsg  string
                payload  any
        )

        // Validate the JWT and extract the clientID. Compare the clientID against the deletion request login
        // credentials.
        if clientID, _, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov2" title="2">{
                return "", errors.New("authorization failure")
        }</span>

        <span class="cov5" title="8">if httpMsg, _, payload, err = common.HTTPDeleteUser(r.auth, r.db, r.logger, clientID, &amp;input); err != nil </span><span class="cov4" title="7">{
                return "", fmt.Errorf("%s: %v", httpMsg, payload)
        }</span>

        <span class="cov1" title="1">return "account successfully deleted", nil</span>
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input modelsPostgres.UserLoginCredentials) (*models.JWTAuthResponse, error) <span class="cov4" title="5">{
        var (
                err       error
                authToken *models.JWTAuthResponse
                httpMsg   string
                payload   any
        )

        if err = validator.ValidateStruct(&amp;input); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation %w", err)
        }</span>

        <span class="cov3" title="4">if authToken, httpMsg, _, payload, err = common.HTTPLoginUser(r.auth, r.db, r.logger, &amp;input); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("%s: %v", httpMsg, payload)
        }</span>

        <span class="cov1" title="1">return authToken, nil</span>
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*models.JWTAuthResponse, error) <span class="cov5" title="8">{
        var (
                err        error
                freshToken *models.JWTAuthResponse
                clientID   uuid.UUID
                expiresAt  int64
                httpMsg    string
        )

        // Validate the JWT and extract the clientID. Compare the clientID against the deletion request login
        // credentials.
        if clientID, expiresAt, err = AuthorizationCheck(ctx, r.auth, r.db, r.logger, r.authHeaderKey); err != nil </span><span class="cov3" title="3">{
                return freshToken, errors.New("authorization failure")
        }</span>

        <span class="cov4" title="5">if freshToken, httpMsg, _, err = common.HTTPRefreshLogin(r.auth, r.db, r.logger, clientID, expiresAt); err != nil </span><span class="cov3" title="3">{

                return nil, errors.New(httpMsg)
        }</span>

        <span class="cov1" title="1">return freshToken, nil</span>
}

// Mutation returns graphql_generated.MutationResolver implementation.
func (r *Resolver) Mutation() graphql_generated.MutationResolver <span class="cov10" title="81">{ return &amp;mutationResolver{r} }</span>

type mutationResolver struct{ *Resolver }
</pre>

		<pre class="file" id="file22" style="display: none">package graphql

// configTestData will return a map of test data containing valid and invalid GraphQL configs.
func configTestData() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "empty": ``,

                "valid": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  playgroundPath: /playground
  queryPath: /query
  readTimeout: 3s
  writeTimeout: 3s
  readHeaderTimeout: 3s
authorization:
  headerKey: Authorization`,

                "out of range port": `
server:
  portNumber: 99
  shutdownDelay: 5s
  basePath: api/rest/v1
  playgroundPath: /playground
  queryPath: /query
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "out of range time delay": `
server:
  portNumber: 44243
  shutdownDelay: 0s
  basePath: api/rest/v1
  playgroundPath: /playground
  queryPath: /query
  readTimeout: 0s
  writeTimeout: 0s
  readHeaderTimeout: 0s
authorization:
  headerKey: Authorization`,

                "no base path": `
server:
  portNumber: 44243
  shutdownDelay: 5s
  playgroundPath: /playground
  queryPath: /query
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no playground path": `
server:
  portNumber: 44243
  shutdownDelay: 5s
  basePath: api/rest/v1
  queryPath: /query
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no query path": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  playgroundPath: /playground
  readTimeout: 3s
  writeTimeout: 3s
  readHeaderTimeout: 3s
authorization:
  headerKey: Authorization`,

                "no read timeout": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  playgroundPath: /playground
  queryPath: /query
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no write timeout": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  playgroundPath: /playground
  queryPath: /query
  readTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no read header timeout": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  playgroundPath: /playground
  queryPath: /query
  readTimeout: 1s
  writeTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no auth header": `
server:
  portNumber: 44243
  shutdownDelay: 5s
  basePath: api/rest/v1
  playgroundPath: /playground
  queryPath: /query
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey:`,
        }
}</span>
</pre>

		<pre class="file" id="file23" style="display: none">package logger

import (
        "fmt"

        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/configloader"
        "github.com/surahman/FTeX/pkg/constants"
)

// config contains the configurations loaded from the configuration file.
//
//nolint:lll
type config struct {
        BuiltinConfig        string         `json:"builtinConfig,omitempty"        mapstructure:"builtinConfig"        validate:"oneof='Production' 'production' 'Development' 'development'" yaml:"builtinConfig,omitempty"`
        BuiltinEncoderConfig string         `json:"builtinEncoderConfig,omitempty" mapstructure:"builtinEncoderConfig" validate:"oneof='Production' 'production' 'Development' 'development'" yaml:"builtinEncoderConfig,omitempty"`
        GeneralConfig        *generalConfig `json:"generalConfig,omitempty"        mapstructure:"generalConfig"        yaml:"generalConfig,omitempty"`
        EncoderConfig        *encoderConfig `json:"encoderConfig,omitempty"        mapstructure:"encoderConfig"        yaml:"encoderConfig,omitempty"`
}

// generalConfig contains all the general logger configurations.
//
//nolint:lll
type generalConfig struct {
        Development       bool     `json:"development"       mapstructure:"development"       validate:"required" yaml:"development"`
        DisableCaller     bool     `json:"disableCaller"     mapstructure:"disableCaller"     validate:"required" yaml:"disableCaller"`
        DisableStacktrace bool     `json:"disableStacktrace" mapstructure:"disableStacktrace" validate:"required" yaml:"disableStacktrace"`
        Encoding          string   `json:"encoding"          mapstructure:"encoding"          validate:"required" yaml:"encoding"`
        OutputPaths       []string `json:"outputPaths"       mapstructure:"outputPaths"       validate:"required" yaml:"outputPaths"`
        ErrorOutputPaths  []string `json:"errorOutputPaths"  mapstructure:"errorOutputPaths"  validate:"required" yaml:"errorOutputPaths"`
}

// encoderConfig contains all the log encoder configurations.
//
//nolint:lll
type encoderConfig struct {
        MessageKey       string `json:"messageKey"       mapstructure:"messageKey"       validate:"required" yaml:"messageKey"`
        LevelKey         string `json:"levelKey"         mapstructure:"levelKey"         validate:"required" yaml:"levelKey"`
        TimeKey          string `json:"timeKey"          mapstructure:"timeKey"          validate:"required" yaml:"timeKey"`
        NameKey          string `json:"nameKey"          mapstructure:"nameKey"          validate:"required" yaml:"nameKey"`
        CallerKey        string `json:"callerKey"        mapstructure:"callerKey"        validate:"required" yaml:"callerKey"`
        FunctionKey      string `json:"functionKey"      mapstructure:"functionKey"      validate:"required" yaml:"functionKey"`
        StacktraceKey    string `json:"stacktraceKey"    mapstructure:"stacktraceKey"    validate:"required" yaml:"stacktraceKey"`
        SkipLineEnding   bool   `json:"skipLineEnding"   mapstructure:"skipLineEnding"   validate:"required" yaml:"skipLineEnding"`
        LineEnding       string `json:"lineEnding"       mapstructure:"lineEnding"       validate:"required" yaml:"lineEnding"`
        ConsoleSeparator string `json:"consoleSeparator" mapstructure:"consoleSeparator" validate:"required" yaml:"consoleSeparator"`
}

// newConfig creates a blank configuration struct for the Zap Logger.
func newConfig() config <span class="cov6" title="5">{
        return config{}
}</span>

// Load will attempt to load configurations from a file on a file system.
func (cfg *config) Load(fs afero.Fs) error <span class="cov10" title="13">{
        if err := configloader.Load(
                fs,
                cfg,
                constants.LoggerFileName(),
                constants.LoggerPrefix(),
                "yaml"); err != nil </span><span class="cov4" title="3">{
                return fmt.Errorf("zap logger config loading failed: %w", err)
        }</span>

        <span class="cov9" title="10">return nil</span>
}
</pre>

		<pre class="file" id="file24" style="display: none">package logger

import (
        "errors"
        "fmt"
        "log"
        "strings"

        "github.com/spf13/afero"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/yaml.v3"
)

// Logger is the Zap logger object.
type Logger struct {
        zapLogger *zap.Logger
}

// NewLogger will create a new uninitialized logger.
func NewLogger() *Logger <span class="cov9" title="8">{
        return &amp;Logger{}
}</span>

// Init will initialize the logger with configurations and start it.
func (l *Logger) Init(fs *afero.Fs) error <span class="cov8" title="6">{
        if l.zapLogger != nil </span><span class="cov1" title="1">{
                return errors.New("logger is already initialized")
        }</span>

        <span class="cov7" title="5">var (
                err        error
                baseConfig zap.Config
                encConfig  zapcore.EncoderConfig
        )

        userConfig := newConfig()
        if err = userConfig.Load(*fs); err != nil </span><span class="cov1" title="1">{
                log.Printf("failed to load logger configuration file from disk: %v\n", err)

                return err
        }</span>

        // Base logger configuration.
        <span class="cov6" title="4">switch strings.ToLower(userConfig.BuiltinConfig) </span>{
        case "development":<span class="cov5" title="3">
                baseConfig = zap.NewDevelopmentConfig()</span>
        case "production":<span class="cov1" title="1">
                baseConfig = zap.NewProductionConfig()</span>
        default:<span class="cov0" title="0">
                msg := "could not select the base configuration type"
                log.Println(msg)

                return errors.New(msg)</span>
        }

        // Encoder configuration.
        <span class="cov6" title="4">switch strings.ToLower(userConfig.BuiltinEncoderConfig) </span>{
        case "development":<span class="cov5" title="3">
                encConfig = zap.NewDevelopmentEncoderConfig()</span>
        case "production":<span class="cov1" title="1">
                encConfig = zap.NewProductionEncoderConfig()</span>
        default:<span class="cov0" title="0">
                msg := "could not select the base encoder type"
                log.Println(msg)

                return errors.New(msg)</span>
        }

        // Merge configurations.
        <span class="cov6" title="4">if err = mergeConfig[*zap.Config, *generalConfig](&amp;baseConfig, userConfig.GeneralConfig); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to merge base configurations and user provided configurations for logger: %v\n", err)

                return err
        }</span>

        <span class="cov6" title="4">if err = mergeConfig[*zapcore.EncoderConfig, *encoderConfig](&amp;encConfig, userConfig.EncoderConfig); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to merge base and user provided encoder configurations for logger: %v\n", err)

                return err
        }</span>

        // Init and create logger.
        <span class="cov6" title="4">baseConfig.EncoderConfig = encConfig
        if l.zapLogger, err = baseConfig.Build(zap.AddCallerSkip(1)); err != nil </span><span class="cov0" title="0">{
                msg := "failure configuring logger"
                log.Printf(msg+": %v\n", err)

                return fmt.Errorf(msg+": %w", err)
        }</span>

        <span class="cov6" title="4">return nil</span>
}

// Info logs messages at the info level.
func (l *Logger) Info(message string, fields ...zap.Field) <span class="cov3" title="2">{
        l.zapLogger.Info(message, fields...)
}</span>

// Debug logs messages at the debug level.
func (l *Logger) Debug(message string, fields ...zap.Field) <span class="cov3" title="2">{
        l.zapLogger.Debug(message, fields...)
}</span>

// Warn logs messages at the warn level.
func (l *Logger) Warn(message string, fields ...zap.Field) <span class="cov3" title="2">{
        l.zapLogger.Warn(message, fields...)
}</span>

// Error logs messages at the error level.
func (l *Logger) Error(message string, fields ...zap.Field) <span class="cov3" title="2">{
        l.zapLogger.Error(message, fields...)
}</span>

// Panic logs messages at the panic level and then panics at the call site.
func (l *Logger) Panic(message string, fields ...zap.Field) <span class="cov3" title="2">{
        l.zapLogger.Panic(message, fields...)
}</span>

// mergeConfig will merge the configuration files by marshaling and unmarshalling.
//
//nolint:lll
func mergeConfig[DST *zap.Config | *zapcore.EncoderConfig, SRC *generalConfig | *encoderConfig](dst DST, src SRC) (err error) <span class="cov10" title="10">{
        var yamlToConv []byte

        if yamlToConv, err = yaml.Marshal(src); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="10">if err = yaml.Unmarshal(yamlToConv, dst); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="10">return</span>
}

// setTestLogger is a utility method that sets a logger base for testing.
func (l *Logger) setTestLogger(testLogger *zap.Logger) <span class="cov3" title="2">{
        l.zapLogger = testLogger
}</span>

// NewTestLogger will create a new development logger to be used in test suites.
func NewTestLogger() (*Logger, error) <span class="cov1" title="1">{
        baseConfig := zap.NewDevelopmentConfig()
        baseConfig.EncoderConfig = zap.NewDevelopmentEncoderConfig()

        var (
                err       error
                zapLogger *zap.Logger
        )

        if zapLogger, err = baseConfig.Build(zap.AddCallerSkip(1)); err != nil </span><span class="cov0" title="0">{
                log.Printf("failure configuring logger: %v\n", err)

                return nil, fmt.Errorf("zap logger base config builing failed: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;Logger{zapLogger: zapLogger}, nil</span>
}
</pre>

		<pre class="file" id="file25" style="display: none">package logger

// configTestData will return a map of test data containing valid and invalid logger configs.
func configTestData() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "empty": ``,

                "valid_devel": `
builtinConfig: Development
builtinEncoderConfig: Development`,

                "valid_prod": `
builtinConfig: Production
builtinEncoderConfig: Production`,

                "invalid_builtin": `
builtinConfig: Invalid
builtinEncoderConfig: Invalid`,

                "valid_config": `
builtinConfig: Development
builtinEncoderConfig: Development
generalConfig:
  development: true
  disableCaller: true
  disableStacktrace: true
  encoding: json
  outputPaths: ["stdout", "stderr"]
  errorOutputPaths: ["stdout", "stderr"]
encoderConfig:
  messageKey: message key
  levelKey: level key
  timeKey: time key
  nameKey: name key
  callerKey: caller key
  functionKey: function key
  stacktraceKey: stacktrace key
  skipLineEnding: true
  lineEnding: line ending
  consoleSeparator: console separator`,
        }
}</span>
</pre>

		<pre class="file" id="file26" style="display: none">package postgres

import (
        "fmt"
        "time"

        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/configloader"
        "github.com/surahman/FTeX/pkg/constants"
)

// config contains the configurations loaded from the configuration file.
//
//nolint:lll
type config struct {
        Authentication authenticationConfig `json:"authentication,omitempty" mapstructure:"authentication" yaml:"authentication,omitempty"`
        Connection     connectionConfig     `json:"connection,omitempty"     mapstructure:"connection"     yaml:"connection,omitempty"`
        Pool           poolConfig           `json:"pool,omitempty"           mapstructure:"pool"           yaml:"pool,omitempty"`
}

// authenticationConfig contains the Postgres session authentication information.
type authenticationConfig struct {
        Username string `json:"username,omitempty" mapstructure:"username" validate:"required" yaml:"username,omitempty"`
        Password string `json:"password,omitempty" mapstructure:"password" validate:"required" yaml:"password,omitempty"`
}

// connectionConfig contains the Postgres session connection information.
//
//nolint:lll
type connectionConfig struct {
        Database        string `json:"database,omitempty"              mapstructure:"database"              validate:"required"       yaml:"database,omitempty"`
        Host            string `json:"host,omitempty"                  mapstructure:"host"                  validate:"required"       yaml:"host,omitempty"`
        MaxConnAttempts int    `json:"maxConnectionAttempts,omitempty" mapstructure:"maxConnectionAttempts" validate:"required,min=1" yaml:"maxConnectionAttempts,omitempty"`
        Timeout         int    `json:"timeout,omitempty"               mapstructure:"timeout"               validate:"required,min=5" yaml:"timeout,omitempty"`
        Port            uint16 `json:"port,omitempty"                  mapstructure:"port"                  validate:"required"       yaml:"port,omitempty"`
}

// poolConfig contains the Postgres session connection pool specific information.
//
//nolint:lll
type poolConfig struct {
        HealthCheckPeriod time.Duration `json:"healthCheckPeriod,omitempty" mapstructure:"healthCheckPeriod" validate:"omitempty,min=5s" yaml:"healthCheckPeriod,omitempty"`
        MaxConns          int32         `json:"maxConns,omitempty"          mapstructure:"maxConns"          validate:"required,gte=4"   yaml:"maxConns,omitempty"`
        MinConns          int32         `json:"minConns,omitempty"          mapstructure:"minConns"          validate:"required,gte=4"   yaml:"minConns,omitempty"`
}

// newConfig creates a blank configuration struct for Postgres.
func newConfig() config <span class="cov8" title="9">{
        return config{}
}</span>

// Load will attempt to load configurations from a file on a file system.
func (cfg *config) Load(fs afero.Fs) error <span class="cov10" title="15">{
        if err := configloader.Load(
                fs,
                cfg,
                constants.PostgresFileName(),
                constants.PostgresPrefix(),
                "yaml"); err != nil </span><span class="cov6" title="6">{
                return fmt.Errorf("postgres config loading failed: %w", err)
        }</span>

        <span class="cov8" title="9">return nil</span>
}
</pre>

		<pre class="file" id="file27" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: crypto.sql

package postgres

import (
        "context"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/shopspring/decimal"
)

const cryptoCreateAccount = `-- name: cryptoCreateAccount :execrows
INSERT INTO crypto_accounts (client_id, ticker)
VALUES ($1, $2)
`

type cryptoCreateAccountParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Ticker   string    `json:"ticker"`
}

// cryptoCreateAccount inserts a fiat account record.
func (q *Queries) cryptoCreateAccount(ctx context.Context, arg *cryptoCreateAccountParams) (int64, error) <span class="cov10" title="73">{
        result, err := q.db.Exec(ctx, cryptoCreateAccount, arg.ClientID, arg.Ticker)
        if err != nil </span><span class="cov4" title="6">{
                return 0, err
        }</span>
        <span class="cov9" title="67">return result.RowsAffected(), nil</span>
}

const cryptoGetAccount = `-- name: cryptoGetAccount :one
SELECT ticker, balance, last_tx, last_tx_ts, created_at, client_id
FROM crypto_accounts
WHERE client_id=$1 AND ticker=$2
`

type cryptoGetAccountParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Ticker   string    `json:"ticker"`
}

// cryptoGetAccount will retrieve a specific user's account for a given cryptocurrency ticker.
func (q *Queries) cryptoGetAccount(ctx context.Context, arg *cryptoGetAccountParams) (CryptoAccount, error) <span class="cov4" title="6">{
        row := q.db.QueryRow(ctx, cryptoGetAccount, arg.ClientID, arg.Ticker)
        var i CryptoAccount
        err := row.Scan(
                &amp;i.Ticker,
                &amp;i.Balance,
                &amp;i.LastTx,
                &amp;i.LastTxTs,
                &amp;i.CreatedAt,
                &amp;i.ClientID,
        )
        return i, err
}</span>

const cryptoGetAllAccounts = `-- name: cryptoGetAllAccounts :many
SELECT ticker, balance, last_tx, last_tx_ts, created_at, client_id
FROM crypto_accounts
WHERE client_id=$1 AND ticker &gt;= $2
ORDER BY ticker
LIMIT $3
`

type cryptoGetAllAccountsParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Ticker   string    `json:"ticker"`
        Limit    int32     `json:"limit"`
}

// cryptoGetAllAccounts will retrieve all accounts associated with a specific user.
func (q *Queries) cryptoGetAllAccounts(ctx context.Context, arg *cryptoGetAllAccountsParams) ([]CryptoAccount, error) <span class="cov6" title="15">{
        rows, err := q.db.Query(ctx, cryptoGetAllAccounts, arg.ClientID, arg.Ticker, arg.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="15">defer rows.Close()
        var items []CryptoAccount
        for rows.Next() </span><span class="cov7" title="19">{
                var i CryptoAccount
                if err := rows.Scan(
                        &amp;i.Ticker,
                        &amp;i.Balance,
                        &amp;i.LastTx,
                        &amp;i.LastTxTs,
                        &amp;i.CreatedAt,
                        &amp;i.ClientID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov7" title="19">items = append(items, i)</span>
        }
        <span class="cov6" title="15">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="15">return items, nil</span>
}

const cryptoGetAllJournalTransactionsPaginated = `-- name: cryptoGetAllJournalTransactionsPaginated :many
SELECT ticker, amount, transacted_at, client_id, tx_id
FROM crypto_journal
WHERE client_id = $1
      AND ticker = $2
      AND transacted_at
          BETWEEN $5::timestamptz
              AND $6::timestamptz
ORDER BY transacted_at DESC
OFFSET $3
LIMIT $4
`

type cryptoGetAllJournalTransactionsPaginatedParams struct {
        ClientID  uuid.UUID          `json:"clientID"`
        Ticker    string             `json:"ticker"`
        Offset    int32              `json:"offset"`
        Limit     int32              `json:"limit"`
        StartTime pgtype.Timestamptz `json:"startTime"`
        EndTime   pgtype.Timestamptz `json:"endTime"`
}

// cryptoGetAllJournalTransactionsPaginated will retrieve the journal entries associated with a specific account
// in a date range.
func (q *Queries) cryptoGetAllJournalTransactionsPaginated(ctx context.Context, arg *cryptoGetAllJournalTransactionsPaginatedParams) ([]CryptoJournal, error) <span class="cov6" title="16">{
        rows, err := q.db.Query(ctx, cryptoGetAllJournalTransactionsPaginated,
                arg.ClientID,
                arg.Ticker,
                arg.Offset,
                arg.Limit,
                arg.StartTime,
                arg.EndTime,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="16">defer rows.Close()
        var items []CryptoJournal
        for rows.Next() </span><span class="cov8" title="30">{
                var i CryptoJournal
                if err := rows.Scan(
                        &amp;i.Ticker,
                        &amp;i.Amount,
                        &amp;i.TransactedAt,
                        &amp;i.ClientID,
                        &amp;i.TxID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="30">items = append(items, i)</span>
        }
        <span class="cov6" title="16">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="16">return items, nil</span>
}

const cryptoGetJournalTransaction = `-- name: cryptoGetJournalTransaction :many
SELECT ticker, amount, transacted_at, client_id, tx_id
FROM crypto_journal
WHERE client_id = $1 AND tx_id = $2
`

type cryptoGetJournalTransactionParams struct {
        ClientID uuid.UUID `json:"clientID"`
        TxID     uuid.UUID `json:"txID"`
}

// cryptoGetJournalTransaction will retrieve the journal entries associated with a transaction.
func (q *Queries) cryptoGetJournalTransaction(ctx context.Context, arg *cryptoGetJournalTransactionParams) ([]CryptoJournal, error) <span class="cov7" title="20">{
        rows, err := q.db.Query(ctx, cryptoGetJournalTransaction, arg.ClientID, arg.TxID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="20">defer rows.Close()
        var items []CryptoJournal
        for rows.Next() </span><span class="cov6" title="14">{
                var i CryptoJournal
                if err := rows.Scan(
                        &amp;i.Ticker,
                        &amp;i.Amount,
                        &amp;i.TransactedAt,
                        &amp;i.ClientID,
                        &amp;i.TxID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="14">items = append(items, i)</span>
        }
        <span class="cov7" title="20">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="20">return items, nil</span>
}

const cryptoPurchase = `-- name: cryptoPurchase :exec
CALL purchase_cryptocurrency($1,$2,$3, $5::numeric(18, 2), $4, $6::numeric(24, 8))
`

type cryptoPurchaseParams struct {
        TransactionID      uuid.UUID       `json:"TransactionID"`
        ClientID           uuid.UUID       `json:"ClientID"`
        FiatCurrency       Currency        `json:"FiatCurrency"`
        CryptoTicker       string          `json:"CryptoTicker"`
        FiatDebitAmount    decimal.Decimal `json:"fiatDebitAmount"`
        CryptoCreditAmount decimal.Decimal `json:"cryptoCreditAmount"`
}

// cryptoPurchase will execute a transaction to purchase a Cryptocurrency using a Fiat currency.
func (q *Queries) cryptoPurchase(ctx context.Context, arg *cryptoPurchaseParams) error <span class="cov9" title="60">{
        _, err := q.db.Exec(ctx, cryptoPurchase,
                arg.TransactionID,
                arg.ClientID,
                arg.FiatCurrency,
                arg.CryptoTicker,
                arg.FiatDebitAmount,
                arg.CryptoCreditAmount,
        )
        return err
}</span>

const cryptoSell = `-- name: cryptoSell :exec
CALL sell_cryptocurrency($1,$2,$3, $5::numeric(18, 2), $4, $6::numeric(24, 8))
`

type cryptoSellParams struct {
        TransactionID     uuid.UUID       `json:"TransactionID"`
        ClientID          uuid.UUID       `json:"ClientID"`
        FiatCurrency      Currency        `json:"FiatCurrency"`
        CryptoTicker      string          `json:"CryptoTicker"`
        FiatCreditAmount  decimal.Decimal `json:"fiatCreditAmount"`
        CryptoDebitAmount decimal.Decimal `json:"cryptoDebitAmount"`
}

// cryptoSell will execute a transaction to sell a Cryptocurrency and purchase a Fiat currency.
func (q *Queries) cryptoSell(ctx context.Context, arg *cryptoSellParams) error <span class="cov5" title="10">{
        _, err := q.db.Exec(ctx, cryptoSell,
                arg.TransactionID,
                arg.ClientID,
                arg.FiatCurrency,
                arg.CryptoTicker,
                arg.FiatCreditAmount,
                arg.CryptoDebitAmount,
        )
        return err
}</span>
</pre>

		<pre class="file" id="file28" style="display: none">package postgres

import (
        "errors"
        "net/http"
)

// Error is the base error type. The builder pattern is used to add specialization codes to the errors.
type Error struct {
        Message string
        Code    int
}

// Check to ensure the error interface is implemented.
var _ error = &amp;Error{}

// Error get human readable error message.
func (e *Error) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// Is will return whether the input error is an instance of expected error.
func (e *Error) Is(err error) bool <span class="cov10" title="5">{
        var target *Error
        if !errors.As(err, &amp;target) </span><span class="cov7" title="3">{
                return false
        }</span>

        <span class="cov4" title="2">return e.Code == target.Code</span>
}

// NewError is a base error message with no special code.
func NewError(message string) *Error <span class="cov10" title="5">{
        return &amp;Error{Message: message, Code: 0}
}</span>

// SetStatus will configure the status code within the error message.
func (e *Error) SetStatus(code int) *Error <span class="cov7" title="3">{
        e.Code = code

        return e
}</span>

// Generic error variables.
// Errors to be returned by the Postgres Queries exposed through the interface for various failure conditions.
//
//nolint:lll
var (
        ErrRegisterUser          = errorRegisterUser()             // ErrorRegisterUser is returned if user registration fails.
        ErrLoginUser             = errorLoginUser()                // ErrLoginUser is returned if user credentials are not found.
        ErrNotFoundUser          = errorNotFoundUser()             // ErrNotFoundUser is returned if a user account is not found.
        ErrCreateFiat            = errorCreateFiat()               // ErrCreateFiat is returned if a Fiat account could not be opened.
        ErrTransactFiat          = errorTransactionFiat()          // ErrTransactFiat is returned if a Fiat transaction fails.
        ErrNotFound              = errorNotFound()                 // ErrNotFound is returned as a generic not found error.
        ErrUnhealthy             = errorUnhealthy()                // ErrUnhealthy is returned if the database cannot be pinged.
        ErrTransactCrypto        = errorTransactionCrypto()        // ErrTransactCrypto is returned if a Crypto transaction fails.
        ErrTransactCryptoDetails = errorTransactionCryptoDetails() // ErrTransactCryptoDetails is returned if a Crypto transaction succeeds, but transaction retrieval fails.
)

func errorRegisterUser() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "username is already registered",
                Code:    http.StatusNotFound,
        }
}</span>

func errorLoginUser() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "invalid username or password",
                Code:    http.StatusForbidden,
        }
}</span>

func errorNotFoundUser() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "invalid username or password",
                Code:    http.StatusNotFound,
        }
}</span>

func errorCreateFiat() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "could not open Fiat account",
                Code:    http.StatusConflict,
        }
}</span>

func errorTransactionFiat() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "could not complete Fiat transaction",
                Code:    http.StatusInternalServerError,
        }
}</span>

func errorNotFound() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "records not found",
                Code:    http.StatusNotFound,
        }
}</span>

func errorUnhealthy() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "unhealthy",
                Code:    http.StatusServiceUnavailable,
        }
}</span>

func errorTransactionCrypto() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "could not complete Crypto transaction",
                Code:    http.StatusInternalServerError,
        }
}</span>

func errorTransactionCryptoDetails() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "could not retrieve transaction details for successful Crypto transaction",
                Code:    http.StatusInternalServerError,
        }
}</span>
</pre>

		<pre class="file" id="file29" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: fiat.sql

package postgres

import (
        "context"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/shopspring/decimal"
)

const fiatCreateAccount = `-- name: fiatCreateAccount :execrows
INSERT INTO fiat_accounts (client_id, currency)
VALUES ($1, $2)
`

type fiatCreateAccountParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Currency Currency  `json:"currency"`
}

// fiatCreateAccount inserts a fiat account record.
func (q *Queries) fiatCreateAccount(ctx context.Context, arg *fiatCreateAccountParams) (int64, error) <span class="cov10" title="165">{
        result, err := q.db.Exec(ctx, fiatCreateAccount, arg.ClientID, arg.Currency)
        if err != nil </span><span class="cov4" title="8">{
                return 0, err
        }</span>
        <span class="cov9" title="157">return result.RowsAffected(), nil</span>
}

const fiatExternalTransferJournalEntry = `-- name: fiatExternalTransferJournalEntry :one
WITH deposit AS (
    INSERT INTO fiat_journal (
        client_id,
        currency,
        amount,
        transacted_at,
        tx_id)
    SELECT
        (   SELECT client_id
            FROM users
            WHERE username = 'fiat-currencies'),
        $2,
        round_half_even(-1 * $3::numeric(18, 2), 2),
        now(),
        gen_random_uuid()
    RETURNING tx_id, transacted_at
)
INSERT INTO fiat_journal (
    client_id,
    currency,
    amount,
    transacted_at,
    tx_id)
SELECT
    $1,
    $2,
    round_half_even($3::numeric(18, 2), 2),
    (   SELECT transacted_at
        FROM deposit),
    (   SELECT tx_id
        FROM deposit)
RETURNING tx_id, transacted_at
`

type fiatExternalTransferJournalEntryParams struct {
        ClientID uuid.UUID       `json:"clientID"`
        Currency Currency        `json:"currency"`
        Amount   decimal.Decimal `json:"amount"`
}

type fiatExternalTransferJournalEntryRow struct {
        TxID         uuid.UUID          `json:"txID"`
        TransactedAt pgtype.Timestamptz `json:"transactedAt"`
}

// fiatExternalTransferJournalEntry will create both journal entries for fiat accounts inbound deposits.
func (q *Queries) fiatExternalTransferJournalEntry(ctx context.Context, arg *fiatExternalTransferJournalEntryParams) (fiatExternalTransferJournalEntryRow, error) <span class="cov9" title="152">{
        row := q.db.QueryRow(ctx, fiatExternalTransferJournalEntry, arg.ClientID, arg.Currency, arg.Amount)
        var i fiatExternalTransferJournalEntryRow
        err := row.Scan(&amp;i.TxID, &amp;i.TransactedAt)
        return i, err
}</span>

const fiatGetAccount = `-- name: fiatGetAccount :one
SELECT currency, balance, last_tx, last_tx_ts, created_at, client_id
FROM fiat_accounts
WHERE client_id=$1 AND currency=$2
`

type fiatGetAccountParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Currency Currency  `json:"currency"`
}

// fiatGetAccount will retrieve a specific user's account for a given currency.
func (q *Queries) fiatGetAccount(ctx context.Context, arg *fiatGetAccountParams) (FiatAccount, error) <span class="cov5" title="14">{
        row := q.db.QueryRow(ctx, fiatGetAccount, arg.ClientID, arg.Currency)
        var i FiatAccount
        err := row.Scan(
                &amp;i.Currency,
                &amp;i.Balance,
                &amp;i.LastTx,
                &amp;i.LastTxTs,
                &amp;i.CreatedAt,
                &amp;i.ClientID,
        )
        return i, err
}</span>

const fiatGetAllAccounts = `-- name: fiatGetAllAccounts :many
SELECT currency, balance, last_tx, last_tx_ts, created_at, client_id
FROM fiat_accounts
WHERE client_id=$1 AND currency &gt;= $2
ORDER BY currency
LIMIT $3
`

type fiatGetAllAccountsParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Currency Currency  `json:"currency"`
        Limit    int32     `json:"limit"`
}

// fiatGetAllAccounts will retrieve all accounts associated with a specific user.
func (q *Queries) fiatGetAllAccounts(ctx context.Context, arg *fiatGetAllAccountsParams) ([]FiatAccount, error) <span class="cov5" title="15">{
        rows, err := q.db.Query(ctx, fiatGetAllAccounts, arg.ClientID, arg.Currency, arg.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="15">defer rows.Close()
        var items []FiatAccount
        for rows.Next() </span><span class="cov6" title="19">{
                var i FiatAccount
                if err := rows.Scan(
                        &amp;i.Currency,
                        &amp;i.Balance,
                        &amp;i.LastTx,
                        &amp;i.LastTxTs,
                        &amp;i.CreatedAt,
                        &amp;i.ClientID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="19">items = append(items, i)</span>
        }
        <span class="cov5" title="15">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="15">return items, nil</span>
}

const fiatGetAllJournalTransactionsPaginated = `-- name: fiatGetAllJournalTransactionsPaginated :many
SELECT currency, amount, transacted_at, client_id, tx_id
FROM fiat_journal
WHERE client_id = $1
      AND currency = $2
      AND transacted_at
          BETWEEN $5::timestamptz
              AND $6::timestamptz
ORDER BY transacted_at DESC
OFFSET $3
LIMIT $4
`

type fiatGetAllJournalTransactionsPaginatedParams struct {
        ClientID  uuid.UUID          `json:"clientID"`
        Currency  Currency           `json:"currency"`
        Offset    int32              `json:"offset"`
        Limit     int32              `json:"limit"`
        StartTime pgtype.Timestamptz `json:"startTime"`
        EndTime   pgtype.Timestamptz `json:"endTime"`
}

// fiatGetAllJournalTransactionsPaginated will retrieve the journal entries associated with a specific account
// in a date range.
func (q *Queries) fiatGetAllJournalTransactionsPaginated(ctx context.Context, arg *fiatGetAllJournalTransactionsPaginatedParams) ([]FiatJournal, error) <span class="cov5" title="16">{
        rows, err := q.db.Query(ctx, fiatGetAllJournalTransactionsPaginated,
                arg.ClientID,
                arg.Currency,
                arg.Offset,
                arg.Limit,
                arg.StartTime,
                arg.EndTime,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="16">defer rows.Close()
        var items []FiatJournal
        for rows.Next() </span><span class="cov6" title="30">{
                var i FiatJournal
                if err := rows.Scan(
                        &amp;i.Currency,
                        &amp;i.Amount,
                        &amp;i.TransactedAt,
                        &amp;i.ClientID,
                        &amp;i.TxID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="30">items = append(items, i)</span>
        }
        <span class="cov5" title="16">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="16">return items, nil</span>
}

const fiatGetJournalTransaction = `-- name: fiatGetJournalTransaction :many
SELECT currency, amount, transacted_at, client_id, tx_id
FROM fiat_journal
WHERE client_id = $1 AND tx_id = $2
`

type fiatGetJournalTransactionParams struct {
        ClientID uuid.UUID `json:"clientID"`
        TxID     uuid.UUID `json:"txID"`
}

// fiatGetJournalTransaction will retrieve the journal entries associated with a transaction.
func (q *Queries) fiatGetJournalTransaction(ctx context.Context, arg *fiatGetJournalTransactionParams) ([]FiatJournal, error) <span class="cov8" title="54">{
        rows, err := q.db.Query(ctx, fiatGetJournalTransaction, arg.ClientID, arg.TxID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="54">defer rows.Close()
        var items []FiatJournal
        for rows.Next() </span><span class="cov7" title="48">{
                var i FiatJournal
                if err := rows.Scan(
                        &amp;i.Currency,
                        &amp;i.Amount,
                        &amp;i.TransactedAt,
                        &amp;i.ClientID,
                        &amp;i.TxID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov7" title="48">items = append(items, i)</span>
        }
        <span class="cov8" title="54">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="54">return items, nil</span>
}

const fiatGetJournalTransactionForAccount = `-- name: fiatGetJournalTransactionForAccount :many
SELECT currency, amount, transacted_at, client_id, tx_id
FROM fiat_journal
WHERE client_id = $1 AND currency = $2
`

type fiatGetJournalTransactionForAccountParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Currency Currency  `json:"currency"`
}

// fiatGetJournalTransactionForAccount will retrieve the journal entries associated with a specific account.
func (q *Queries) fiatGetJournalTransactionForAccount(ctx context.Context, arg *fiatGetJournalTransactionForAccountParams) ([]FiatJournal, error) <span class="cov4" title="7">{
        rows, err := q.db.Query(ctx, fiatGetJournalTransactionForAccount, arg.ClientID, arg.Currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="7">defer rows.Close()
        var items []FiatJournal
        for rows.Next() </span><span class="cov4" title="6">{
                var i FiatJournal
                if err := rows.Scan(
                        &amp;i.Currency,
                        &amp;i.Amount,
                        &amp;i.TransactedAt,
                        &amp;i.ClientID,
                        &amp;i.TxID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="6">items = append(items, i)</span>
        }
        <span class="cov4" title="7">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="7">return items, nil</span>
}

const fiatInternalTransferJournalEntry = `-- name: fiatInternalTransferJournalEntry :one
WITH deposit AS (
    INSERT INTO fiat_journal(
        client_id,
        currency,
        amount,
        transacted_at,
        tx_id)
    SELECT
        $4::uuid,
        $5::currency,
        round_half_even(-1 * $6::numeric(18, 2), 2),
        now(),
        gen_random_uuid()
    RETURNING tx_id, transacted_at
)
INSERT INTO fiat_journal (
    client_id,
    currency,
    amount,
    transacted_at,
    tx_id)
SELECT
    $1::uuid,
    $2::currency,
    round_half_even($3::numeric(18, 2), 2),
    (   SELECT transacted_at
        FROM deposit),
    (   SELECT tx_id
        FROM deposit)
RETURNING tx_id, transacted_at
`

type fiatInternalTransferJournalEntryParams struct {
        DestinationAccount  uuid.UUID       `json:"destinationAccount"`
        DestinationCurrency Currency        `json:"destinationCurrency"`
        CreditAmount        decimal.Decimal `json:"creditAmount"`
        SourceAccount       uuid.UUID       `json:"sourceAccount"`
        SourceCurrency      Currency        `json:"sourceCurrency"`
        DebitAmount         decimal.Decimal `json:"debitAmount"`
}

type fiatInternalTransferJournalEntryRow struct {
        TxID         uuid.UUID          `json:"txID"`
        TransactedAt pgtype.Timestamptz `json:"transactedAt"`
}

// fiatInternalTransferJournalEntry will create both journal entries for fiat account internal transfers.
func (q *Queries) fiatInternalTransferJournalEntry(ctx context.Context, arg *fiatInternalTransferJournalEntryParams) (fiatInternalTransferJournalEntryRow, error) <span class="cov5" title="16">{
        row := q.db.QueryRow(ctx, fiatInternalTransferJournalEntry,
                arg.DestinationAccount,
                arg.DestinationCurrency,
                arg.CreditAmount,
                arg.SourceAccount,
                arg.SourceCurrency,
                arg.DebitAmount,
        )
        var i fiatInternalTransferJournalEntryRow
        err := row.Scan(&amp;i.TxID, &amp;i.TransactedAt)
        return i, err
}</span>

const fiatRowLockAccount = `-- name: fiatRowLockAccount :one
SELECT balance
FROM fiat_accounts
WHERE client_id=$1 AND currency=$2
LIMIT 1
FOR NO KEY UPDATE
`

type fiatRowLockAccountParams struct {
        ClientID uuid.UUID `json:"clientID"`
        Currency Currency  `json:"currency"`
}

// fiatRowLockAccount will acquire a row level lock without locks on the foreign keys.
func (q *Queries) fiatRowLockAccount(ctx context.Context, arg *fiatRowLockAccountParams) (decimal.Decimal, error) <span class="cov7" title="46">{
        row := q.db.QueryRow(ctx, fiatRowLockAccount, arg.ClientID, arg.Currency)
        var balance decimal.Decimal
        err := row.Scan(&amp;balance)
        return balance, err
}</span>

const fiatUpdateAccountBalance = `-- name: fiatUpdateAccountBalance :one
UPDATE fiat_accounts
SET balance=round_half_even(balance + $4::numeric(18, 2), 2),
    last_tx=round_half_even($4::numeric(18, 2), 2),
    last_tx_ts=$3
WHERE client_id=$1 AND currency=$2
RETURNING balance, last_tx, last_tx_ts
`

type fiatUpdateAccountBalanceParams struct {
        ClientID uuid.UUID          `json:"clientID"`
        Currency Currency           `json:"currency"`
        LastTxTs pgtype.Timestamptz `json:"lastTxTs"`
        Amount   decimal.Decimal    `json:"amount"`
}

type fiatUpdateAccountBalanceRow struct {
        Balance  decimal.Decimal    `json:"balance"`
        LastTx   decimal.Decimal    `json:"lastTx"`
        LastTxTs pgtype.Timestamptz `json:"lastTxTs"`
}

// fiatUpdateAccountBalance will add an amount to a fiat accounts balance.
func (q *Queries) fiatUpdateAccountBalance(ctx context.Context, arg *fiatUpdateAccountBalanceParams) (fiatUpdateAccountBalanceRow, error) <span class="cov7" title="39">{
        row := q.db.QueryRow(ctx, fiatUpdateAccountBalance,
                arg.ClientID,
                arg.Currency,
                arg.LastTxTs,
                arg.Amount,
        )
        var i fiatUpdateAccountBalanceRow
        err := row.Scan(&amp;i.Balance, &amp;i.LastTx, &amp;i.LastTxTs)
        return i, err
}</span>
</pre>

		<pre class="file" id="file30" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package postgres

import (
        "database/sql/driver"
        "fmt"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/shopspring/decimal"
)

type Currency string

const (
        CurrencyAED    Currency = "AED"
        CurrencyAFN    Currency = "AFN"
        CurrencyALL    Currency = "ALL"
        CurrencyAMD    Currency = "AMD"
        CurrencyANG    Currency = "ANG"
        CurrencyAOA    Currency = "AOA"
        CurrencyARS    Currency = "ARS"
        CurrencyAUD    Currency = "AUD"
        CurrencyAWG    Currency = "AWG"
        CurrencyAZN    Currency = "AZN"
        CurrencyBAM    Currency = "BAM"
        CurrencyBBD    Currency = "BBD"
        CurrencyBDT    Currency = "BDT"
        CurrencyBGN    Currency = "BGN"
        CurrencyBHD    Currency = "BHD"
        CurrencyBIF    Currency = "BIF"
        CurrencyBMD    Currency = "BMD"
        CurrencyBND    Currency = "BND"
        CurrencyBOB    Currency = "BOB"
        CurrencyBRL    Currency = "BRL"
        CurrencyBSD    Currency = "BSD"
        CurrencyBTN    Currency = "BTN"
        CurrencyBWP    Currency = "BWP"
        CurrencyBYN    Currency = "BYN"
        CurrencyBZD    Currency = "BZD"
        CurrencyCAD    Currency = "CAD"
        CurrencyCDF    Currency = "CDF"
        CurrencyCHF    Currency = "CHF"
        CurrencyCLP    Currency = "CLP"
        CurrencyCNY    Currency = "CNY"
        CurrencyCOP    Currency = "COP"
        CurrencyCRC    Currency = "CRC"
        CurrencyCUC    Currency = "CUC"
        CurrencyCUP    Currency = "CUP"
        CurrencyCVE    Currency = "CVE"
        CurrencyCZK    Currency = "CZK"
        CurrencyDJF    Currency = "DJF"
        CurrencyDKK    Currency = "DKK"
        CurrencyDOP    Currency = "DOP"
        CurrencyDZD    Currency = "DZD"
        CurrencyEGP    Currency = "EGP"
        CurrencyERN    Currency = "ERN"
        CurrencyETB    Currency = "ETB"
        CurrencyEUR    Currency = "EUR"
        CurrencyFJD    Currency = "FJD"
        CurrencyFKP    Currency = "FKP"
        CurrencyGBP    Currency = "GBP"
        CurrencyGEL    Currency = "GEL"
        CurrencyGGP    Currency = "GGP"
        CurrencyGHS    Currency = "GHS"
        CurrencyGIP    Currency = "GIP"
        CurrencyGMD    Currency = "GMD"
        CurrencyGNF    Currency = "GNF"
        CurrencyGTQ    Currency = "GTQ"
        CurrencyGYD    Currency = "GYD"
        CurrencyHKD    Currency = "HKD"
        CurrencyHNL    Currency = "HNL"
        CurrencyHRK    Currency = "HRK"
        CurrencyHTG    Currency = "HTG"
        CurrencyHUF    Currency = "HUF"
        CurrencyIDR    Currency = "IDR"
        CurrencyILS    Currency = "ILS"
        CurrencyIMP    Currency = "IMP"
        CurrencyINR    Currency = "INR"
        CurrencyIQD    Currency = "IQD"
        CurrencyIRR    Currency = "IRR"
        CurrencyISK    Currency = "ISK"
        CurrencyJEP    Currency = "JEP"
        CurrencyJMD    Currency = "JMD"
        CurrencyJOD    Currency = "JOD"
        CurrencyJPY    Currency = "JPY"
        CurrencyKES    Currency = "KES"
        CurrencyKGS    Currency = "KGS"
        CurrencyKHR    Currency = "KHR"
        CurrencyKMF    Currency = "KMF"
        CurrencyKPW    Currency = "KPW"
        CurrencyKRW    Currency = "KRW"
        CurrencyKWD    Currency = "KWD"
        CurrencyKYD    Currency = "KYD"
        CurrencyKZT    Currency = "KZT"
        CurrencyLAK    Currency = "LAK"
        CurrencyLBP    Currency = "LBP"
        CurrencyLKR    Currency = "LKR"
        CurrencyLRD    Currency = "LRD"
        CurrencyLSL    Currency = "LSL"
        CurrencyLYD    Currency = "LYD"
        CurrencyMAD    Currency = "MAD"
        CurrencyMDL    Currency = "MDL"
        CurrencyMGA    Currency = "MGA"
        CurrencyMKD    Currency = "MKD"
        CurrencyMMK    Currency = "MMK"
        CurrencyMNT    Currency = "MNT"
        CurrencyMOP    Currency = "MOP"
        CurrencyMRU    Currency = "MRU"
        CurrencyMUR    Currency = "MUR"
        CurrencyMVR    Currency = "MVR"
        CurrencyMWK    Currency = "MWK"
        CurrencyMXN    Currency = "MXN"
        CurrencyMYR    Currency = "MYR"
        CurrencyMZN    Currency = "MZN"
        CurrencyNAD    Currency = "NAD"
        CurrencyNGN    Currency = "NGN"
        CurrencyNIO    Currency = "NIO"
        CurrencyNOK    Currency = "NOK"
        CurrencyNPR    Currency = "NPR"
        CurrencyNZD    Currency = "NZD"
        CurrencyOMR    Currency = "OMR"
        CurrencyPAB    Currency = "PAB"
        CurrencyPEN    Currency = "PEN"
        CurrencyPGK    Currency = "PGK"
        CurrencyPHP    Currency = "PHP"
        CurrencyPKR    Currency = "PKR"
        CurrencyPLN    Currency = "PLN"
        CurrencyPYG    Currency = "PYG"
        CurrencyQAR    Currency = "QAR"
        CurrencyRON    Currency = "RON"
        CurrencyRSD    Currency = "RSD"
        CurrencyRUB    Currency = "RUB"
        CurrencyRWF    Currency = "RWF"
        CurrencySAR    Currency = "SAR"
        CurrencySBD    Currency = "SBD"
        CurrencySCR    Currency = "SCR"
        CurrencySDG    Currency = "SDG"
        CurrencySEK    Currency = "SEK"
        CurrencySGD    Currency = "SGD"
        CurrencySHP    Currency = "SHP"
        CurrencySLL    Currency = "SLL"
        CurrencySOS    Currency = "SOS"
        CurrencySPL    Currency = "SPL"
        CurrencySRD    Currency = "SRD"
        CurrencySTN    Currency = "STN"
        CurrencySVC    Currency = "SVC"
        CurrencySYP    Currency = "SYP"
        CurrencySZL    Currency = "SZL"
        CurrencyTHB    Currency = "THB"
        CurrencyTJS    Currency = "TJS"
        CurrencyTMT    Currency = "TMT"
        CurrencyTND    Currency = "TND"
        CurrencyTOP    Currency = "TOP"
        CurrencyTRY    Currency = "TRY"
        CurrencyTTD    Currency = "TTD"
        CurrencyTVD    Currency = "TVD"
        CurrencyTWD    Currency = "TWD"
        CurrencyTZS    Currency = "TZS"
        CurrencyUAH    Currency = "UAH"
        CurrencyUGX    Currency = "UGX"
        CurrencyUSD    Currency = "USD"
        CurrencyUYU    Currency = "UYU"
        CurrencyUZS    Currency = "UZS"
        CurrencyVEF    Currency = "VEF"
        CurrencyVND    Currency = "VND"
        CurrencyVUV    Currency = "VUV"
        CurrencyWST    Currency = "WST"
        CurrencyXAF    Currency = "XAF"
        CurrencyXCD    Currency = "XCD"
        CurrencyXDR    Currency = "XDR"
        CurrencyXOF    Currency = "XOF"
        CurrencyXPF    Currency = "XPF"
        CurrencyYER    Currency = "YER"
        CurrencyZAR    Currency = "ZAR"
        CurrencyZMW    Currency = "ZMW"
        CurrencyZWD    Currency = "ZWD"
        CurrencyFIAT   Currency = "FIAT"
        CurrencyCRYPTO Currency = "CRYPTO"
)

func (e *Currency) Scan(src interface{}) error <span class="cov10" title="122">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov2" title="2">
                *e = Currency(s)</span>
        case string:<span class="cov9" title="118">
                *e = Currency(s)</span>
        default:<span class="cov2" title="2">
                return fmt.Errorf("unsupported scan type for Currency: %T", src)</span>
        }
        <span class="cov9" title="120">return nil</span>
}

type NullCurrency struct {
        Currency Currency
        Valid    bool // Valid is true if Currency is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCurrency) Scan(value interface{}) error <span class="cov3" title="4">{
        if value == nil </span><span class="cov1" title="1">{
                ns.Currency, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov3" title="3">ns.Valid = true
        return ns.Currency.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullCurrency) Value() (driver.Value, error) <span class="cov2" title="2">{
        if !ns.Valid </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">return string(ns.Currency), nil</span>
}

func (e Currency) Valid() bool <span class="cov5" title="12">{
        switch e </span>{
        case CurrencyAED,
                CurrencyAFN,
                CurrencyALL,
                CurrencyAMD,
                CurrencyANG,
                CurrencyAOA,
                CurrencyARS,
                CurrencyAUD,
                CurrencyAWG,
                CurrencyAZN,
                CurrencyBAM,
                CurrencyBBD,
                CurrencyBDT,
                CurrencyBGN,
                CurrencyBHD,
                CurrencyBIF,
                CurrencyBMD,
                CurrencyBND,
                CurrencyBOB,
                CurrencyBRL,
                CurrencyBSD,
                CurrencyBTN,
                CurrencyBWP,
                CurrencyBYN,
                CurrencyBZD,
                CurrencyCAD,
                CurrencyCDF,
                CurrencyCHF,
                CurrencyCLP,
                CurrencyCNY,
                CurrencyCOP,
                CurrencyCRC,
                CurrencyCUC,
                CurrencyCUP,
                CurrencyCVE,
                CurrencyCZK,
                CurrencyDJF,
                CurrencyDKK,
                CurrencyDOP,
                CurrencyDZD,
                CurrencyEGP,
                CurrencyERN,
                CurrencyETB,
                CurrencyEUR,
                CurrencyFJD,
                CurrencyFKP,
                CurrencyGBP,
                CurrencyGEL,
                CurrencyGGP,
                CurrencyGHS,
                CurrencyGIP,
                CurrencyGMD,
                CurrencyGNF,
                CurrencyGTQ,
                CurrencyGYD,
                CurrencyHKD,
                CurrencyHNL,
                CurrencyHRK,
                CurrencyHTG,
                CurrencyHUF,
                CurrencyIDR,
                CurrencyILS,
                CurrencyIMP,
                CurrencyINR,
                CurrencyIQD,
                CurrencyIRR,
                CurrencyISK,
                CurrencyJEP,
                CurrencyJMD,
                CurrencyJOD,
                CurrencyJPY,
                CurrencyKES,
                CurrencyKGS,
                CurrencyKHR,
                CurrencyKMF,
                CurrencyKPW,
                CurrencyKRW,
                CurrencyKWD,
                CurrencyKYD,
                CurrencyKZT,
                CurrencyLAK,
                CurrencyLBP,
                CurrencyLKR,
                CurrencyLRD,
                CurrencyLSL,
                CurrencyLYD,
                CurrencyMAD,
                CurrencyMDL,
                CurrencyMGA,
                CurrencyMKD,
                CurrencyMMK,
                CurrencyMNT,
                CurrencyMOP,
                CurrencyMRU,
                CurrencyMUR,
                CurrencyMVR,
                CurrencyMWK,
                CurrencyMXN,
                CurrencyMYR,
                CurrencyMZN,
                CurrencyNAD,
                CurrencyNGN,
                CurrencyNIO,
                CurrencyNOK,
                CurrencyNPR,
                CurrencyNZD,
                CurrencyOMR,
                CurrencyPAB,
                CurrencyPEN,
                CurrencyPGK,
                CurrencyPHP,
                CurrencyPKR,
                CurrencyPLN,
                CurrencyPYG,
                CurrencyQAR,
                CurrencyRON,
                CurrencyRSD,
                CurrencyRUB,
                CurrencyRWF,
                CurrencySAR,
                CurrencySBD,
                CurrencySCR,
                CurrencySDG,
                CurrencySEK,
                CurrencySGD,
                CurrencySHP,
                CurrencySLL,
                CurrencySOS,
                CurrencySPL,
                CurrencySRD,
                CurrencySTN,
                CurrencySVC,
                CurrencySYP,
                CurrencySZL,
                CurrencyTHB,
                CurrencyTJS,
                CurrencyTMT,
                CurrencyTND,
                CurrencyTOP,
                CurrencyTRY,
                CurrencyTTD,
                CurrencyTVD,
                CurrencyTWD,
                CurrencyTZS,
                CurrencyUAH,
                CurrencyUGX,
                CurrencyUSD,
                CurrencyUYU,
                CurrencyUZS,
                CurrencyVEF,
                CurrencyVND,
                CurrencyVUV,
                CurrencyWST,
                CurrencyXAF,
                CurrencyXCD,
                CurrencyXDR,
                CurrencyXOF,
                CurrencyXPF,
                CurrencyYER,
                CurrencyZAR,
                CurrencyZMW,
                CurrencyZWD,
                CurrencyFIAT,
                CurrencyCRYPTO:<span class="cov5" title="10">
                return true</span>
        }
        <span class="cov2" title="2">return false</span>
}

type CryptoAccount struct {
        Ticker    string             `json:"ticker"`
        Balance   decimal.Decimal    `json:"balance"`
        LastTx    decimal.Decimal    `json:"lastTx"`
        LastTxTs  pgtype.Timestamptz `json:"lastTxTs"`
        CreatedAt pgtype.Timestamptz `json:"createdAt"`
        ClientID  uuid.UUID          `json:"clientID"`
}

type CryptoJournal struct {
        Ticker       string             `json:"ticker"`
        Amount       decimal.Decimal    `json:"amount"`
        TransactedAt pgtype.Timestamptz `json:"transactedAt"`
        ClientID     uuid.UUID          `json:"clientID"`
        TxID         uuid.UUID          `json:"txID"`
}

type FiatAccount struct {
        Currency  Currency           `json:"currency"`
        Balance   decimal.Decimal    `json:"balance"`
        LastTx    decimal.Decimal    `json:"lastTx"`
        LastTxTs  pgtype.Timestamptz `json:"lastTxTs"`
        CreatedAt pgtype.Timestamptz `json:"createdAt"`
        ClientID  uuid.UUID          `json:"clientID"`
}

type FiatJournal struct {
        Currency     Currency           `json:"currency"`
        Amount       decimal.Decimal    `json:"amount"`
        TransactedAt pgtype.Timestamptz `json:"transactedAt"`
        ClientID     uuid.UUID          `json:"clientID"`
        TxID         uuid.UUID          `json:"txID"`
}

type User struct {
        FirstName string    `json:"firstName"`
        LastName  string    `json:"lastName"`
        Email     string    `json:"email"`
        Username  string    `json:"username"`
        Password  string    `json:"password"`
        ClientID  uuid.UUID `json:"clientID"`
        IsDeleted bool      `json:"isDeleted"`
}
</pre>

		<pre class="file" id="file31" style="display: none">package postgres

import (
        "context"
        "errors"
        "fmt"
        "math"
        "strconv"
        "time"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/shopspring/decimal"
        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        modelsPostgres "github.com/surahman/FTeX/pkg/models/postgres"
        "go.uber.org/zap"
)

// Mock Postgres SQLC Querier interface stub generation. This is local to the Postgres package.
//go:generate mockgen -destination=querier_mocks.go -package=postgres github.com/surahman/FTeX/pkg/postgres Querier

// Mock Postgres interface stub generation.
//go:generate mockgen -destination=../mocks/mock_postgres.go -package=mocks github.com/surahman/FTeX/pkg/postgres Postgres

// Postgres is the interface through which the queries will be executed on the database.
//
//nolint:interfacebloat
type Postgres interface {
        // Open will establish a pooled connection to the Postgres database and ping it to ensure the connection is open.
        Open() error

        // Close will close an established Postgres pooled connection to support a healthy database.
        Close() error

        // Healthcheck will run a Ping command on an established Postgres database connection.
        Healthcheck() error

        // UserRegister will create a user account in the Postgres database.
        UserRegister(*modelsPostgres.UserAccount) (uuid.UUID, error)

        // UserCredentials will retrieve the ClientID and hashed password associated with a provided username.
        UserCredentials(string) (uuid.UUID, string, error)

        // UserGetInfo will retrieve the account information associated with a Client ID.
        UserGetInfo(uuid.UUID) (modelsPostgres.User, error)

        // UserDelete will delete the account information associated with a Client ID.
        UserDelete(uuid.UUID) error

        // UserIsDeleted is the interface through which external methods can check if a user account is soft-deleted.
        UserIsDeleted(uuid.UUID) (bool, error)

        // FiatCreateAccount will open an account associated with a Client ID for a specific currency.
        FiatCreateAccount(uuid.UUID, Currency) error

        // FiatExternalTransfer will transfer Fiat funds into an account associated with a Client ID for a specific
        // currency.
        FiatExternalTransfer(context.Context, *FiatTransactionDetails) (*FiatAccountTransferResult, error)

        // FiatInternalTransfer will transfer Fiat funds for a specific Client ID between two Fiat currency accounts for
        // that client.
        FiatInternalTransfer(context.Context, *FiatTransactionDetails, *FiatTransactionDetails) (
                *FiatAccountTransferResult, *FiatAccountTransferResult, error)

        // FiatBalance is the interface through which external methods can retrieve a Fiat account balance for a specific
        // currency.
        FiatBalance(uuid.UUID, Currency) (FiatAccount, error)

        // FiatTxDetails is the interface through which external methods can retrieve a Fiat transaction details for a
        // specific transaction.
        FiatTxDetails(uuid.UUID, uuid.UUID) ([]FiatJournal, error)

        // FiatBalancePaginated is the interface through which external methods can retrieve all Fiat account balances
        // for a specific client.
        FiatBalancePaginated(uuid.UUID, Currency, int32) ([]FiatAccount, error)

        // FiatTransactionsPaginated is the interface through which external methods can retrieve transactions on a
        // Fiat account for a specific client during a specific month.
        FiatTransactionsPaginated(uuid.UUID, Currency, int32, int32, pgtype.Timestamptz, pgtype.Timestamptz) (
                []FiatJournal, error)

        // CryptoCreateAccount is the interface through which external methods can create a Crypto account.
        CryptoCreateAccount(uuid.UUID, string) error

        // CryptoBalance is the interface through which external methods can retrieve a Fiat-account balance for a specific
        // cryptocurrency.
        CryptoBalance(uuid.UUID, string) (CryptoAccount, error)

        // CryptoTxDetails is the interface through which external methods can retrieve a Crypto transaction details for a
        // specific transaction.
        CryptoTxDetails(uuid.UUID, uuid.UUID) ([]CryptoJournal, error)

        // CryptoPurchase is the interface through which external methods can purchase a specific Cryptocurrency.
        CryptoPurchase(uuid.UUID, Currency, decimal.Decimal, string, decimal.Decimal) (*FiatJournal, *CryptoJournal, error)

        // CryptoSell is the interface through which external methods can sell a specific Cryptocurrency.
        CryptoSell(uuid.UUID, Currency, decimal.Decimal, string, decimal.Decimal) (*FiatJournal, *CryptoJournal, error)

        // CryptoBalancesPaginated is the interface through which external methods can retrieve all Crypto account balances
        // for a specific client.
        CryptoBalancesPaginated(uuid.UUID, string, int32) ([]CryptoAccount, error)

        // CryptoTransactionsPaginated is the interface through which external methods can retrieve transactions on a Crypto
        // account for a specific client during a specific month.
        CryptoTransactionsPaginated(uuid.UUID, string, int32, int32, pgtype.Timestamptz, pgtype.Timestamptz) (
                []CryptoJournal, error)
}

// Check to ensure the Postgres interface has been implemented.
var _ Postgres = &amp;postgresImpl{}

// postgresImpl contains objects required to interface with the database.
type postgresImpl struct {
        conf    config
        pool    *pgxpool.Pool
        logger  *logger.Logger
        queries *Queries
        Query   Querier
}

// NewPostgres will create a new Postgres configuration by loading it.
func NewPostgres(fs *afero.Fs, logger *logger.Logger) (Postgres, error) <span class="cov5" title="4">{
        if fs == nil || logger == nil </span><span class="cov4" title="3">{
                return nil, errors.New("nil file system or logger supplied")
        }</span>

        <span class="cov1" title="1">return newPostgresImpl(fs, logger)</span>
}

// newPostgresImpl will create a new postgresImpl configuration and load it from disk.
func newPostgresImpl(fs *afero.Fs, logger *logger.Logger) (*postgresImpl, error) <span class="cov7" title="8">{
        if fs == nil || logger == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil file system or logger supplied")
        }</span>

        <span class="cov7" title="8">postgres := &amp;postgresImpl{conf: newConfig(), logger: logger}
        if err := postgres.conf.Load(*fs); err != nil </span><span class="cov1" title="1">{
                postgres.logger.Error("failed to load Postgres configurations from disk", zap.Error(err))

                return nil, err
        }</span>

        <span class="cov6" title="7">return postgres, nil</span>
}

// Open will start a database connection pool and establish a connection.
func (p *postgresImpl) Open() error <span class="cov6" title="6">{
        var err error
        if err = p.verifySession(); err == nil </span><span class="cov0" title="0">{
                return errors.New("connection is already established to Postgres")
        }</span>

        <span class="cov6" title="6">var pgxConfig *pgxpool.Config

        if pgxConfig, err = pgxpool.ParseConfig(fmt.Sprintf(constants.PostgresDSN(),
                p.conf.Authentication.Username,
                p.conf.Authentication.Password,
                p.conf.Connection.Host,
                p.conf.Connection.Port,
                p.conf.Connection.Database,
                p.conf.Connection.Timeout)); err != nil </span><span class="cov0" title="0">{
                msg := "failed to parse Postgres DSN"
                p.logger.Error(msg, zap.Error(err))

                return fmt.Errorf(msg+"%w", err)
        }</span>

        <span class="cov6" title="6">pgxConfig.MaxConns = p.conf.Pool.MaxConns
        pgxConfig.MinConns = p.conf.Pool.MinConns
        pgxConfig.HealthCheckPeriod = p.conf.Pool.HealthCheckPeriod

        if p.pool, err = pgxpool.NewWithConfig(context.Background(), pgxConfig); err != nil </span><span class="cov0" title="0">{
                msg := "failed to configure Postgres connection"
                p.logger.Error(msg, zap.Error(err))

                return fmt.Errorf(msg+"%w", err)
        }</span>

        // Binary Exponential Backoff connection to Postgres. The lazy connection can be opened via a ping to the database.
        <span class="cov6" title="6">if err = p.createSessionRetry(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Setup SQLC DBTX interface.
        <span class="cov5" title="5">p.queries = New(p.pool)
        p.Query = p.queries

        return nil</span>
}

// verifySession will check to see if a session is established.
func (p *postgresImpl) verifySession() error <span class="cov10" title="19">{
        if p.pool == nil || p.pool.Ping(context.Background()) != nil </span><span class="cov8" title="13">{
                return errors.New("no session established")
        }</span>

        <span class="cov6" title="6">return nil</span>
}

// createSessionRetry will attempt to open the connection using binary exponential back-off.
// Stop on the first success or fail after the last one.
func (p *postgresImpl) createSessionRetry() (err error) <span class="cov6" title="6">{
        for attempt := 1; attempt &lt;= p.conf.Connection.MaxConnAttempts; attempt++ </span><span class="cov6" title="6">{
                waitTime := time.Duration(math.Pow(2, float64(attempt))) * time.Second
                p.logger.Info(fmt.Sprintf("Attempting connection to Postgres database in %s...", waitTime),
                        zap.String("attempt", strconv.Itoa(attempt)))
                time.Sleep(waitTime)

                if err = p.pool.Ping(context.Background()); err == nil </span><span class="cov5" title="5">{
                        return nil
                }</span>
        }
        <span class="cov1" title="1">p.logger.Error("unable to establish connection to Postgres database", zap.Error(err))

        return</span>
}

// Close will close the database connection pool.
func (p *postgresImpl) Close() (err error) <span class="cov6" title="6">{
        if err = p.verifySession(); err != nil </span><span class="cov3" title="2">{
                msg := "no established Postgres connection to close"
                p.logger.Error(msg)

                return errors.New(msg)
        }</span>

        <span class="cov5" title="4">p.pool.Close()

        return</span>
}

// Healthcheck will run a ping on the database to ascertain health.
func (p *postgresImpl) Healthcheck() error <span class="cov4" title="3">{
        var err error
        if err = p.verifySession(); err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov1" title="1">if err = p.pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("postgres cluster ping failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file32" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package postgres

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov5" title="5">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov10" title="26">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>

		<pre class="file" id="file33" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/surahman/FTeX/pkg/postgres (interfaces: Querier)

// Package postgres is a generated GoMock package.
package postgres

import (
        context "context"
        reflect "reflect"

        uuid "github.com/gofrs/uuid"
        gomock "github.com/golang/mock/gomock"
        decimal "github.com/shopspring/decimal"
)

// MockQuerier is a mock of Querier interface.
type MockQuerier struct {
        ctrl     *gomock.Controller
        recorder *MockQuerierMockRecorder
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder struct {
        mock *MockQuerier
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier(ctrl *gomock.Controller) *MockQuerier <span class="cov7" title="10">{
        mock := &amp;MockQuerier{ctrl: ctrl}
        mock.recorder = &amp;MockQuerierMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier) EXPECT() *MockQuerierMockRecorder <span class="cov10" title="31">{
        return m.recorder
}</span>

// cryptoCreateAccount mocks base method.
func (m *MockQuerier) cryptoCreateAccount(arg0 context.Context, arg1 *cryptoCreateAccountParams) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoCreateAccount", arg0, arg1)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// cryptoCreateAccount indicates an expected call of cryptoCreateAccount.
func (mr *MockQuerierMockRecorder) cryptoCreateAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoCreateAccount", reflect.TypeOf((*MockQuerier)(nil).cryptoCreateAccount), arg0, arg1)
}</span>

// cryptoGetAccount mocks base method.
func (m *MockQuerier) cryptoGetAccount(arg0 context.Context, arg1 *cryptoGetAccountParams) (CryptoAccount, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoGetAccount", arg0, arg1)
        ret0, _ := ret[0].(CryptoAccount)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// cryptoGetAccount indicates an expected call of cryptoGetAccount.
func (mr *MockQuerierMockRecorder) cryptoGetAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoGetAccount", reflect.TypeOf((*MockQuerier)(nil).cryptoGetAccount), arg0, arg1)
}</span>

// cryptoGetAllAccounts mocks base method.
func (m *MockQuerier) cryptoGetAllAccounts(arg0 context.Context, arg1 *cryptoGetAllAccountsParams) ([]CryptoAccount, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoGetAllAccounts", arg0, arg1)
        ret0, _ := ret[0].([]CryptoAccount)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// cryptoGetAllAccounts indicates an expected call of cryptoGetAllAccounts.
func (mr *MockQuerierMockRecorder) cryptoGetAllAccounts(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoGetAllAccounts", reflect.TypeOf((*MockQuerier)(nil).cryptoGetAllAccounts), arg0, arg1)
}</span>

// cryptoGetAllJournalTransactionsPaginated mocks base method.
func (m *MockQuerier) cryptoGetAllJournalTransactionsPaginated(arg0 context.Context, arg1 *cryptoGetAllJournalTransactionsPaginatedParams) ([]CryptoJournal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoGetAllJournalTransactionsPaginated", arg0, arg1)
        ret0, _ := ret[0].([]CryptoJournal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// cryptoGetAllJournalTransactionsPaginated indicates an expected call of cryptoGetAllJournalTransactionsPaginated.
func (mr *MockQuerierMockRecorder) cryptoGetAllJournalTransactionsPaginated(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoGetAllJournalTransactionsPaginated", reflect.TypeOf((*MockQuerier)(nil).cryptoGetAllJournalTransactionsPaginated), arg0, arg1)
}</span>

// cryptoGetJournalTransaction mocks base method.
func (m *MockQuerier) cryptoGetJournalTransaction(arg0 context.Context, arg1 *cryptoGetJournalTransactionParams) ([]CryptoJournal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoGetJournalTransaction", arg0, arg1)
        ret0, _ := ret[0].([]CryptoJournal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// cryptoGetJournalTransaction indicates an expected call of cryptoGetJournalTransaction.
func (mr *MockQuerierMockRecorder) cryptoGetJournalTransaction(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoGetJournalTransaction", reflect.TypeOf((*MockQuerier)(nil).cryptoGetJournalTransaction), arg0, arg1)
}</span>

// cryptoPurchase mocks base method.
func (m *MockQuerier) cryptoPurchase(arg0 context.Context, arg1 *cryptoPurchaseParams) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoPurchase", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// cryptoPurchase indicates an expected call of cryptoPurchase.
func (mr *MockQuerierMockRecorder) cryptoPurchase(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoPurchase", reflect.TypeOf((*MockQuerier)(nil).cryptoPurchase), arg0, arg1)
}</span>

// cryptoSell mocks base method.
func (m *MockQuerier) cryptoSell(arg0 context.Context, arg1 *cryptoSellParams) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoSell", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// cryptoSell indicates an expected call of cryptoSell.
func (mr *MockQuerierMockRecorder) cryptoSell(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoSell", reflect.TypeOf((*MockQuerier)(nil).cryptoSell), arg0, arg1)
}</span>

// fiatCreateAccount mocks base method.
func (m *MockQuerier) fiatCreateAccount(arg0 context.Context, arg1 *fiatCreateAccountParams) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatCreateAccount", arg0, arg1)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatCreateAccount indicates an expected call of fiatCreateAccount.
func (mr *MockQuerierMockRecorder) fiatCreateAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatCreateAccount", reflect.TypeOf((*MockQuerier)(nil).fiatCreateAccount), arg0, arg1)
}</span>

// fiatExternalTransferJournalEntry mocks base method.
func (m *MockQuerier) fiatExternalTransferJournalEntry(arg0 context.Context, arg1 *fiatExternalTransferJournalEntryParams) (fiatExternalTransferJournalEntryRow, error) <span class="cov2" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatExternalTransferJournalEntry", arg0, arg1)
        ret0, _ := ret[0].(fiatExternalTransferJournalEntryRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatExternalTransferJournalEntry indicates an expected call of fiatExternalTransferJournalEntry.
func (mr *MockQuerierMockRecorder) fiatExternalTransferJournalEntry(arg0, arg1 interface{}) *gomock.Call <span class="cov3" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatExternalTransferJournalEntry", reflect.TypeOf((*MockQuerier)(nil).fiatExternalTransferJournalEntry), arg0, arg1)
}</span>

// fiatGetAccount mocks base method.
func (m *MockQuerier) fiatGetAccount(arg0 context.Context, arg1 *fiatGetAccountParams) (FiatAccount, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatGetAccount", arg0, arg1)
        ret0, _ := ret[0].(FiatAccount)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatGetAccount indicates an expected call of fiatGetAccount.
func (mr *MockQuerierMockRecorder) fiatGetAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatGetAccount", reflect.TypeOf((*MockQuerier)(nil).fiatGetAccount), arg0, arg1)
}</span>

// fiatGetAllAccounts mocks base method.
func (m *MockQuerier) fiatGetAllAccounts(arg0 context.Context, arg1 *fiatGetAllAccountsParams) ([]FiatAccount, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatGetAllAccounts", arg0, arg1)
        ret0, _ := ret[0].([]FiatAccount)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatGetAllAccounts indicates an expected call of fiatGetAllAccounts.
func (mr *MockQuerierMockRecorder) fiatGetAllAccounts(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatGetAllAccounts", reflect.TypeOf((*MockQuerier)(nil).fiatGetAllAccounts), arg0, arg1)
}</span>

// fiatGetAllJournalTransactionsPaginated mocks base method.
func (m *MockQuerier) fiatGetAllJournalTransactionsPaginated(arg0 context.Context, arg1 *fiatGetAllJournalTransactionsPaginatedParams) ([]FiatJournal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatGetAllJournalTransactionsPaginated", arg0, arg1)
        ret0, _ := ret[0].([]FiatJournal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatGetAllJournalTransactionsPaginated indicates an expected call of fiatGetAllJournalTransactionsPaginated.
func (mr *MockQuerierMockRecorder) fiatGetAllJournalTransactionsPaginated(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatGetAllJournalTransactionsPaginated", reflect.TypeOf((*MockQuerier)(nil).fiatGetAllJournalTransactionsPaginated), arg0, arg1)
}</span>

// fiatGetJournalTransaction mocks base method.
func (m *MockQuerier) fiatGetJournalTransaction(arg0 context.Context, arg1 *fiatGetJournalTransactionParams) ([]FiatJournal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatGetJournalTransaction", arg0, arg1)
        ret0, _ := ret[0].([]FiatJournal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatGetJournalTransaction indicates an expected call of fiatGetJournalTransaction.
func (mr *MockQuerierMockRecorder) fiatGetJournalTransaction(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatGetJournalTransaction", reflect.TypeOf((*MockQuerier)(nil).fiatGetJournalTransaction), arg0, arg1)
}</span>

// fiatGetJournalTransactionForAccount mocks base method.
func (m *MockQuerier) fiatGetJournalTransactionForAccount(arg0 context.Context, arg1 *fiatGetJournalTransactionForAccountParams) ([]FiatJournal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatGetJournalTransactionForAccount", arg0, arg1)
        ret0, _ := ret[0].([]FiatJournal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatGetJournalTransactionForAccount indicates an expected call of fiatGetJournalTransactionForAccount.
func (mr *MockQuerierMockRecorder) fiatGetJournalTransactionForAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatGetJournalTransactionForAccount", reflect.TypeOf((*MockQuerier)(nil).fiatGetJournalTransactionForAccount), arg0, arg1)
}</span>

// fiatInternalTransferJournalEntry mocks base method.
func (m *MockQuerier) fiatInternalTransferJournalEntry(arg0 context.Context, arg1 *fiatInternalTransferJournalEntryParams) (fiatInternalTransferJournalEntryRow, error) <span class="cov3" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatInternalTransferJournalEntry", arg0, arg1)
        ret0, _ := ret[0].(fiatInternalTransferJournalEntryRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatInternalTransferJournalEntry indicates an expected call of fiatInternalTransferJournalEntry.
func (mr *MockQuerierMockRecorder) fiatInternalTransferJournalEntry(arg0, arg1 interface{}) *gomock.Call <span class="cov4" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatInternalTransferJournalEntry", reflect.TypeOf((*MockQuerier)(nil).fiatInternalTransferJournalEntry), arg0, arg1)
}</span>

// fiatRowLockAccount mocks base method.
func (m *MockQuerier) fiatRowLockAccount(arg0 context.Context, arg1 *fiatRowLockAccountParams) (decimal.Decimal, error) <span class="cov8" title="15">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatRowLockAccount", arg0, arg1)
        ret0, _ := ret[0].(decimal.Decimal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatRowLockAccount indicates an expected call of fiatRowLockAccount.
func (mr *MockQuerierMockRecorder) fiatRowLockAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov7" title="13">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatRowLockAccount", reflect.TypeOf((*MockQuerier)(nil).fiatRowLockAccount), arg0, arg1)
}</span>

// fiatUpdateAccountBalance mocks base method.
func (m *MockQuerier) fiatUpdateAccountBalance(arg0 context.Context, arg1 *fiatUpdateAccountBalanceParams) (fiatUpdateAccountBalanceRow, error) <span class="cov4" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatUpdateAccountBalance", arg0, arg1)
        ret0, _ := ret[0].(fiatUpdateAccountBalanceRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatUpdateAccountBalance indicates an expected call of fiatUpdateAccountBalance.
func (mr *MockQuerierMockRecorder) fiatUpdateAccountBalance(arg0, arg1 interface{}) *gomock.Call <span class="cov7" title="11">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatUpdateAccountBalance", reflect.TypeOf((*MockQuerier)(nil).fiatUpdateAccountBalance), arg0, arg1)
}</span>

// testRoundHalfEven mocks base method.
func (m *MockQuerier) testRoundHalfEven(arg0 context.Context, arg1 *testRoundHalfEvenParams) (decimal.Decimal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "testRoundHalfEven", arg0, arg1)
        ret0, _ := ret[0].(decimal.Decimal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// testRoundHalfEven indicates an expected call of testRoundHalfEven.
func (mr *MockQuerierMockRecorder) testRoundHalfEven(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "testRoundHalfEven", reflect.TypeOf((*MockQuerier)(nil).testRoundHalfEven), arg0, arg1)
}</span>

// userCreate mocks base method.
func (m *MockQuerier) userCreate(arg0 context.Context, arg1 *userCreateParams) (uuid.UUID, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "userCreate", arg0, arg1)
        ret0, _ := ret[0].(uuid.UUID)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// userCreate indicates an expected call of userCreate.
func (mr *MockQuerierMockRecorder) userCreate(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "userCreate", reflect.TypeOf((*MockQuerier)(nil).userCreate), arg0, arg1)
}</span>

// userDelete mocks base method.
func (m *MockQuerier) userDelete(arg0 context.Context, arg1 uuid.UUID) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "userDelete", arg0, arg1)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// userDelete indicates an expected call of userDelete.
func (mr *MockQuerierMockRecorder) userDelete(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "userDelete", reflect.TypeOf((*MockQuerier)(nil).userDelete), arg0, arg1)
}</span>

// userGetClientId mocks base method.
func (m *MockQuerier) userGetClientId(arg0 context.Context, arg1 string) (uuid.UUID, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "userGetClientId", arg0, arg1)
        ret0, _ := ret[0].(uuid.UUID)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// userGetClientId indicates an expected call of userGetClientId.
func (mr *MockQuerierMockRecorder) userGetClientId(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "userGetClientId", reflect.TypeOf((*MockQuerier)(nil).userGetClientId), arg0, arg1)
}</span>

// userGetCredentials mocks base method.
func (m *MockQuerier) userGetCredentials(arg0 context.Context, arg1 string) (userGetCredentialsRow, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "userGetCredentials", arg0, arg1)
        ret0, _ := ret[0].(userGetCredentialsRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// userGetCredentials indicates an expected call of userGetCredentials.
func (mr *MockQuerierMockRecorder) userGetCredentials(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "userGetCredentials", reflect.TypeOf((*MockQuerier)(nil).userGetCredentials), arg0, arg1)
}</span>

// userGetInfo mocks base method.
func (m *MockQuerier) userGetInfo(arg0 context.Context, arg1 uuid.UUID) (userGetInfoRow, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "userGetInfo", arg0, arg1)
        ret0, _ := ret[0].(userGetInfoRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// userGetInfo indicates an expected call of userGetInfo.
func (mr *MockQuerierMockRecorder) userGetInfo(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "userGetInfo", reflect.TypeOf((*MockQuerier)(nil).userGetInfo), arg0, arg1)
}</span>

// userIsDeleted mocks base method.
func (m *MockQuerier) userIsDeleted(arg0 context.Context, arg1 uuid.UUID) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "userIsDeleted", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// userIsDeleted indicates an expected call of userIsDeleted.
func (mr *MockQuerierMockRecorder) userIsDeleted(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "userIsDeleted", reflect.TypeOf((*MockQuerier)(nil).userIsDeleted), arg0, arg1)
}</span>
</pre>

		<pre class="file" id="file34" style="display: none">package postgres

import (
        "context"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/shopspring/decimal"
        "github.com/surahman/FTeX/pkg/constants"
        "go.uber.org/zap"
)

// CryptoCreateAccount is the interface through which external methods can create a Crypto account.
func (p *postgresImpl) CryptoCreateAccount(clientID uuid.UUID, ticker string) error <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        rowsAffected, err := p.Query.cryptoCreateAccount(ctx, &amp;cryptoCreateAccountParams{ClientID: clientID, Ticker: ticker})
        if err != nil || rowsAffected != int64(1) </span><span class="cov0" title="0">{
                p.logger.Error("failed to create Crypto account", zap.Error(err))

                return ErrCreateFiat
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// CryptoBalance is the interface through which external methods can retrieve a Crypto-account balance for a specific
// cryptocurrency.
func (p *postgresImpl) CryptoBalance(clientID uuid.UUID, ticker string) (CryptoAccount, error) <span class="cov7" title="6">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        balance, err := p.Query.cryptoGetAccount(ctx, &amp;cryptoGetAccountParams{clientID, ticker})
        if err != nil </span><span class="cov1" title="1">{
                return CryptoAccount{}, ErrNotFound
        }</span>

        <span class="cov6" title="5">return balance, nil</span>
}

// CryptoTxDetails is the interface through which external methods can retrieve a Crypto transaction details for a
// specific transaction.
func (p *postgresImpl) CryptoTxDetails(clientID uuid.UUID, transactionID uuid.UUID) ([]CryptoJournal, error) <span class="cov10" title="14">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())
        defer cancel()

        journal, err := p.Query.cryptoGetJournalTransaction(ctx, &amp;cryptoGetJournalTransactionParams{clientID, transactionID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>

        <span class="cov10" title="14">return journal, nil</span>
}

// CryptoPurchase is the interface through which external methods can purchase a specific Cryptocurrency.
//
//nolint:dupl
func (p *postgresImpl) CryptoPurchase(
        clientID uuid.UUID,
        fiatCurrency Currency,
        fiatDebitAmount decimal.Decimal,
        cryptoTicker string,
        cryptoCreditAmount decimal.Decimal) (*FiatJournal, *CryptoJournal, error) <span class="cov7" title="7">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())
        defer cancel()

        txID, err := uuid.NewV4()
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to generate transaction id for Crypto purchase", zap.Error(err))

                return nil, nil, ErrTransactCrypto
        }</span>

        <span class="cov7" title="7">err = p.Query.cryptoPurchase(ctx, &amp;cryptoPurchaseParams{
                TransactionID:      txID,
                ClientID:           clientID,
                FiatCurrency:       fiatCurrency,
                CryptoTicker:       cryptoTicker,
                FiatDebitAmount:    fiatDebitAmount,
                CryptoCreditAmount: cryptoCreditAmount,
        })
        if err != nil </span><span class="cov4" title="3">{
                return nil, nil, ErrTransactCrypto
        }</span>

        <span class="cov5" title="4">fiatJournal, err := p.Query.fiatGetJournalTransaction(ctx, &amp;fiatGetJournalTransactionParams{
                ClientID: clientID,
                TxID:     txID,
        })
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to retrieve Fiat transaction details post Crypto purchase", zap.Error(err))

                return nil, nil, ErrTransactCryptoDetails
        }</span>

        <span class="cov5" title="4">cryptoJournal, err := p.Query.cryptoGetJournalTransaction(ctx, &amp;cryptoGetJournalTransactionParams{
                ClientID: clientID,
                TxID:     txID,
        })
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to retrieve Crypto transaction details post Crypto purchase", zap.Error(err))

                return nil, nil, ErrTransactCryptoDetails
        }</span>

        <span class="cov5" title="4">return &amp;fiatJournal[0], &amp;cryptoJournal[0], nil</span>
}

// CryptoSell is the interface through which external methods can sell a specific Cryptocurrency.
//
//nolint:dupl
func (p *postgresImpl) CryptoSell(
        clientID uuid.UUID,
        fiatCurrency Currency,
        fiatCreditAmount decimal.Decimal,
        cryptoTicker string,
        cryptoDebitAmount decimal.Decimal) (*FiatJournal, *CryptoJournal, error) <span class="cov6" title="5">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        txID, err := uuid.NewV4()
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to generate transaction id for Crypto sale", zap.Error(err))

                return nil, nil, ErrTransactCrypto
        }</span>

        <span class="cov6" title="5">err = p.Query.cryptoSell(ctx, &amp;cryptoSellParams{
                TransactionID:     txID,
                ClientID:          clientID,
                FiatCurrency:      fiatCurrency,
                CryptoTicker:      cryptoTicker,
                FiatCreditAmount:  fiatCreditAmount,
                CryptoDebitAmount: cryptoDebitAmount,
        })
        if err != nil </span><span class="cov4" title="3">{
                return nil, nil, ErrTransactCrypto
        }</span>

        <span class="cov3" title="2">fiatJournal, err := p.Query.fiatGetJournalTransaction(ctx, &amp;fiatGetJournalTransactionParams{
                ClientID: clientID,
                TxID:     txID,
        })
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to retrieve Fiat transaction details post Crypto sale", zap.Error(err))

                return nil, nil, ErrTransactCryptoDetails
        }</span>

        <span class="cov3" title="2">cryptoJournal, err := p.Query.cryptoGetJournalTransaction(ctx, &amp;cryptoGetJournalTransactionParams{
                ClientID: clientID,
                TxID:     txID,
        })
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to retrieve Crypto transaction details post Crypto sale", zap.Error(err))

                return nil, nil, ErrTransactCryptoDetails
        }</span>

        <span class="cov3" title="2">return &amp;fiatJournal[0], &amp;cryptoJournal[0], nil</span>
}

// CryptoBalancesPaginated is the interface through which external methods can retrieve all Crypto account balances for
// a specific client.
func (p *postgresImpl) CryptoBalancesPaginated(clientID uuid.UUID, ticker string, limit int32) (
        []CryptoAccount, error) <span class="cov8" title="9">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        balance, err := p.Query.cryptoGetAllAccounts(ctx, &amp;cryptoGetAllAccountsParams{
                ClientID: clientID,
                Ticker:   ticker,
                Limit:    limit,
        })
        if err != nil </span><span class="cov0" title="0">{
                return []CryptoAccount{}, ErrNotFound
        }</span>

        <span class="cov8" title="9">return balance, nil</span>
}

// CryptoTransactionsPaginated is the interface through which external methods can retrieve transactions on a Crypto
// account for a specific client during a specific month.
func (p *postgresImpl) CryptoTransactionsPaginated(
        clientID uuid.UUID,
        ticker string,
        limit,
        offset int32,
        startTime,
        endTime pgtype.Timestamptz) ([]CryptoJournal, error) <span class="cov8" title="8">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        balance, err := p.Query.cryptoGetAllJournalTransactionsPaginated(ctx, &amp;cryptoGetAllJournalTransactionsPaginatedParams{
                ClientID:  clientID,
                Ticker:    ticker,
                Offset:    offset,
                Limit:     limit,
                StartTime: startTime,
                EndTime:   endTime,
        })
        if err != nil </span><span class="cov0" title="0">{
                return []CryptoJournal{}, ErrNotFound
        }</span>

        <span class="cov8" title="8">return balance, nil</span>
}
</pre>

		<pre class="file" id="file35" style="display: none">package postgres

import (
        "context"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/surahman/FTeX/pkg/constants"
        "go.uber.org/zap"
)

// FiatCreateAccount is the interface through which external methods can create a Fiat account.
func (p *postgresImpl) FiatCreateAccount(clientID uuid.UUID, currency Currency) error <span class="cov4" title="3">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        rowsAffected, err := p.Query.fiatCreateAccount(ctx, &amp;fiatCreateAccountParams{ClientID: clientID, Currency: currency})
        if err != nil || rowsAffected != int64(1) </span><span class="cov3" title="2">{
                p.logger.Error("failed to create fiat account", zap.Error(err))

                return ErrCreateFiat
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FiatBalance is the interface through which external methods can retrieve a Fiat-account balance for a specific
// currency.
func (p *postgresImpl) FiatBalance(clientID uuid.UUID, currency Currency) (FiatAccount, error) <span class="cov7" title="6">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        balance, err := p.Query.fiatGetAccount(ctx, &amp;fiatGetAccountParams{ClientID: clientID, Currency: currency})
        if err != nil </span><span class="cov1" title="1">{
                return FiatAccount{}, ErrNotFound
        }</span>

        <span class="cov6" title="5">return balance, nil</span>
}

// FiatTxDetails is the interface through which external methods can retrieve a Fiat transaction details for a specific
// transaction.
func (p *postgresImpl) FiatTxDetails(clientID uuid.UUID, transactionID uuid.UUID) ([]FiatJournal, error) <span class="cov10" title="14">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        journal, err := p.Query.fiatGetJournalTransaction(ctx, &amp;fiatGetJournalTransactionParams{clientID, transactionID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>

        <span class="cov10" title="14">return journal, nil</span>
}

// FiatBalancePaginated is the interface through which external methods can retrieve all Fiat account balances for a
// specific client.
func (p *postgresImpl) FiatBalancePaginated(clientID uuid.UUID, baseCurrency Currency, limit int32) (
        []FiatAccount, error) <span class="cov8" title="9">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        balance, err := p.Query.fiatGetAllAccounts(ctx, &amp;fiatGetAllAccountsParams{
                ClientID: clientID,
                Currency: baseCurrency,
                Limit:    limit,
        })
        if err != nil </span><span class="cov0" title="0">{
                return []FiatAccount{}, ErrNotFound
        }</span>

        <span class="cov8" title="9">return balance, nil</span>
}

// FiatTransactionsPaginated is the interface through which external methods can retrieve transactions on a Fiat
// account for a specific client during a specific month.
func (p *postgresImpl) FiatTransactionsPaginated(
        clientID uuid.UUID,
        currency Currency,
        limit,
        offset int32,
        startTime,
        endTime pgtype.Timestamptz) ([]FiatJournal, error) <span class="cov8" title="8">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        balance, err := p.Query.fiatGetAllJournalTransactionsPaginated(ctx, &amp;fiatGetAllJournalTransactionsPaginatedParams{
                ClientID:  clientID,
                Currency:  currency,
                Offset:    offset,
                Limit:     limit,
                StartTime: startTime,
                EndTime:   endTime,
        })
        if err != nil </span><span class="cov0" title="0">{
                return []FiatJournal{}, ErrNotFound
        }</span>

        <span class="cov8" title="8">return balance, nil</span>
}
</pre>

		<pre class="file" id="file36" style="display: none">package postgres

import (
        "context"

        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/constants"
        modelsPostgres "github.com/surahman/FTeX/pkg/models/postgres"
        "go.uber.org/zap"
)

// UserRegister is the interface through which external methods can create a user.
func (p *postgresImpl) UserRegister(userDetails *modelsPostgres.UserAccount) (uuid.UUID, error) <span class="cov3" title="2">{
        params := userCreateParams{
                Username:  userDetails.Username,
                Password:  userDetails.Password,
                FirstName: userDetails.FirstName,
                LastName:  userDetails.LastName,
                Email:     userDetails.Email,
        }

        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        clientID, err := p.Query.userCreate(ctx, &amp;params)
        if err != nil </span><span class="cov1" title="1">{
                p.logger.Error("failed to register user", zap.Error(err))

                return uuid.UUID{}, ErrRegisterUser
        }</span>

        <span class="cov1" title="1">return clientID, nil</span>
}

// UserCredentials is the interface through which external methods can retrieve user credentials.
func (p *postgresImpl) UserCredentials(username string) (uuid.UUID, string, error) <span class="cov5" title="3">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        credentials, err := p.Query.userGetCredentials(ctx, username)
        if err != nil </span><span class="cov3" title="2">{
                p.logger.Error("failed to retrieve user account credentials", zap.Error(err))

                return uuid.UUID{}, "", ErrLoginUser
        }</span>

        <span class="cov1" title="1">return credentials.ClientID, credentials.Password, nil</span>
}

// UserGetInfo is the interface through which external methods can retrieve user account information.
func (p *postgresImpl) UserGetInfo(clientID uuid.UUID) (modelsPostgres.User, error) <span class="cov3" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        userAccount, err := p.Query.userGetInfo(ctx, clientID)
        if err != nil </span><span class="cov1" title="1">{
                p.logger.Error("failed to retrieve user account info", zap.Error(err))

                return modelsPostgres.User{}, ErrNotFoundUser
        }</span>

        <span class="cov1" title="1">return modelsPostgres.User{
                        UserAccount: &amp;modelsPostgres.UserAccount{
                                UserLoginCredentials: modelsPostgres.UserLoginCredentials{
                                        Username: userAccount.Username,
                                        Password: userAccount.Password,
                                },
                                FirstName: userAccount.FirstName,
                                LastName:  userAccount.LastName,
                                Email:     userAccount.Email,
                        },
                        ClientID:  userAccount.ClientID,
                        IsDeleted: userAccount.IsDeleted,
                },
                nil</span>
}

// UserDelete is the interface through which external methods can soft-delete a user account.
func (p *postgresImpl) UserDelete(clientID uuid.UUID) error <span class="cov6" title="4">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        rowsAffected, err := p.Query.userDelete(ctx, clientID)
        if err != nil || rowsAffected != int64(1) </span><span class="cov0" title="0">{
                p.logger.Error("failed to delete user", zap.Error(err))

                return ErrNotFoundUser
        }</span>

        <span class="cov6" title="4">return nil</span>
}

// UserIsDeleted is the interface through which external methods can check if a user account is soft-deleted.
func (p *postgresImpl) UserIsDeleted(clientID uuid.UUID) (bool, error) <span class="cov10" title="9">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        isDeleted, err := p.Query.userIsDeleted(ctx, clientID)
        if err != nil </span><span class="cov1" title="1">{
                p.logger.Error("failed to check deletion status of user", zap.Error(err))

                return false, ErrNotFound
        }</span>

        <span class="cov9" title="8">return isDeleted, nil</span>
}
</pre>

		<pre class="file" id="file37" style="display: none">package postgres

import (
        "fmt"

        "github.com/gofrs/uuid"
        "github.com/shopspring/decimal"
)

// configTestData will return a map of test data containing valid and invalid Postgres configs.
func configTestData() map[string]string <span class="cov1" title="1">{
        return map[string]string{
                "empty": ``,

                "test_suite": `
authentication:
  username: postgres
  password: postgres
connection:
  database: ftex_db_test
  host: 127.0.0.1
  maxConnectionAttempts: 1
  port: 6432
  timeout: 5
pool:
  healthCheckPeriod: 30s
  maxConns: 4
  minConns: 4`,

                "github-ci-runner": `
authentication:
  username: postgres
  password: postgres
connection:
  database: ftex_db_test
  maxConnectionAttempts: 3
  host: 127.0.0.1
  port: 5432
  timeout: 5
pool:
  healthCheckPeriod: 30s
  maxConns: 8
  minConns: 4`,

                "valid": `
authentication:
  username: postgres
  password: postgres
connection:
  database: ftex_db
  host: 127.0.0.1
  maxConnectionAttempts: 5
  port: 6432
  timeout: 5
pool:
  healthCheckPeriod: 30s
  maxConns: 8
  minConns: 4`,

                "bad_health_check": `
authentication:
  username: postgres
  password: postgres
connection:
  database: ftex_db
  host: 127.0.0.1
  maxConnectionAttempts: 5
  port: 6432
  timeout: 5
pool:
  healthCheckPeriod: 3s
  maxConns: 8
  minConns: 4`,

                "invalid_conns": `
authentication:
  username: postgres
  password: postgres
connection:
  database: ftex_db
  host: 127.0.0.1
  maxConnectionAttempts: 5
  port: 6432
  timeout: 5
pool:
  healthCheckPeriod: 30s
  maxConns: 2
  minConns: 2`,

                "invalid_max_conn_attempts": `
authentication:
  username: postgres
  password: postgres
connection:
  database: ftex_db
  host: 127.0.0.1
  maxConnectionAttempts: 0
  port: 6432
  timeout: 5
pool:
  healthCheckPeriod: 30s
  maxConns: 8
  minConns: 4`,

                "invalid_timeout": `
authentication:
  username: postgres
  password: postgres
connection:
  database: ftex_db
  host: 127.0.0.1
  maxConnectionAttempts: 5
  port: 6432
  timeout: 2
pool:
  healthCheckPeriod: 30s
  maxConns: 8
  minConns: 4`,
        }
}</span>

// getTestUsers will generate a number of test users for testing.
func getTestUsers() map[string]userCreateParams <span class="cov7" title="43">{
        users := make(map[string]userCreateParams)
        username := "username%d"
        password := "user-password-%d"
        firstname := "firstname-%d"
        lastname := "lastname-%d"
        email := "user%d@email-address.com"

        for idx := 1; idx &lt; 5; idx++ </span><span class="cov10" title="172">{
                uname := fmt.Sprintf(username, idx)
                users[uname] = userCreateParams{
                        Username:  fmt.Sprintf(username, idx),
                        Password:  fmt.Sprintf(password, idx),
                        FirstName: fmt.Sprintf(firstname, idx),
                        LastName:  fmt.Sprintf(lastname, idx),
                        Email:     fmt.Sprintf(email, idx),
                }
        }</span>

        <span class="cov7" title="43">return users</span>
}

// getTestFiatAccounts generates a number of test fiat accounts.
func getTestFiatAccounts(clientID1, clientID2 uuid.UUID) map[string][]fiatCreateAccountParams <span class="cov6" title="27">{
        return map[string][]fiatCreateAccountParams{
                "clientID1": {
                        {
                                ClientID: clientID1,
                                Currency: CurrencyAED,
                        }, {
                                ClientID: clientID1,
                                Currency: CurrencyUSD,
                        }, {
                                ClientID: clientID1,
                                Currency: CurrencyCAD,
                        },
                },
                "clientID2": {
                        {
                                ClientID: clientID2,
                                Currency: CurrencyAED,
                        }, {
                                ClientID: clientID2,
                                Currency: CurrencyUSD,
                        }, {
                                ClientID: clientID2,
                                Currency: CurrencyCAD,
                        },
                },
        }
}</span>

// getTestJournalInternalFiatAccounts generates a number of test fiat internal transfer journal entries.
func getTestJournalInternalFiatAccounts(
        clientID1,
        clientID2 uuid.UUID) map[string]fiatInternalTransferJournalEntryParams <span class="cov2" title="2">{
        return map[string]fiatInternalTransferJournalEntryParams{
                "CAD-AED": {
                        SourceAccount:       clientID1,
                        SourceCurrency:      CurrencyCAD,
                        DestinationAccount:  clientID2,
                        DestinationCurrency: CurrencyAED,
                        CreditAmount:        decimal.NewFromFloat(123.45),
                        DebitAmount:         decimal.NewFromFloat(-123.45),
                },
                "CAD-USD": {
                        SourceAccount:       clientID1,
                        SourceCurrency:      CurrencyCAD,
                        DestinationAccount:  clientID2,
                        DestinationCurrency: CurrencyUSD,
                        CreditAmount:        decimal.NewFromFloat(4567.89),
                        DebitAmount:         decimal.NewFromFloat(-4567.89),
                },
                "USD-AED": {
                        SourceAccount:       clientID1,
                        SourceCurrency:      CurrencyUSD,
                        DestinationAccount:  clientID2,
                        DestinationCurrency: CurrencyAED,
                        CreditAmount:        decimal.NewFromFloat(9192.24),
                        DebitAmount:         decimal.NewFromFloat(-9192.24),
                },
        }
}</span>

// getTestFiatJournal generates a number of test general ledger entry parameters.
func getTestFiatJournal(clientID1, clientID2 uuid.UUID) map[string]fiatExternalTransferJournalEntryParams <span class="cov6" title="20">{
        // Create balance amounts.
        var (
                amount1 = decimal.NewFromFloat(1024.55)
                amount2 = decimal.NewFromFloat(4096.89)
                amount3 = decimal.NewFromFloat(256.44)
        )

        return map[string]fiatExternalTransferJournalEntryParams{
                "Client ID 1 - USD": {
                        ClientID: clientID1,
                        Currency: CurrencyUSD,
                        Amount:   amount1,
                },
                "Client ID 1 - AED": {
                        ClientID: clientID1,
                        Currency: CurrencyAED,
                        Amount:   amount2,
                },
                "Client ID 1 - CAD": {
                        ClientID: clientID1,
                        Currency: CurrencyCAD,
                        Amount:   amount3,
                },
                "Client ID 2 - USD": {
                        ClientID: clientID2,
                        Currency: CurrencyUSD,
                        Amount:   amount2,
                },
                "Client ID 2 - AED": {
                        ClientID: clientID2,
                        Currency: CurrencyAED,
                        Amount:   amount3,
                },
                "Client ID 2 - CAD": {
                        ClientID: clientID2,
                        Currency: CurrencyCAD,
                        Amount:   amount1,
                },
        }
}</span>

// getTestCryptoAccounts generates a number of test crypto accounts.
func getTestCryptoAccounts(clientID1, clientID2 uuid.UUID) map[string][]cryptoCreateAccountParams <span class="cov5" title="12">{
        return map[string][]cryptoCreateAccountParams{
                "clientID1": {
                        {
                                ClientID: clientID1,
                                Ticker:   "BTC",
                        }, {
                                ClientID: clientID1,
                                Ticker:   "ETH",
                        }, {
                                ClientID: clientID1,
                                Ticker:   "USDT",
                        },
                },
                "clientID2": {
                        {
                                ClientID: clientID2,
                                Ticker:   "BTC",
                        }, {
                                ClientID: clientID2,
                                Ticker:   "ETH",
                        }, {
                                ClientID: clientID2,
                                Ticker:   "USDT",
                        },
                },
        }
}</span>

// getTestCryptoPurchaseParams generates a number of test crypto purchase requests.
func getTestCryptoPurchaseParams(clientID1, clientID2 uuid.UUID) map[string][]cryptoPurchaseParams <span class="cov2" title="2">{
        var (
                amount1 = decimal.NewFromFloat(1024.55)
                amount2 = decimal.NewFromFloat(4096.89)
                amount3 = decimal.NewFromFloat(256.44)
        )

        return map[string][]cryptoPurchaseParams{
                "clientID1": {
                        {
                                TransactionID:      uuid.UUID{},
                                ClientID:           clientID1,
                                FiatCurrency:       CurrencyUSD,
                                CryptoTicker:       "BTC",
                                FiatDebitAmount:    amount1,
                                CryptoCreditAmount: amount3,
                        }, {
                                TransactionID:      uuid.UUID{},
                                ClientID:           clientID1,
                                FiatCurrency:       CurrencyUSD,
                                CryptoTicker:       "ETH",
                                FiatDebitAmount:    amount3,
                                CryptoCreditAmount: amount2,
                        }, {
                                TransactionID:      uuid.UUID{},
                                ClientID:           clientID1,
                                FiatCurrency:       CurrencyUSD,
                                CryptoTicker:       "USDT",
                                FiatDebitAmount:    amount2,
                                CryptoCreditAmount: amount1,
                        },
                },
                "clientID2": {
                        {
                                TransactionID:      uuid.UUID{},
                                ClientID:           clientID2,
                                FiatCurrency:       CurrencyUSD,
                                CryptoTicker:       "BTC",
                                FiatDebitAmount:    amount1,
                                CryptoCreditAmount: amount2,
                        }, {
                                TransactionID:      uuid.UUID{},
                                ClientID:           clientID2,
                                FiatCurrency:       CurrencyUSD,
                                CryptoTicker:       "ETH",
                                FiatDebitAmount:    amount2,
                                CryptoCreditAmount: amount3,
                        }, {
                                TransactionID:      uuid.UUID{},
                                ClientID:           clientID2,
                                FiatCurrency:       CurrencyUSD,
                                CryptoTicker:       "USDT",
                                FiatDebitAmount:    amount3,
                                CryptoCreditAmount: amount1,
                        },
                },
        }
}</span>
</pre>

		<pre class="file" id="file38" style="display: none">package postgres

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/gofrs/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/shopspring/decimal"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "go.uber.org/zap"
)

type FiatTransactionDetails struct {
        ClientID uuid.UUID       `json:"clientId"`
        Currency Currency        `json:"currency"`
        Amount   decimal.Decimal `json:"amount"`
}

// Less returns a total ordering on two FiatTransactionDetails structs.
/*        IF
 [1]         LHS UUID is equal to the RHS UUID
                AND
                LHS Currency is greater than the RHS Currency
 [2]         OR
                LHS UUID is greater than the RHS UUID
        RETURN RHS and LHS
                ELSE
        RETURN LHS and RHS
*/
func (lhs *FiatTransactionDetails) Less(rhs *FiatTransactionDetails) (
        **FiatTransactionDetails, **FiatTransactionDetails) <span class="cov10" title="33">{
        compare := bytes.Compare(lhs.ClientID.Bytes(), rhs.ClientID.Bytes())

        if (compare == 0 &amp;&amp; lhs.Currency &gt; rhs.Currency) || compare &gt; 0 </span><span class="cov7" title="12">{
                return &amp;rhs, &amp;lhs
        }</span>

        <span class="cov8" title="21">return &amp;lhs, &amp;rhs</span>
}

type FiatAccountTransferResult struct {
        TxID     uuid.UUID          `json:"txId"`
        ClientID uuid.UUID          `json:"clientId"`
        TxTS     pgtype.Timestamptz `json:"txTimestamp"`
        Balance  decimal.Decimal    `json:"balance"`
        LastTx   decimal.Decimal    `json:"lastTx"`
        Currency Currency           `json:"currency"`
}

// FiatExternalTransfer controls the transaction block that the external Fiat transfer transaction executes in.
func (p *postgresImpl) FiatExternalTransfer(parentCtx context.Context, xferDetails *FiatTransactionDetails) (
        *FiatAccountTransferResult, error) <span class="cov6" title="9">{
        ctx, cancel := context.WithTimeout(parentCtx, constants.ThreeSeconds())

        defer cancel()

        var (
                err       error
                tx        pgx.Tx
                txReceipt *FiatAccountTransferResult
        )

        // Begin transaction.
        if tx, err = p.pool.Begin(ctx); err != nil </span><span class="cov0" title="0">{
                p.logger.Warn("external transfer Fiat transaction block setup failed", zap.Error(err))

                return nil, ErrTransactFiat
        }</span>

        // Set rollback in case of failure.
        <span class="cov6" title="9">defer func() </span><span class="cov6" title="9">{
                if errRollback := tx.Rollback(context.TODO()); errRollback != nil </span><span class="cov6" title="8">{
                        // If the connection is closed, the transaction was committed. Ignore the error from rollback in this case.
                        if !errors.Is(errRollback, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                p.logger.Error("failed to rollback external Fiat account transaction", zap.Error(errRollback))
                        }</span>
                }
        }()

        // Configure transaction query connection.
        <span class="cov6" title="9">queryTx := p.queries.WithTx(tx)

        // Handoff to external fiat transaction core logic.
        if txReceipt, err = fiatExternalTransfer(ctx, p.logger, queryTx, xferDetails); err != nil </span><span class="cov1" title="1">{
                p.logger.Warn("failed to complete external Fiat transfer transaction", zap.Error(err))

                return nil, ErrTransactFiat
        }</span>

        // Commit transaction.
        <span class="cov6" title="8">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                p.logger.Warn("failed to commit external Fiat account transfer", zap.Error(err))

                return nil, ErrTransactFiat
        }</span>

        <span class="cov6" title="8">return txReceipt, nil</span>
}

// fiatExternalTransfer will execute the logic to complete the external Fiat transfer transaction.
/*
                  Minimize the duration for which the transaction block will be active by performing as many operations as
                   possible outside the transaction.

        The queries to update the balance will round Half-to-Even to account for floating point precision
        representational issues.

    [1] Acquire a row lock on the destination account without holding a lock on the foreign key for the Client ID.
        There will be no update for the external account balance, so there is no need for a row lock on the account.
    [2] Make the Journal entries for the external and internal accounts.
    [3] Update the balance for the internal account.
*/
func fiatExternalTransfer(
        ctx context.Context,
        logger *logger.Logger,
        queryTx Querier,
        xferDetails *FiatTransactionDetails) (*FiatAccountTransferResult, error) <span class="cov7" title="12">{
        var (
                err        error
                journalRow fiatExternalTransferJournalEntryRow
                updateRow  fiatUpdateAccountBalanceRow
        )

        // Row lock the destination account.
        if _, err = queryTx.fiatRowLockAccount(ctx, &amp;fiatRowLockAccountParams{
                ClientID: xferDetails.ClientID,
                Currency: xferDetails.Currency,
        }); err != nil </span><span class="cov2" title="2">{
                msg := "failed to get row lock on destination Fiat account"
                logger.Warn(msg, zap.Error(err))

                return nil, fmt.Errorf(msg+" %w", err)
        }</span>

        // Make General Journal ledger entries.
        <span class="cov6" title="10">if journalRow, err = queryTx.fiatExternalTransferJournalEntry(ctx, &amp;fiatExternalTransferJournalEntryParams{
                ClientID: xferDetails.ClientID,
                Currency: xferDetails.Currency,
                Amount:   xferDetails.Amount,
        }); err != nil </span><span class="cov1" title="1">{
                msg := "failed to post Fiat account Journal entries"
                logger.Warn(msg, zap.Error(err))

                return nil, fmt.Errorf(msg+" %w", err)
        }</span>

        // Update the account balance.
        <span class="cov6" title="9">if updateRow, err = queryTx.fiatUpdateAccountBalance(ctx, &amp;fiatUpdateAccountBalanceParams{
                ClientID: xferDetails.ClientID,
                Currency: xferDetails.Currency,
                Amount:   xferDetails.Amount,
                LastTxTs: journalRow.TransactedAt,
        }); err != nil </span><span class="cov1" title="1">{
                msg := "failed to update Fiat account balance"
                logger.Warn(msg, zap.Error(err))

                return nil, fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov6" title="8">return &amp;FiatAccountTransferResult{
                        TxID:     journalRow.TxID,
                        ClientID: xferDetails.ClientID,
                        TxTS:     journalRow.TransactedAt,
                        Balance:  updateRow.Balance,
                        LastTx:   updateRow.LastTx,
                        Currency: xferDetails.Currency,
                },
                nil</span>
}

// fiatTransactionRowLockAndBalanceCheck will acquire row locks on the Fiat accounts in a deterministic lock order.
// It will then check to see if the balance of the source/debit account is sufficient for the transaction.
func fiatTransactionRowLockAndBalanceCheck(
        ctx context.Context,
        queryTx Querier,
        src,
        dst *FiatTransactionDetails) error <span class="cov9" title="24">{
        // Check for negative values.
        if src.Amount.IsNegative() || dst.Amount.IsNegative() </span><span class="cov2" title="2">{
                return fmt.Errorf("amounts contains negative value")
        }</span>

        // Order locks.
        <span class="cov8" title="22">lockFirst, lockSecond := src.Less(dst)

        // Row lock the accounts in order.
        balanceFirst, err := queryTx.fiatRowLockAccount(ctx, &amp;fiatRowLockAccountParams{
                ClientID: (*lockFirst).ClientID,
                Currency: (*lockFirst).Currency,
        })
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("failed to get row lock on first Fiat account %w", err)
        }</span>

        <span class="cov8" title="20">balanceSecond, err := queryTx.fiatRowLockAccount(ctx, &amp;fiatRowLockAccountParams{
                ClientID: (*lockSecond).ClientID,
                Currency: (*lockSecond).Currency,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get row lock on second Fiat account %w", err)
        }</span>

        // Check which lock operation returned the source/debit balance.
        <span class="cov8" title="19">debitBalance := &amp;balanceFirst
        if *lockSecond == src </span><span class="cov6" title="10">{
                debitBalance = &amp;balanceSecond
        }</span>

        // Check for sufficient funds.
        <span class="cov8" title="19">if debitBalance.LessThan(src.Amount) </span><span class="cov4" title="4">{
                return fmt.Errorf("insufficient balance in source account: %s, %s", debitBalance, src.Amount)
        }</span>

        <span class="cov7" title="15">return nil</span>
}

// FiatInternalTransfer controls the transaction block that the internal Fiat transfer transaction executes in.
func (p *postgresImpl) FiatInternalTransfer(
        parentCtx context.Context,
        src,
        dst *FiatTransactionDetails) (*FiatAccountTransferResult, *FiatAccountTransferResult, error) <span class="cov7" title="11">{
        ctx, cancel := context.WithTimeout(parentCtx, constants.ThreeSeconds())

        defer cancel()

        var (
                err          error
                tx           pgx.Tx
                dstTxReceipt *FiatAccountTransferResult
                srcTxReceipt *FiatAccountTransferResult
        )

        // Begin transaction.
        if tx, err = p.pool.Begin(ctx); err != nil </span><span class="cov0" title="0">{
                msg := "internal transfer Fiat transaction block setup failed"
                p.logger.Warn(msg, zap.Error(err))

                return nil, nil, fmt.Errorf(msg+" %w", err)
        }</span>

        // Set rollback in case of failure.
        <span class="cov7" title="11">defer func() </span><span class="cov7" title="11">{
                if errRollback := tx.Rollback(context.TODO()); errRollback != nil </span><span class="cov6" title="10">{
                        // If the connection is closed, the transaction was committed. Ignore the error from rollback in this case.
                        if !errors.Is(errRollback, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                p.logger.Error("failed to rollback internal Fiat account transaction", zap.Error(errRollback))
                        }</span>
                }
        }()

        // Configure transaction query connection.
        <span class="cov7" title="11">queryTx := p.queries.WithTx(tx)

        // Handoff to internal fiat transaction core logic.
        if srcTxReceipt, dstTxReceipt, err = fiatInternalTransfer(ctx, p.logger, queryTx, src, dst); err != nil </span><span class="cov1" title="1">{
                msg := "failed to complete internal Fiat transfer transaction"
                p.logger.Warn(msg, zap.Error(err))

                return nil, nil, fmt.Errorf(msg+" %w", err)
        }</span>

        // Commit transaction.
        <span class="cov6" title="10">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                msg := "failed to commit internal Fiat account transfer"
                p.logger.Warn(msg, zap.Error(err))

                return nil, nil, fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov6" title="10">return srcTxReceipt, dstTxReceipt, nil</span>
}

// fiatInternalTransfer will execute the logic to complete the internal Fiat transfer transaction.
/*
                  Minimize the duration for which the transaction block will be active by performing as many operations as
                   possible outside the transaction.

        The queries to update the balance will round Half-to-Even to account for floating point precision
        representational issues.

    [1] Acquire a row lock on the accounts without holding a lock on the foreign key for the Client ID.
        Their accounts will be compared against each other using a total order rule.
    [2] Make the Journal entries for both of the accounts.
    [3] Update the balance for the source and destination accounts.
*/
func fiatInternalTransfer(
        ctx context.Context,
        logger *logger.Logger,
        queryTx Querier,
        src,
        dst *FiatTransactionDetails) (*FiatAccountTransferResult, *FiatAccountTransferResult, error) <span class="cov7" title="15">{
        var (
                err           error
                journalRow    fiatInternalTransferJournalEntryRow
                postCreditRow fiatUpdateAccountBalanceRow
                postDebitRow  fiatUpdateAccountBalanceRow
        )

        // Row lock the accounts in order and check balances.
        if err = fiatTransactionRowLockAndBalanceCheck(ctx, queryTx, src, dst); err != nil </span><span class="cov2" title="2">{
                msg := "failed to get row lock on Fiat accounts and verify balance of debit account"
                logger.Warn(msg, zap.Error(err))

                return nil, nil, fmt.Errorf(msg+" %w", err)
        }</span>

        // Make General Journal ledger entries.
        <span class="cov7" title="13">if journalRow, err = queryTx.fiatInternalTransferJournalEntry(ctx, &amp;fiatInternalTransferJournalEntryParams{
                DestinationAccount:  dst.ClientID,
                DestinationCurrency: dst.Currency,
                CreditAmount:        dst.Amount,
                SourceAccount:       src.ClientID,
                SourceCurrency:      src.Currency,
                DebitAmount:         src.Amount,
        }); err != nil </span><span class="cov1" title="1">{
                msg := "failed to post Fiat account Journal entries for internal transfer"
                logger.Warn(msg, zap.Error(err))

                return nil, nil, fmt.Errorf(msg+" %w", err)
        }</span>

        // Update the destination and then source account balances.
        <span class="cov7" title="12">if postCreditRow, err = queryTx.fiatUpdateAccountBalance(ctx, &amp;fiatUpdateAccountBalanceParams{
                ClientID: dst.ClientID,
                Currency: dst.Currency,
                Amount:   dst.Amount,
                LastTxTs: journalRow.TransactedAt,
        }); err != nil </span><span class="cov1" title="1">{
                msg := "failed to credit Fiat account balance for internal transfer"
                logger.Warn(msg, zap.Error(err))

                return nil, nil, fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov7" title="11">if postDebitRow, err = queryTx.fiatUpdateAccountBalance(ctx, &amp;fiatUpdateAccountBalanceParams{
                ClientID: src.ClientID,
                Currency: src.Currency,
                Amount:   src.Amount.Mul(decimal.NewFromFloat(-1.0)),
                LastTxTs: journalRow.TransactedAt,
        }); err != nil </span><span class="cov1" title="1">{
                msg := "failed to debit Fiat account balance for internal transfer"
                logger.Warn(msg, zap.Error(err))

                return nil, nil, fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov6" title="10">return &amp;FiatAccountTransferResult{
                        TxID:     journalRow.TxID,
                        ClientID: src.ClientID,
                        TxTS:     postDebitRow.LastTxTs,
                        Balance:  postDebitRow.Balance,
                        LastTx:   postDebitRow.LastTx,
                        Currency: src.Currency,
                },
                &amp;FiatAccountTransferResult{
                        TxID:     journalRow.TxID,
                        ClientID: dst.ClientID,
                        TxTS:     postCreditRow.LastTxTs,
                        Balance:  postCreditRow.Balance,
                        LastTx:   postCreditRow.LastTx,
                        Currency: dst.Currency,
                },
                nil</span>
}
</pre>

		<pre class="file" id="file39" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: udf.sql

package postgres

import (
        "context"

        "github.com/shopspring/decimal"
)

const testRoundHalfEven = `-- name: testRoundHalfEven :one
SELECT round_half_even($1, $2)
`

type testRoundHalfEvenParams struct {
        Num   decimal.Decimal `json:"num"`
        Scale int32           `json:"scale"`
}

// testRoundHalfEven
func (q *Queries) testRoundHalfEven(ctx context.Context, arg *testRoundHalfEvenParams) (decimal.Decimal, error) <span class="cov10" title="11">{
        row := q.db.QueryRow(ctx, testRoundHalfEven, arg.Num, arg.Scale)
        var round_half_even decimal.Decimal
        err := row.Scan(&amp;round_half_even)
        return round_half_even, err
}</span>
</pre>

		<pre class="file" id="file40" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package postgres

import (
        "context"

        "github.com/gofrs/uuid"
)

const userCreate = `-- name: userCreate :one
INSERT INTO users (username, password, first_name, last_name, email)
VALUES ($1, $2, $3, $4, $5)
RETURNING client_id
`

type userCreateParams struct {
        Username  string `json:"username"`
        Password  string `json:"password"`
        FirstName string `json:"firstName"`
        LastName  string `json:"lastName"`
        Email     string `json:"email"`
}

// userCreate will create a new user record.
func (q *Queries) userCreate(ctx context.Context, arg *userCreateParams) (uuid.UUID, error) <span class="cov10" title="159">{
        row := q.db.QueryRow(ctx, userCreate,
                arg.Username,
                arg.Password,
                arg.FirstName,
                arg.LastName,
                arg.Email,
        )
        var client_id uuid.UUID
        err := row.Scan(&amp;client_id)
        return client_id, err
}</span>

const userDelete = `-- name: userDelete :execrows
UPDATE users
SET is_deleted=true
WHERE client_id=$1 AND is_deleted=false
`

// userDelete will soft delete a users account.
func (q *Queries) userDelete(ctx context.Context, clientID uuid.UUID) (int64, error) <span class="cov5" title="14">{
        result, err := q.db.Exec(ctx, userDelete, clientID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov5" title="14">return result.RowsAffected(), nil</span>
}

const userGetClientId = `-- name: userGetClientId :one
SELECT client_id
FROM users
WHERE username=$1
LIMIT 1
`

// userGetClientId will retrieve a users client id.
func (q *Queries) userGetClientId(ctx context.Context, username string) (uuid.UUID, error) <span class="cov8" title="63">{
        row := q.db.QueryRow(ctx, userGetClientId, username)
        var client_id uuid.UUID
        err := row.Scan(&amp;client_id)
        return client_id, err
}</span>

const userGetCredentials = `-- name: userGetCredentials :one
SELECT client_id, password
FROM users
WHERE username=$1 AND is_deleted=false
LIMIT 1
`

type userGetCredentialsRow struct {
        ClientID uuid.UUID `json:"clientID"`
        Password string    `json:"password"`
}

// userGetCredentials will retrieve a users client id and password.
func (q *Queries) userGetCredentials(ctx context.Context, username string) (userGetCredentialsRow, error) <span class="cov4" title="8">{
        row := q.db.QueryRow(ctx, userGetCredentials, username)
        var i userGetCredentialsRow
        err := row.Scan(&amp;i.ClientID, &amp;i.Password)
        return i, err
}</span>

const userGetInfo = `-- name: userGetInfo :one
SELECT username, client_id, password, first_name, last_name, email, is_deleted
FROM users
WHERE client_id=$1
LIMIT 1
`

type userGetInfoRow struct {
        Username  string    `json:"username"`
        ClientID  uuid.UUID `json:"clientID"`
        Password  string    `json:"password"`
        FirstName string    `json:"firstName"`
        LastName  string    `json:"lastName"`
        Email     string    `json:"email"`
        IsDeleted bool      `json:"isDeleted"`
}

// userGetInfo will retrieve a single users account information.
func (q *Queries) userGetInfo(ctx context.Context, clientID uuid.UUID) (userGetInfoRow, error) <span class="cov4" title="7">{
        row := q.db.QueryRow(ctx, userGetInfo, clientID)
        var i userGetInfoRow
        err := row.Scan(
                &amp;i.Username,
                &amp;i.ClientID,
                &amp;i.Password,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Email,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const userIsDeleted = `-- name: userIsDeleted :one
SELECT is_deleted
FROM users
WHERE client_id=$1
LIMIT 1
`

// userIsDeleted will return the soft delete status of a user account.
func (q *Queries) userIsDeleted(ctx context.Context, clientID uuid.UUID) (bool, error) <span class="cov6" title="18">{
        row := q.db.QueryRow(ctx, userIsDeleted, clientID)
        var is_deleted bool
        err := row.Scan(&amp;is_deleted)
        return is_deleted, err
}</span>
</pre>

		<pre class="file" id="file41" style="display: none">package quotes

import (
        "fmt"
        "time"

        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/configloader"
        "github.com/surahman/FTeX/pkg/constants"
)

// config is the configuration container for connecting to external Quotes services.
//
//nolint:lll
type config struct {
        FiatCurrency   apiConfig        `json:"fiatCurrency,omitempty"   mapstructure:"fiatCurrency"   validate:"required"         yaml:"fiatCurrency,omitempty"`
        CryptoCurrency apiConfig        `json:"cryptoCurrency,omitempty" mapstructure:"cryptoCurrency" validate:"required"         yaml:"cryptoCurrency,omitempty"`
        Connection     connectionConfig `json:"connection,omitempty"     mapstructure:"connection"     yaml:"connection,omitempty"`
}

// apiConfig contains the API Key and URL information for a currency exchange endpoint.
type apiConfig struct {
        APIKey    string `json:"apiKey,omitempty"    mapstructure:"apiKey"    validate:"required" yaml:"apiKey,omitempty"`
        HeaderKey string `json:"headerKey,omitempty" mapstructure:"headerKey" validate:"required" yaml:"headerKey,omitempty"`
        Endpoint  string `json:"endpoint,omitempty"  mapstructure:"endpoint"  validate:"required" yaml:"endpoint,omitempty"`
}

// connectionConfig contains HTTP connection attempt information.
//
//nolint:lll
type connectionConfig struct {
        UserAgent string        `json:"userAgent,omitempty" mapstructure:"userAgent" validate:"required" yaml:"userAgent,omitempty"`
        Timeout   time.Duration `json:"timeout,omitempty"   mapstructure:"timeout"   validate:"required" yaml:"timeout,omitempty"`
}

// newConfig creates a blank configuration struct for Redis.
func newConfig() *config <span class="cov4" title="3">{
        return &amp;config{}
}</span>

// Load will attempt to load configurations from a file on a file system.
func (cfg *config) Load(fs afero.Fs) (err error) <span class="cov10" title="17">{
        if err := configloader.Load(
                fs,
                cfg,
                constants.QuotesFileName(),
                constants.QuotesPrefix(),
                "yaml"); err != nil </span><span class="cov9" title="13">{
                return fmt.Errorf("quotes config loading failed: %w", err)
        }</span>

        <span class="cov5" title="4">return nil</span>
}
</pre>

		<pre class="file" id="file42" style="display: none">package quotes

import "errors"

// Error is the base error type. The builder pattern is used to add specialization codes to the errors.
type Error struct {
        Message string
        Code    int
}

// Check to ensure the error interface is implemented.
var _ error = &amp;Error{}

// Error get human readable error message.
func (e *Error) Error() string <span class="cov6" title="4">{
        return e.Message
}</span>

// Is will return whether the input err is an instance of expected error.
func (e *Error) Is(err error) bool <span class="cov7" title="5">{
        var target *Error
        if !errors.As(err, &amp;target) </span><span class="cov5" title="3">{
                return false
        }</span>

        <span class="cov3" title="2">return e.Code == target.Code</span>
}

// NewError is a base error message with no special code.
func NewError(message string) *Error <span class="cov10" title="9">{
        return &amp;Error{Message: message, Code: 0}
}</span>

// SetStatus configures the error status/code.
func (e *Error) SetStatus(status int) *Error <span class="cov7" title="5">{
        e.Code = status

        return e
}</span>
</pre>

		<pre class="file" id="file43" style="display: none">package quotes

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/imroc/req/v3"
        "github.com/shopspring/decimal"
        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "go.uber.org/zap"
)

// Mock Quotes interface stub generation. This is local to the Quotes package.
//go:generate mockgen -destination=quotes_mocks.go -package=quotes github.com/surahman/FTeX/pkg/quotes Quotes

// Quotes is the interface through which the currency quote services can be accessed. Created to support mock testing.
type Quotes interface {
        // fiatQuote will retrieve a quote for a Fiat currency price.
        fiatQuote(source, destination string, sourceAmount decimal.Decimal) (models.FiatQuote, error)

        // cryptoQuote will retrieve a quote for a Cryptocurrency price.
        cryptoQuote(source, destination string) (models.CryptoQuote, error)

        // FiatConversion will convert a source currency, in a given amount, to the destination currency.
        FiatConversion(source, destination string, amount decimal.Decimal,
                fiatQuote func(source, destination string, amount decimal.Decimal) (models.FiatQuote, error)) (
                decimal.Decimal, decimal.Decimal, error)

        // CryptoConversion will convert Fiat to Crypto and Crypto to Fiat currencies, for a given amount.
        CryptoConversion(fiatSymbol, cryptoSymbol string, amount decimal.Decimal, isPurchasingCrypto bool,
                cryptoQuote func(source, destination string) (models.CryptoQuote, error)) (
                decimal.Decimal, decimal.Decimal, error)
}

// Check to ensure the Redis interface has been implemented.
var _ Quotes = &amp;quotesImpl{}

// quoteImpl implements the Quote interface and contains the logic to interface with currency price services.
type quotesImpl struct {
        clientCrypto *req.Client
        clientFiat   *req.Client
        conf         *config
        logger       *logger.Logger
}

// NewQuote will create a new Quote configuration by loading it.
func NewQuote(fs *afero.Fs, logger *logger.Logger) (Quotes, error) <span class="cov0" title="0">{
        if fs == nil || logger == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil file system or logger supplied")
        }</span>

        <span class="cov0" title="0">return newQuotesImpl(fs, logger)</span>
}

// newQuoteImpl will create a new quoteImpl configuration and load it from disk.
func newQuotesImpl(fs *afero.Fs, logger *logger.Logger) (q *quotesImpl, err error) <span class="cov3" title="2">{
        q = &amp;quotesImpl{conf: newConfig(), logger: logger}
        if err = q.conf.Load(*fs); err != nil </span><span class="cov1" title="1">{
                q.logger.Error("failed to load Quote configurations from disk", zap.Error(err))

                return nil, err
        }</span>

        // Fiat Client configuration.
        <span class="cov1" title="1">q.clientFiat, err = configFiatClient(q.conf)
        if err != nil </span><span class="cov0" title="0">{
                q.logger.Error("failed to configure Fiat client", zap.Error(err))

                return nil, err
        }</span>

        // Crypto Client configuration.
        <span class="cov1" title="1">q.clientCrypto, err = configCryptoClient(q.conf)
        if err != nil </span><span class="cov0" title="0">{
                q.logger.Error("failed to configure Crypto client", zap.Error(err))

                return nil, err
        }</span>

        <span class="cov1" title="1">return</span>
}

// configFiatClient will setup the global configurations for the Fiat client.
func configFiatClient(conf *config) (*req.Client, error) <span class="cov5" title="4">{
        if conf == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("configurations not loaded")
        }</span>

        <span class="cov4" title="3">return req.C().
                        SetUserAgent(conf.Connection.UserAgent).
                        SetTimeout(conf.Connection.Timeout).
                        SetCommonHeader(conf.FiatCurrency.HeaderKey, conf.FiatCurrency.APIKey),
                nil</span>
}

// configCryptoClient will setup the global configurations for the Crypto client.
func configCryptoClient(conf *config) (*req.Client, error) <span class="cov5" title="4">{
        if conf == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("configurations not loaded")
        }</span>

        <span class="cov4" title="3">return req.C().
                        SetUserAgent(conf.Connection.UserAgent).
                        SetTimeout(conf.Connection.Timeout).
                        SetCommonHeader(conf.CryptoCurrency.HeaderKey, conf.CryptoCurrency.APIKey),
                nil</span>
}

// FiatQuote will access the Fiat currency price quote service and get the latest exchange rate.
func (q *quotesImpl) fiatQuote(source, destination string, sourceAmount decimal.Decimal) (models.FiatQuote, error) <span class="cov4" title="3">{
        result := models.FiatQuote{}

        _, err := q.clientFiat.R().
                SetQueryParam("from", source).
                SetQueryParam("to", destination).
                SetQueryParam("amount", sourceAmount.String()).
                SetSuccessResult(&amp;result).
                Get(q.conf.FiatCurrency.Endpoint)

        // Failed to query endpoint for price.
        if err != nil </span><span class="cov0" title="0">{
                q.logger.Warn("failed to get Fiat currency price quote", zap.Error(err))

                return result, NewError(constants.RetryMessageString()).SetStatus(http.StatusServiceUnavailable)
        }</span>

        // Check for a successful rate retrieval.
        <span class="cov4" title="3">if !result.Success </span><span class="cov1" title="1">{
                return result, NewError("invalid Fiat currency code").SetStatus(http.StatusBadRequest)
        }</span>

        <span class="cov3" title="2">return result, nil</span>
}

// FiatConversion will convert a source currency, of a given amount, to the destination currency.
func (q *quotesImpl) FiatConversion(
        source,
        destination string,
        amount decimal.Decimal,
        fiatQuote func(source, destination string, amount decimal.Decimal) (models.FiatQuote, error)) (
        decimal.Decimal, decimal.Decimal, error) <span class="cov7" title="8">{
        var (
                err      error
                rawQuote models.FiatQuote
        )

        // The fiatQuote parameter is exposed for stub injection used for testing.
        if fiatQuote == nil </span><span class="cov1" title="1">{
                fiatQuote = q.fiatQuote
        }</span>

        <span class="cov7" title="8">rawQuote, err = fiatQuote(source, destination, amount)
        if err != nil </span><span class="cov1" title="1">{
                q.logger.Warn("failed to convert Fiat currency", zap.Error(err))

                return decimal.Decimal{}, decimal.Decimal{}, fmt.Errorf("%w", err)
        }</span>

        // For precision-related concerns, the amount to be posted will be recalculated here.
        // We only rely on the quote provider for rate quote's precision and not the amount converted precision.
        <span class="cov7" title="7">convertedAmount := rawQuote.Info.Rate.
                Mul(amount).
                RoundBank(constants.DecimalPlacesFiat())

        return rawQuote.Info.Rate, convertedAmount, nil</span>
}

// CryptoQuote will access the Fiat currency price quote service and get the latest exchange rate.
func (q *quotesImpl) cryptoQuote(source, destination string) (models.CryptoQuote, error) <span class="cov6" title="5">{
        result := models.CryptoQuote{}

        resp, err := q.clientCrypto.R().
                SetPathParam("base_symbol", source).
                SetPathParam("quote_symbol", destination).
                SetSuccessResult(&amp;result).
                Get(q.conf.CryptoCurrency.Endpoint)

        // Failed to query endpoint for price.
        if err != nil </span><span class="cov0" title="0">{
                q.logger.Warn("failed to get Fiat currency price quote", zap.Error(err))

                return result, NewError("crypto price service unreachable").SetStatus(http.StatusInternalServerError)
        }</span>

        <span class="cov6" title="5">if !resp.IsSuccessState() </span><span class="cov1" title="1">{
                // Invalid cryptocurrency codes.
                if resp.StatusCode == 550 </span><span class="cov1" title="1">{ //nolint:gomnd
                        return result, NewError("invalid Crypto currency code").SetStatus(http.StatusBadRequest)
                }</span>

                // Log and other API related errors and return an internal server error to user.
                <span class="cov0" title="0">q.logger.Error("API error", zap.String("Response", resp.String()))

                return result, NewError(constants.RetryMessageString()).SetStatus(http.StatusInternalServerError)</span>
        }

        <span class="cov5" title="4">return result, nil</span>
}

// CryptoConversion will convert Fiat to Crypto and Crypto to Fiat currencies, for a given amount.
func (q *quotesImpl) CryptoConversion(
        sourceCurrency,
        destinationCurrency string,
        sourceAmount decimal.Decimal,
        isPurchasingCrypto bool,
        cryptoQuote func(source, destination string) (models.CryptoQuote, error)) (
        decimal.Decimal, decimal.Decimal, error) <span class="cov10" title="15">{
        var (
                precision = constants.DecimalPlacesCrypto()
                err       error
                rawQuote  models.CryptoQuote
        )

        // The fiatQuote parameter is exposed for stub injection used for testing.
        if cryptoQuote == nil </span><span class="cov3" title="2">{
                cryptoQuote = q.cryptoQuote
        }</span>

        <span class="cov10" title="15">if !isPurchasingCrypto </span><span class="cov7" title="7">{
                precision = constants.DecimalPlacesFiat()
        }</span>

        <span class="cov10" title="15">rawQuote, err = cryptoQuote(sourceCurrency, destinationCurrency)
        if err != nil </span><span class="cov1" title="1">{
                q.logger.Warn("failed to retrieve Fiat to Cryptocurrency exchange quote", zap.Error(err))

                return decimal.Decimal{}, decimal.Decimal{}, fmt.Errorf("%w", err)
        }</span>

        // For precision-related concerns, the amount to be posted will be recalculated here.
        // We only rely on the quote provider for rate quote's precision and not the amount converted precision.
        <span class="cov9" title="14">convertedAmount := rawQuote.Rate.
                Mul(sourceAmount).
                RoundBank(precision)

        return rawQuote.Rate, convertedAmount, nil</span>
}
</pre>

		<pre class="file" id="file44" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/surahman/FTeX/pkg/quotes (interfaces: Quotes)

// Package quotes is a generated GoMock package.
package quotes

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        decimal "github.com/shopspring/decimal"
        models "github.com/surahman/FTeX/pkg/models"
)

// MockQuotes is a mock of Quotes interface.
type MockQuotes struct {
        ctrl     *gomock.Controller
        recorder *MockQuotesMockRecorder
}

// MockQuotesMockRecorder is the mock recorder for MockQuotes.
type MockQuotesMockRecorder struct {
        mock *MockQuotes
}

// NewMockQuotes creates a new mock instance.
func NewMockQuotes(ctrl *gomock.Controller) *MockQuotes <span class="cov10" title="20">{
        mock := &amp;MockQuotes{ctrl: ctrl}
        mock.recorder = &amp;MockQuotesMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuotes) EXPECT() *MockQuotesMockRecorder <span class="cov10" title="20">{
        return m.recorder
}</span>

// CryptoConversion mocks base method.
func (m *MockQuotes) CryptoConversion(arg0, arg1 string, arg2 decimal.Decimal, arg3 bool, arg4 func(string, string) (models.CryptoQuote, error)) (decimal.Decimal, decimal.Decimal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CryptoConversion", arg0, arg1, arg2, arg3, arg4)
        ret0, _ := ret[0].(decimal.Decimal)
        ret1, _ := ret[1].(decimal.Decimal)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// CryptoConversion indicates an expected call of CryptoConversion.
func (mr *MockQuotesMockRecorder) CryptoConversion(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CryptoConversion", reflect.TypeOf((*MockQuotes)(nil).CryptoConversion), arg0, arg1, arg2, arg3, arg4)
}</span>

// FiatConversion mocks base method.
func (m *MockQuotes) FiatConversion(arg0, arg1 string, arg2 decimal.Decimal, arg3 func(string, string, decimal.Decimal) (models.FiatQuote, error)) (decimal.Decimal, decimal.Decimal, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FiatConversion", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(decimal.Decimal)
        ret1, _ := ret[1].(decimal.Decimal)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FiatConversion indicates an expected call of FiatConversion.
func (mr *MockQuotesMockRecorder) FiatConversion(arg0, arg1, arg2, arg3 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FiatConversion", reflect.TypeOf((*MockQuotes)(nil).FiatConversion), arg0, arg1, arg2, arg3)
}</span>

// cryptoQuote mocks base method.
func (m *MockQuotes) cryptoQuote(arg0, arg1 string) (models.CryptoQuote, error) <span class="cov8" title="13">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cryptoQuote", arg0, arg1)
        ret0, _ := ret[0].(models.CryptoQuote)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// cryptoQuote indicates an expected call of cryptoQuote.
func (mr *MockQuotesMockRecorder) cryptoQuote(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="13">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cryptoQuote", reflect.TypeOf((*MockQuotes)(nil).cryptoQuote), arg0, arg1)
}</span>

// fiatQuote mocks base method.
func (m *MockQuotes) fiatQuote(arg0, arg1 string, arg2 decimal.Decimal) (models.FiatQuote, error) <span class="cov6" title="7">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "fiatQuote", arg0, arg1, arg2)
        ret0, _ := ret[0].(models.FiatQuote)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// fiatQuote indicates an expected call of fiatQuote.
func (mr *MockQuotesMockRecorder) fiatQuote(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov6" title="7">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "fiatQuote", reflect.TypeOf((*MockQuotes)(nil).fiatQuote), arg0, arg1, arg2)
}</span>
</pre>

		<pre class="file" id="file45" style="display: none">package quotes

// configTestData will return a map of test data containing valid and invalid http quotes client configs.
func configTestData() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "empty": ``,

                "valid": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout: 5s`,

                "no fiat api key": `
fiatCurrency:
  apiKey:
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout: 1s`,

                "no fiat header key": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey:
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout: 1s
`,

                "no fiat api endpoint": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint:
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout: 1s`,

                "no fiat": `
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout: 1s`,

                "no crypto api key": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey:
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout: 1s`,

                "no crypto header key": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey:
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout: 1s`,

                "no crypto api endpoint": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint:
connection:
  userAgent: ftex_inc
  timeout: 1s`,

                "no crypto": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
connection:
  userAgent: ftex_inc
  timeout: 1s`,

                "no connection user-agent": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent:
  timeout: 1s`,

                "no connection timeout": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}
connection:
  userAgent: ftex_inc
  timeout:`,

                "no connection": `
fiatCurrency:
  apiKey: some-api-key-for-fiat-currencies
  headerKey: X-RapidAPI-Key
  endpoint: https://currency-conversion-and-exchange-rates.p.rapidapi.com/convert?
cryptoCurrency:
  apiKey: some-api-key-for-crypto-currencies
  headerKey: X-CoinAPI-Key
  endpoint: https://rest.coinapi.io/v1/exchangerate/{base_symbol}/{quote_symbol}`,
        }
}</span>
</pre>

		<pre class="file" id="file46" style="display: none">package redis

import (
        "fmt"

        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/configloader"
        "github.com/surahman/FTeX/pkg/constants"
)

// config is the configuration container for connecting to the Redis database.
//
//nolint:lll
type config struct {
        Authentication authenticationConfig `json:"authentication,omitempty" mapstructure:"authentication" yaml:"authentication,omitempty"`
        Connection     connectionConfig     `json:"connection,omitempty"     mapstructure:"connection"     yaml:"connection,omitempty"`
}

// authenticationConfig contains the Redis session authentication information.
type authenticationConfig struct {
        Username string `json:"username,omitempty" mapstructure:"username" validate:"required"       yaml:"username,omitempty"`
        Password string `json:"password,omitempty" mapstructure:"password" yaml:"password,omitempty"`
}

// connectionConfig contains the Redis session connection information.
//
//nolint:lll
type connectionConfig struct {
        Addr            string `json:"addr,omitempty"            mapstructure:"addr"            validate:"required"           yaml:"addr,omitempty"`
        MaxConnAttempts int    `json:"maxConnAttempts,omitempty" mapstructure:"maxConnAttempts" validate:"required,min=1"     yaml:"maxConnAttempts,omitempty"`
        MaxRetries      int    `json:"maxRetries,omitempty"      mapstructure:"maxRetries"      validate:"required,min=1"     yaml:"maxRetries,omitempty"`
        PoolSize        int    `json:"poolSize,omitempty"        mapstructure:"poolSize"        validate:"required,min=1"     yaml:"poolSize,omitempty"`
        MinIdleConns    int    `json:"minIdleConns,omitempty"    mapstructure:"minIdleConns"    validate:"required,min=1"     yaml:"minIdleConns,omitempty"`
        MaxIdleConns    int    `json:"maxIdleConns,omitempty"    mapstructure:"maxIdleConns"    yaml:"maxIdleConns,omitempty"`
}

// newConfig creates a blank configuration struct for Redis.
func newConfig() *config <span class="cov4" title="3">{
        return &amp;config{}
}</span>

// Load will attempt to load configurations from a file on a file system.
func (cfg *config) Load(fs afero.Fs) error <span class="cov10" title="21">{
        if err := configloader.Load(
                fs,
                cfg,
                constants.RedisFileName(),
                constants.RedisPrefix(),
                "yaml"); err != nil </span><span class="cov6" title="7">{
                return fmt.Errorf("redis config loading failed: %w", err)
        }</span>

        <span class="cov8" title="14">return nil</span>
}
</pre>

		<pre class="file" id="file47" style="display: none">package redis

import (
        "errors"
)

// Error codes.
const (
        ErrorUnknown = iota
        ErrorCacheMiss
        ErrorCacheSet
        ErrorCacheDel
        ErrorUnhealthy
)

// Error is the base error type. The builder pattern is used to add specialization codes to the errors.
type Error struct {
        Message string
        Code    int
}

// Check to ensure the error interface is implemented.
var _ error = &amp;Error{}

// Error get human readable error message.
func (e *Error) Error() string <span class="cov3" title="2">{
        return e.Message
}</span>

// Is will return whether the input err is an instance of expected error.
func (e *Error) Is(err error) bool <span class="cov7" title="9">{
        var target *Error
        if !errors.As(err, &amp;target) </span><span class="cov4" title="3">{
                return false
        }</span>

        <span class="cov6" title="6">return e.Code == target.Code</span>
}

// NewError is a base error message with no special code.
func NewError(message string) *Error <span class="cov10" title="20">{
        return &amp;Error{Message: message, Code: ErrorUnknown}
}</span>

// errorCacheMiss will specialize the error as a cache miss.
func (e *Error) errorCacheMiss() *Error <span class="cov7" title="10">{
        e.Code = ErrorCacheMiss

        return e
}</span>

// errorCacheSet will specialize the error as a cache set failure.
func (e *Error) errorCacheSet() *Error <span class="cov5" title="4">{
        e.Code = ErrorCacheSet

        return e
}</span>

// errorCacheDel will specialize the error as a cache delete failure.
func (e *Error) errorCacheDel() *Error <span class="cov5" title="4">{
        e.Code = ErrorCacheDel

        return e
}</span>

// Generic error variables.
// Errors to be returned by the Postgres Queries exposed through the interface for various failure conditions.
var (
        ErrCacheUnknown = errorCacheUnknown() // ErrCacheUnknown is returned if an unknown error occurs in the cache.
        ErrCacheMiss    = errorCacheMiss()    // ErrCacheMiss is returned when a cache miss occurs.
        ErrCacheSet     = errorCacheSet()     // ErrCacheSet is returned if a key-value pair cannot be placed in the cache.
        ErrCacheDel     = errorCacheDel()     // ErrCacheDel is returned if a key-value pair cannot be deleted from the cache.
        ErrUnhealthy    = errorUnhealthy()    // ErrUnhealthy is returned if the cache is unreachable.
)

func errorCacheUnknown() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "unknown Redis cache error",
                Code:    ErrorUnknown,
        }
}</span>

func errorCacheMiss() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "Redis cache miss",
                Code:    ErrorCacheMiss,
        }
}</span>

func errorCacheSet() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "Redis cache Set failure",
                Code:    ErrorCacheSet,
        }
}</span>

func errorCacheDel() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "Redis cache Del failure",
                Code:    ErrorCacheDel,
        }
}</span>

func errorUnhealthy() error <span class="cov1" title="1">{
        return &amp;Error{
                Message: "unhealthy",
                Code:    ErrorUnhealthy,
        }
}</span>
</pre>

		<pre class="file" id="file48" style="display: none">package redis

import (
        "bytes"
        "context"
        "encoding/gob"
        "errors"
        "fmt"
        "math"
        "strconv"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "go.uber.org/zap"
)

// Mock Redis interface stub generation.
//go:generate mockgen -destination=../mocks/mock_redis.go -package=mocks github.com/surahman/FTeX/pkg/redis Redis

// Redis is the interface through which the cache server can be accessed. Created to support mock testing.
type Redis interface {
        // Open will create a connection pool and establish a connection to the Redis cache server.
        Open() error

        // Close will shut down the connection pool and ensure that the connection to the Redis cache server is terminated.
        // correctly.
        Close() error

        // Healthcheck will ping all the Redis cache server to see if all the shards are reachable.
        Healthcheck() error

        // Set will place a key with a given value in the cache with a TTL, if specified in the configurations.
        Set(string, any, time.Duration) error

        // Get will retrieve a value associated with a provided key.
        Get(string, any) error

        // Del will remove all keys provided as a set of keys.
        Del(...string) error
}

// Check to ensure the Redis interface has been implemented.
var _ Redis = &amp;redisImpl{}

// redisImpl implements the Redis interface and contains the logic to interface with the cache.
type redisImpl struct {
        conf    *config
        logger  *logger.Logger
        redisDB *redis.Client
}

// NewRedis will create a new Redis configuration by loading it.
func NewRedis(fs *afero.Fs, logger *logger.Logger) (Redis, error) <span class="cov6" title="4">{
        if fs == nil || logger == nil </span><span class="cov4" title="3">{
                return nil, errors.New("nil file system or logger supplied")
        }</span>

        <span class="cov1" title="1">return newRedisImpl(fs, logger)</span>
}

// newRedisImpl will create a new redisImpl configuration and load it from disk.
func newRedisImpl(fs *afero.Fs, logger *logger.Logger) (c *redisImpl, err error) <span class="cov4" title="3">{
        c = &amp;redisImpl{conf: newConfig(), logger: logger}
        if err = c.conf.Load(*fs); err != nil </span><span class="cov1" title="1">{
                c.logger.Error("failed to load Redis configurations from disk", zap.Error(err))

                return nil, err
        }</span>

        <span class="cov3" title="2">return</span>
}

// verifySession will check to see if a session is established.
func (r *redisImpl) verifySession() error <span class="cov10" title="12">{
        if r.redisDB == nil || r.redisDB.Ping(context.Background()).Err() != nil </span><span class="cov9" title="10">{
                return errors.New("no session established")
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// createSessionRetry will attempt to open the connection using binary exponential back-off and stop on the first
// success or fail after the last one.
func (r *redisImpl) createSessionRetry() error <span class="cov7" title="6">{
        var err error

        for attempt := 1; attempt &lt;= r.conf.Connection.MaxConnAttempts; attempt++ </span><span class="cov7" title="6">{
                waitTime := time.Duration(math.Pow(2, float64(attempt))) * time.Second
                r.logger.Info(fmt.Sprintf("Attempting connection to Redis server in %s...", waitTime),
                        zap.String("attempt", strconv.Itoa(attempt)))

                time.Sleep(waitTime)

                // Successfully opened lazy connection with a ping.
                if err = r.redisDB.Ping(context.Background()).Err(); err == nil </span><span class="cov6" title="4">{
                        return nil
                }</span>
        }

        // Unable to ping Redis server and establish lazy connection.
        <span class="cov3" title="2">msg := "unable to establish connection to Redis server"
        r.logger.Error(msg, zap.Error(err))

        return fmt.Errorf(msg+" %w", err)</span>
}

// Open will establish a connection to the Redis cache server.
func (r *redisImpl) Open() error <span class="cov8" title="7">{
        // Stop connection leaks.
        if err := r.verifySession(); err == nil </span><span class="cov1" title="1">{
                msg := "session to Redis server is already established"
                r.logger.Warn(msg)

                return fmt.Errorf(msg+" %w", err)
        }</span>

        // Compile Redis connection configurations.
        <span class="cov7" title="6">redisConfig := &amp;redis.Options{
                Addr:                  r.conf.Connection.Addr,
                Username:              r.conf.Authentication.Username,
                Password:              r.conf.Authentication.Password,
                MaxRetries:            r.conf.Connection.MaxRetries,
                PoolSize:              r.conf.Connection.PoolSize,
                MinIdleConns:          r.conf.Connection.MinIdleConns,
                ContextTimeoutEnabled: true,
        }

        if r.conf.Connection.MaxIdleConns &gt; 0 </span><span class="cov6" title="5">{
                redisConfig.MaxIdleConns = r.conf.Connection.MaxIdleConns
        }</span>

        <span class="cov7" title="6">r.redisDB = redis.NewClient(redisConfig)

        return r.createSessionRetry()</span>
}

// Close will terminate a connection to the Redis cache server.
func (r *redisImpl) Close() error <span class="cov4" title="3">{
        var err error

        // Check for an open connection.
        if err = r.verifySession(); err != nil </span><span class="cov3" title="2">{
                msg := "no session to Redis server established to close"
                r.logger.Warn(msg)

                return fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov1" title="1">if err = r.redisDB.Close(); err != nil </span><span class="cov0" title="0">{
                msg := "failed to close Redis server connection"
                r.logger.Warn(msg)

                return fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Healthcheck will iterate through all the data shards and attempt to ping them to ensure they are all reachable.
func (r *redisImpl) Healthcheck() error <span class="cov3" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ThreeSeconds())

        defer cancel()

        if err := r.redisDB.Ping(ctx).Err(); err != nil </span><span class="cov1" title="1">{
                msg := "redis health check ping failed"
                r.logger.Info(msg)

                return fmt.Errorf(msg+" %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Set will place a key with a given value in the Redis cache server with a TTL, if specified in the configurations.
func (r *redisImpl) Set(key string, value any, expiration time.Duration) error <span class="cov3" title="2">{
        // Write value to a byte array.
        buffer := bytes.Buffer{}
        encoder := gob.NewEncoder(&amp;buffer)

        if err := encoder.Encode(value); err != nil </span><span class="cov0" title="0">{
                return NewError(err.Error())
        }</span>

        <span class="cov3" title="2">if err := r.redisDB.Set(context.Background(), key, buffer.Bytes(), expiration).Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to place item in Redis cache", zap.String("key", key), zap.Error(err))

                return NewError(err.Error()).errorCacheSet()
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Get will retrieve a value associated with a provided key and write the result into the value parameter.
func (r *redisImpl) Get(key string, value any) error <span class="cov7" title="6">{
        var (
                err     error
                rawData []byte
        )

        if rawData, err = r.redisDB.Get(context.Background(), key).Bytes(); err != nil </span><span class="cov6" title="4">{
                return NewError(err.Error()).errorCacheMiss()
        }</span>

        // Convert to struct.
        <span class="cov3" title="2">decoder := gob.NewDecoder(bytes.NewBuffer(rawData))
        if err = decoder.Decode(value); err != nil </span><span class="cov0" title="0">{
                return NewError(err.Error())
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Del will remove all keys provided as a list of keys.
func (r *redisImpl) Del(keys ...string) error <span class="cov6" title="4">{
        for _, key := range keys </span><span class="cov6" title="4">{
                intCmd := r.redisDB.Del(context.Background(), key)
                if err := intCmd.Err(); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("failed to evict item from Redis cache", zap.String("key", key), zap.Error(err))

                        return NewError(err.Error()).errorCacheDel()
                }</span>

                <span class="cov6" title="4">if intCmd.Val() == 0 </span><span class="cov3" title="2">{
                        err := NewError("unable to locate key on Redis cache").errorCacheMiss()
                        r.logger.Warn("failed to evict item from Redis cache", zap.String("key", key), zap.Error(err))

                        return err
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}
</pre>

		<pre class="file" id="file49" style="display: none">package redis

// configTestData will return a map of test data containing valid and invalid Redis configs.
func configTestData() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "empty": ``,

                "valid": `
authentication:
  username: root
  password: root
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 5
  maxRetries: 3
  poolSize: 4
  minIdleConns: 1
  maxIdleConns: 20`,

                "username_empty": `
authentication:
  username:
  password: root
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 5
  maxRetries: 3
  poolSize: 4
  minIdleConns: 1
  maxIdleConns: 20`,

                "password_empty": `
authentication:
  username: root
  password:
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 5
  maxRetries: 3
  poolSize: 4
  minIdleConns: 1
  maxIdleConns: 20`,

                "no_addr": `
authentication:
  username: root
  password: root
connection:
  addr:
  maxConnAttempts: 5
  maxRetries: 3
  poolSize: 4
  minIdleConns: 1
  maxIdleConns: 20`,

                "invalid_max_retries": `
authentication:
  username: root
  password: root
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 5
  maxRetries: 0
  poolSize: 4
  minIdleConns: 1
  maxIdleConns: 20`,

                "invalid_pool_size": `
authentication:
  username: root
  password: root
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 5
  maxRetries: 3
  poolSize: 0
  minIdleConns: 1
  maxIdleConns: 20`,

                "invalid_min_idle_conns": `
authentication:
  username: root
  password: root
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 5
  maxRetries: 3
  poolSize: 4
  minIdleConns: 0
  maxIdleConns: 20`,

                "no_max_idle_conns": `
authentication:
  username: root
  password: root
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 5
  maxRetries: 3
  poolSize: 4
  minIdleConns: 10
  maxIdleConns:`,

                "test_suite": `
authentication:
  username: ftex_service
  password: ZoF1bncLLyYT1agKfWQY
connection:
  addr: 127.0.0.1:7379
  maxConnAttempts: 1
  maxRetries: 3
  poolSize: 4
  minIdleConns: 1
  maxIdleConns: 20`,

                "github-ci-runner": `
authentication:
  username: default
  password:
connection:
  addr: 127.0.0.1:6379
  maxConnAttempts: 3
  maxRetries: 3
  poolSize: 4
  minIdleConns: 1
  maxIdleConns: 20`,
        }
}</span>
</pre>

		<pre class="file" id="file50" style="display: none">package rest

import (
        "fmt"
        "time"

        "github.com/spf13/afero"
        "github.com/surahman/FTeX/pkg/configloader"
        "github.com/surahman/FTeX/pkg/constants"
)

// config is the configuration for the HTTP REST endpoint.
//
//nolint:lll
type config struct {
        Server        serverConfig        `json:"server,omitempty"        mapstructure:"server"        validate:"required" yaml:"server,omitempty"`
        Authorization authorizationConfig `json:"authorization,omitempty" mapstructure:"authorization" validate:"required" yaml:"authorization,omitempty"`
}

// serverConfig contains the configurations for the HTTP REST server.
//
//nolint:lll
type serverConfig struct {
        BasePath          string        `json:"basePath,omitempty"          mapstructure:"basePath"          validate:"required"          yaml:"basePath,omitempty"`
        SwaggerPath       string        `json:"swaggerPath,omitempty"       mapstructure:"swaggerPath"       validate:"required"          yaml:"swaggerPath,omitempty"`
        PortNumber        int           `json:"portNumber,omitempty"        mapstructure:"portNumber"        validate:"required,min=1000" yaml:"portNumber,omitempty"`
        ShutdownDelay     time.Duration `json:"shutdownDelay,omitempty"     mapstructure:"shutdownDelay"     validate:"required,min=0"    yaml:"shutdownDelay,omitempty"`
        ReadTimeout       time.Duration `json:"readTimeout,omitempty"       mapstructure:"readTimeout"       validate:"required,min=1"    yaml:"readTimeout,omitempty"`
        WriteTimeout      time.Duration `json:"writeTimeout,omitempty"      mapstructure:"writeTimeout"      validate:"required,min=1"    yaml:"writeTimeout,omitempty"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout,omitempty" mapstructure:"readHeaderTimeout" validate:"required,min=1"    yaml:"readHeaderTimeout,omitempty"`
}

// authorizationConfig contains the configurations for request authorization.
type authorizationConfig struct {
        HeaderKey string `json:"headerKey,omitempty" mapstructure:"headerKey" validate:"required" yaml:"headerKey,omitempty"`
}

// newConfig creates a blank configuration struct for the authorization.
func newConfig() *config <span class="cov1" title="1">{
        return &amp;config{}
}</span>

// Load will attempt to load configurations from a file on a file system.
func (cfg *config) Load(fs afero.Fs) error <span class="cov10" title="12">{
        if err := configloader.Load(
                fs,
                cfg,
                constants.HTTPRESTFileName(),
                constants.HTTPRESTPrefix(),
                "yaml"); err != nil </span><span class="cov8" title="9">{
                return fmt.Errorf("rest config loading failed: %w", err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}
</pre>

		<pre class="file" id="file51" style="display: none">package rest

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/postgres"
        "go.uber.org/zap"
)

// AuthMiddleware is the middleware that checks whether a JWT is valid and can access an endpoint.
func AuthMiddleware(auth auth.Auth, db postgres.Postgres, logger *logger.Logger, authHeaderKey string) gin.HandlerFunc <span class="cov10" title="6">{
        handler := func(context *gin.Context) </span><span class="cov9" title="5">{
                var (
                        err         error
                        clientID    uuid.UUID
                        expiresAt   int64
                        isDeleted   bool
                        tokenString = context.GetHeader(authHeaderKey)
                )

                if tokenString == "" </span><span class="cov1" title="1">{
                        context.JSON(http.StatusUnauthorized, "request does not contain an access token")
                        context.Abort()

                        return
                }</span>

                <span class="cov7" title="4">if clientID, expiresAt, err = auth.ValidateJWT(tokenString); err != nil </span><span class="cov1" title="1">{
                        context.JSON(http.StatusForbidden, "request contains invalid or expired authorization token")
                        context.Abort()

                        return
                }</span>

                // Check for user deleted status.
                <span class="cov6" title="3">if isDeleted, err = db.UserIsDeleted(clientID); err != nil </span><span class="cov1" title="1">{
                        logger.Error("unable to retrieve client account status", zap.Error(err))

                        context.JSON(http.StatusInternalServerError, constants.RetryMessageString())
                        context.Abort()

                        return
                }</span>

                <span class="cov4" title="2">if isDeleted </span><span class="cov1" title="1">{
                        context.JSON(http.StatusForbidden, "request contains invalid or expired authorization token")
                        context.Abort()

                        return
                }</span>

                // Store the extracted ClientID and expiration deadline values in the Gin context for handlers.
                <span class="cov1" title="1">context.Set(constants.ClientIDCtxKey(), clientID)
                context.Set(constants.ExpiresAtCtxKey(), expiresAt)

                context.Next()</span>
        }

        <span class="cov10" title="6">return handler</span>
}
</pre>

		<pre class="file" id="file52" style="display: none">package rest

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/common"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/quotes"
        "github.com/surahman/FTeX/pkg/redis"
        "github.com/surahman/FTeX/pkg/validator"
)

// OpenCrypto will handle an HTTP request to open a Cryptocurrency account.
//
//        @Summary                Open a Cryptocurrency account.
//        @Description        Creates a Cryptocurrency account for a specified ticker, to be provided as the currency in the request, for a user by creating a row in the Crypto Accounts table.
//        @Tags                        crypto cryptocurrency currency open
//        @Id                                openCrypto
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        request        body                models.HTTPOpenCurrencyAccountRequest        true        "cryptocurrency ticker for new account"
//        @Success                201                {object}        models.HTTPSuccess                                                "a message to confirm the creation of an account"
//        @Failure                400                {object}        models.HTTPError                                                "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                                                "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                                                "error message with any available details in payload"
//        @Router                        /crypto/open [post]
//
//nolint:dupl
func OpenCrypto(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov6" title="5">{
        return func(ginCtx *gin.Context) </span><span class="cov6" title="5">{
                var (
                        clientID    uuid.UUID
                        err         error
                        request     models.HTTPOpenCurrencyAccountRequest
                        httpStatus  int
                        httpMessage string
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov6" title="4">if err = ginCtx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov6" title="4">if err = validator.ValidateStruct(&amp;request); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest,
                                models.HTTPError{Message: constants.ValidationString(), Payload: err})

                        return
                }</span>

                <span class="cov4" title="3">if httpStatus, httpMessage, err = common.HTTPCryptoOpen(db, logger, clientID, request.Currency); err != nil </span><span class="cov3" title="2">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: request.Currency})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusCreated,
                        models.HTTPSuccess{Message: "account created", Payload: []string{clientID.String(), request.Currency}})</span>
        }
}

// OfferCrypto will handle an HTTP request to get a purchase or sale offer for a Fiat or Cryptocurrency.
//
//        @Summary                Purchase or sell a Cryptocurrency and using a Fiat currency.
//        @Description        Purchase or sell a Fiat currency using a Cryptocurrency. The amount must be a positive number with at most two or eight decimal places for Fiat and Cryptocurrencies respectively. Both currency accounts must be opened beforehand.
//        @Tags                        fiat crypto cryptocurrency currency sell sale offer
//        @Id                                sellOfferCrypto
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        request        body                models.HTTPCryptoOfferRequest        true        "the Cryptocurrency ticker, Fiat currency code, and amount to be converted in the source currency"
//        @Success                200                {object}        models.HTTPSuccess                                "a message to confirm the purchase rate for a Fiat or Cryptocurrency"
//        @Failure                400                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Router                        /crypto/offer [post]
func OfferCrypto(logger *logger.Logger, auth auth.Auth, cache redis.Redis, quotes quotes.Quotes) gin.HandlerFunc <span class="cov10" title="12">{
        return func(ginCtx *gin.Context) </span><span class="cov10" title="12">{
                var (
                        clientID      uuid.UUID
                        err           error
                        request       models.HTTPCryptoOfferRequest
                        offer         models.HTTPExchangeOfferResponse
                        status        int
                        statusMessage string
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov9" title="11">if err = ginCtx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov9" title="11">if err = validator.ValidateStruct(&amp;request); err != nil </span><span class="cov3" title="2">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest,
                                models.HTTPError{Message: constants.ValidationString(), Payload: err})

                        return
                }</span>

                <span class="cov8" title="9">offer, status, statusMessage, err = common.HTTPCryptoOffer(auth, cache, logger, quotes,
                        clientID, request.SourceCurrency, request.DestinationCurrency, request.SourceAmount, *request.IsPurchase)
                if err != nil </span><span class="cov8" title="7">{
                        httpErr := &amp;models.HTTPError{Message: statusMessage}
                        if statusMessage == constants.InvalidRequestString() </span><span class="cov4" title="3">{
                                httpErr.Payload = err.Error()
                        }</span>

                        <span class="cov8" title="7">ginCtx.AbortWithStatusJSON(status, httpErr)

                        return</span>
                }

                <span class="cov3" title="2">offer.ClientID = clientID

                ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "crypto rate offer", Payload: offer})</span>
        }
}

// ExchangeCrypto will handle an HTTP request to execute and complete a Cryptocurrency purchase/sale offer. The default
// action is to purchase a Cryptocurrency using a Fiat.
//
//        @Summary                Transfer funds between Fiat and Crypto accounts using a valid Offer ID.
//        @Description        Purchase or sell a Cryptocurrency to/from a Fiat currency accounts. The Offer ID must be valid and have expired.
//        @Tags                        crypto fiat currency cryptocurrency exchange convert offer transfer execute
//        @Id                                exchangeCrypto
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        offerID        body                models.HTTPTransferRequest        true        "the two currency codes and amount to be converted"
//        @Success                200                {object}        models.HTTPSuccess                        "a message to confirm the conversion of funds"
//        @Failure                400                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                408                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Router                        /crypto/exchange/ [post]
func ExchangeCrypto(logger *logger.Logger, auth auth.Auth, cache redis.Redis, db postgres.Postgres) gin.HandlerFunc <span class="cov6" title="5">{
        return func(ginCtx *gin.Context) </span><span class="cov6" title="5">{
                var (
                        err      error
                        clientID uuid.UUID
                        request  models.HTTPTransferRequest
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov6" title="4">if err = ginCtx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov6" title="4">if err = validator.ValidateStruct(&amp;request); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest,
                                models.HTTPError{Message: constants.ValidationString(), Payload: err})

                        return
                }</span>

                <span class="cov4" title="3">receipt, status, httpErrMsg, err := common.HTTPExchangeCrypto(auth, cache, db, logger, clientID, request.OfferID)
                if err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(status, &amp;models.HTTPError{Message: httpErrMsg})

                        return
                }</span>

                <span class="cov3" title="2">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "funds exchange transfer successful", Payload: receipt})</span>
        }
}

// BalanceCrypto will handle an HTTP request to retrieve a balance for a specific Cryptocurrency.
//
//        @Summary                Retrieve balance for a specific Cryptocurrency.
//        @Description        Retrieves the balance for a specific Cryptocurrency. The currency ticker must be supplied as a query parameter.
//        @Tags                        crypto cryptocurrency currency balance
//        @Id                                balanceCurrencyCrypto
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        ticker        path                string                                true        "the Cryptocurrency ticker to retrieve the balance for"
//        @Success                200                {object}        models.HTTPSuccess        "the details for a specific currency account"
//        @Failure                400                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /crypto/info/balance/{ticker} [get]
//
//nolint:dupl
func BalanceCrypto(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov6" title="5">{
        return func(ginCtx *gin.Context) </span><span class="cov6" title="5">{
                var (
                        accDetails  *postgres.CryptoAccount
                        clientID    uuid.UUID
                        err         error
                        httpStatus  int
                        httpMessage string
                        payload     any
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov6" title="4">if accDetails, httpStatus, httpMessage, payload, err =
                        common.HTTPCryptoBalance(db, logger, clientID, ginCtx.Param("ticker")); err != nil </span><span class="cov4" title="3">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: payload})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "account balance", Payload: accDetails})</span>
        }
}

// TxDetailsCrypto will handle an HTTP request to retrieve information for a specific Crypto transaction.
//
//        @Summary                Retrieve transaction details for a specific transactionID.
//        @Description        Retrieves the transaction details for a specific transactionID. The transaction ID must be supplied as a query parameter.
//        @Tags                        crypto cryptocurrency transactionID transaction details
//        @Id                                txDetailsCrypto
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        transactionID        path                string                                true        "the transaction ID to retrieve the details for"
//        @Success                200                                {object}        models.HTTPSuccess        "the transaction details for a specific transaction ID"
//        @Failure                400                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /crypto/info/transaction/{transactionID} [get]
func TxDetailsCrypto(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov6" title="4">{
        return func(ginCtx *gin.Context) </span><span class="cov6" title="4">{
                var (
                        clientID      uuid.UUID
                        transactionID = ginCtx.Param("transactionID")
                        err           error
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                // Extract and validate the transactionID.
                <span class="cov4" title="3">journalEntries, status, errMsg, err := common.HTTPTxDetails(db, logger, clientID, transactionID)
                if err != nil </span><span class="cov3" title="2">{
                        ginCtx.AbortWithStatusJSON(status, models.HTTPError{Message: errMsg})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "transaction details", Payload: journalEntries})</span>
        }
}

// BalanceCryptoPaginated will handle an HTTP request to retrieve a balance for all Cryptocurrency accounts held by a
// single client.
//
// If a user requests N records, N+1 records will be requested. This is used to calculate if any further records are
// available for retrieval. The page cursor will be the encrypted N+1'th record to retrieve in the subsequent call.
//
//        @Summary                Retrieve all the Cryptocurrency balances for a specific client.
//        @Description        Retrieves all the Cryptocurrency balances for a specific client. The initial request will only contain (optionally) the page size. Subsequent requests will require a cursors to the next page that will be returned in a previous call to the endpoint. The user may choose to change the page size in any sequence of calls.
//        @Tags                        crypto cryptocurrency currency balance
//        @Id                                balanceCurrencyCryptoPaginated
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        pageCursor        query                string                                false        "The page cursor into the query results records."
//        @Param                        pageSize        query                int                                        false        "The number of records to retrieve on this page."
//        @Success                200                        {object}        models.HTTPSuccess        "a message to with a page of account balances for the client's accounts"
//        @Failure                400                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /crypto/info/balance [get]
func BalanceCryptoPaginated(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov8" title="9">{
        return func(ginCtx *gin.Context) </span><span class="cov8" title="9">{
                var (
                        accDetails  models.HTTPCryptoDetailsPaginated
                        httpStatus  int
                        httpMessage string
                        clientID    uuid.UUID
                        err         error
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov8" title="8">accDetails, httpStatus, httpMessage, err = common.HTTPCryptoBalancePaginated(auth, db, logger,
                        clientID, ginCtx.Query("pageCursor"), ginCtx.Query("pageSize"), true)
                if err != nil </span><span class="cov6" title="4">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage})

                        return
                }</span>

                <span class="cov6" title="4">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "account balances", Payload: accDetails})</span>
        }
}

// TxDetailsCryptoPaginated will handle an HTTP request to retrieve all transaction details for a currency account
// held by a single client for a given month.
//
// If a user requests N records, N+1 records will be requested. This is used to calculate if any further records are
// available for retrieval. The page cursor will be the encrypted date range for the month as well as the offset.
//
//        @Summary                Retrieve all the transactions for a currency account for a specific client during a specified month.
//        @Description        Retrieves all the transaction details for currency a specific client during the specified month. The initial request will contain (optionally) the page size and, month, year, and timezone (option, defaults to UTC). Subsequent requests will require a cursors to the next page that will be returned in the previous call to the endpoint. The user may choose to change the page size in any sequence of calls.
//        @Tags                        crypto cryptocurrency currency transaction
//        @Id                                txDetailsCryptoPaginated
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        ticker                path                string                                true        "the currency ticker to retrieve the transaction details for."
//        @Param                        pageCursor        query                string                                false        "The page cursor into the query results records."
//        @Param                        timezone        query                string                                false        "The timezone for the month in question."
//        @Param                        month                query                int                                        false        "The month for which transaction records are being requested."
//        @Param                        year                query                int                                        false        "The year for the month for which transaction records are being requested."
//        @Param                        pageSize        query                int                                        false        "The number of records to retrieve on this page."
//        @Success                200                        {object}        models.HTTPSuccess        "a message to confirm the conversion of funds"
//        @Failure                400                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                416                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /crypto/info/transaction/all/{ticker}/ [get]
func TxDetailsCryptoPaginated(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov8" title="7">{
        return func(ginCtx *gin.Context) </span><span class="cov8" title="7">{
                var (
                        clientID       uuid.UUID
                        ticker         = ginCtx.Param("ticker")
                        err            error
                        journalEntries models.HTTPCryptoTransactionsPaginated
                        httpStatus     int
                        httpMessage    string
                        params         = common.HTTPPaginatedTxParams{
                                PageSizeStr:   ginCtx.Query("pageSize"),
                                PageCursorStr: ginCtx.Query("pageCursor"),
                                TimezoneStr:   ginCtx.Query("timezone"),
                                MonthStr:      ginCtx.Query("month"),
                                YearStr:       ginCtx.Query("year"),
                        }
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov7" title="6">if journalEntries, httpStatus, httpMessage, err =
                        common.HTTPCryptoTransactionsPaginated(auth, db, logger, &amp;params, clientID, ticker, false); err != nil </span><span class="cov6" title="4">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage})

                        return
                }</span>

                <span class="cov3" title="2">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "account transactions", Payload: journalEntries})</span>
        }
}
</pre>

		<pre class="file" id="file53" style="display: none">package rest

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/common"
        "github.com/surahman/FTeX/pkg/constants"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/quotes"
        "github.com/surahman/FTeX/pkg/redis"
        "github.com/surahman/FTeX/pkg/validator"
)

// OpenFiat will handle an HTTP request to open a Fiat account.
//
//        @Summary                Open a Fiat account.
//        @Description        Creates a Fiat account for a specific currency for a user by creating a row in the Fiat Accounts table.
//        @Tags                        fiat currency open
//        @Id                                openFiat
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        request        body                models.HTTPOpenCurrencyAccountRequest        true        "currency code for new account"
//        @Success                201                {object}        models.HTTPSuccess                                                "a message to confirm the creation of an account"
//        @Failure                400                {object}        models.HTTPError                                                "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                                                "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                                                "error message with any available details in payload"
//        @Router                        /fiat/open [post]
//
//nolint:dupl
func OpenFiat(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov7" title="6">{
        return func(ginCtx *gin.Context) </span><span class="cov7" title="6">{
                var (
                        clientID    uuid.UUID
                        err         error
                        request     models.HTTPOpenCurrencyAccountRequest
                        httpStatus  int
                        httpMessage string
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov6" title="5">if err = ginCtx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov6" title="5">if err = validator.ValidateStruct(&amp;request); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest,
                                models.HTTPError{Message: constants.ValidationString(), Payload: err})

                        return
                }</span>

                <span class="cov5" title="4">if httpStatus, httpMessage, err = common.HTTPFiatOpen(db, logger, clientID, request.Currency); err != nil </span><span class="cov4" title="3">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: request.Currency})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusCreated,
                        models.HTTPSuccess{Message: "account created", Payload: []string{clientID.String(), request.Currency}})</span>
        }
}

// DepositFiat will handle an HTTP request to deposit funds into a Fiat account.
//
//        @Summary                Deposit funds into a Fiat account.
//        @Description        Deposit funds into a Fiat account in a specific currency for a user. The amount must be a positive number with at most two decimal places.
//        @Tags                        fiat currency deposit
//        @Id                                depositFiat
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        request        body                models.HTTPDepositCurrencyRequest        true        "currency code and amount to be deposited"
//        @Success                200                {object}        models.HTTPSuccess                                        "a message to confirm the deposit of funds"
//        @Failure                400                {object}        models.HTTPError                                        "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                                        "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                                        "error message with any available details in payload"
//        @Router                        /fiat/deposit [post]
func DepositFiat(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov8" title="8">{
        return func(ginCtx *gin.Context) </span><span class="cov8" title="8">{
                var (
                        clientID        uuid.UUID
                        err             error
                        httpMessage     string
                        httpStatus      int
                        payload         any
                        request         models.HTTPDepositCurrencyRequest
                        transferReceipt *postgres.FiatAccountTransferResult
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov7" title="7">if err = ginCtx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov7" title="7">if transferReceipt, httpStatus, httpMessage, payload, err =
                        common.HTTPFiatDeposit(db, logger, clientID, &amp;request); err != nil </span><span class="cov7" title="6">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: payload})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "funds successfully transferred", Payload: *transferReceipt})</span>
        }
}

// ExchangeOfferFiat will handle an HTTP request to get an exchange offer of funds between two Fiat currencies.
//
//        @Summary                Exchange quote for Fiat funds between two Fiat currencies.
//        @Description        Exchange quote for Fiat funds between two Fiat currencies. The amount must be a positive number with at most two decimal places and both currency accounts must be opened.
//        @Tags                        fiat currency exchange convert offer transfer
//        @Id                                exchangeOfferFiat
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        request        body                models.HTTPExchangeOfferRequest        true        "the two currency code and amount to be converted"
//        @Success                200                {object}        models.HTTPSuccess                                "a message to confirm the conversion rate for a currency"
//        @Failure                400                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Router                        /fiat/exchange/offer [post]
func ExchangeOfferFiat(logger *logger.Logger, auth auth.Auth, cache redis.Redis, quotes quotes.Quotes) gin.HandlerFunc <span class="cov9" title="10">{
        return func(ginCtx *gin.Context) </span><span class="cov9" title="10">{
                var (
                        clientID    uuid.UUID
                        err         error
                        httpStatus  int
                        httpMessage string
                        payload     any
                        request     models.HTTPExchangeOfferRequest
                        offer       *models.HTTPExchangeOfferResponse
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov8" title="9">if err = ginCtx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov8" title="9">if offer, httpStatus, httpMessage, payload, err =
                        common.HTTPFiatOffer(auth, cache, logger, quotes, clientID, &amp;request); err != nil </span><span class="cov8" title="8">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: payload})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "conversion rate offer", Payload: offer})</span>
        }
}

// ExchangeTransferFiat will handle an HTTP request to execute and complete a Fiat currency exchange offer.
//
//        @Summary                Transfer Fiat funds between two Fiat currencies using a valid Offer ID.
//        @Description        Transfer Fiat funds between two Fiat currencies. The Offer ID must be valid and have expired.
//        @Tags                        fiat currency exchange convert offer transfer execute
//        @Id                                exchangeTransferFiat
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        offerID        body                models.HTTPTransferRequest        true        "the two currency codes and amount to be converted"
//        @Success                200                {object}        models.HTTPSuccess                        "a message to confirm the conversion of funds"
//        @Failure                400                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                408                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                        "error message with any available details in payload"
//        @Router                        /fiat/exchange/transfer [post]
func ExchangeTransferFiat(
        logger *logger.Logger,
        auth auth.Auth,
        cache redis.Redis,
        db postgres.Postgres) gin.HandlerFunc <span class="cov10" title="13">{
        return func(ginCtx *gin.Context) </span><span class="cov10" title="13">{
                var (
                        err         error
                        clientID    uuid.UUID
                        receipt     *models.HTTPFiatTransferResponse
                        request     models.HTTPTransferRequest
                        httpStatus  int
                        httpMessage string
                        payload     any
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov9" title="12">if err = ginCtx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov9" title="12">if receipt, httpStatus, httpMessage, payload, err =
                        common.HTTPFiatTransfer(auth, cache, db, logger, clientID, &amp;request); err != nil </span><span class="cov9" title="10">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: payload})

                        return
                }</span>

                <span class="cov3" title="2">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "funds exchange transfer successful", Payload: receipt})</span>
        }
}

// BalanceFiat will handle an HTTP request to retrieve a balance for a specific Fiat currency.
//
//        @Summary                Retrieve balance for a specific Fiat currency.
//        @Description        Retrieves the balance for a specific Fiat currency. The currency ticker must be supplied as a query parameter.
//        @Tags                        fiat currency balance
//        @Id                                balanceCurrencyFiat
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        ticker        path                string                                true        "the currency ticker to retrieve the balance for"
//        @Success                200                {object}        models.HTTPSuccess        "the details for a specific currency account"
//        @Failure                400                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /fiat/info/balance/{ticker} [get]
//
//nolint:dupl
func BalanceFiat(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov6" title="5">{
        return func(ginCtx *gin.Context) </span><span class="cov6" title="5">{
                var (
                        accDetails  *postgres.FiatAccount
                        clientID    uuid.UUID
                        err         error
                        httpStatus  int
                        httpMessage string
                        payload     any
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov5" title="4">if accDetails, httpStatus, httpMessage, payload, err =
                        common.HTTPFiatBalance(db, logger, clientID, ginCtx.Param("ticker")); err != nil </span><span class="cov4" title="3">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: payload})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "account balance", Payload: accDetails})</span>
        }
}

// TxDetailsFiat will handle an HTTP request to retrieve information on a specific transaction.
//
//        @Summary                Retrieve transaction details for a specific transactionID.
//        @Description        Retrieves the transaction details for a specific transactionID. The transaction ID must be supplied as a query parameter.
//        @Tags                        fiat transactionID transaction details
//        @Id                                txDetailsCurrencyFiat
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        transactionID        path                string                                true        "the transaction ID to retrieve the details for"
//        @Success                200                                {object}        models.HTTPSuccess        "the transaction details for a specific transaction ID"
//        @Failure                400                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /fiat/info/transaction/{transactionID} [get]
func TxDetailsFiat(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov7" title="6">{
        return func(ginCtx *gin.Context) </span><span class="cov7" title="6">{
                var (
                        clientID      uuid.UUID
                        transactionID = ginCtx.Param("transactionID")
                        err           error
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                // Extract and validate the transactionID.
                <span class="cov6" title="5">journalEntries, status, errMsg, err := common.HTTPTxDetails(db, logger, clientID, transactionID)
                if err != nil </span><span class="cov5" title="4">{
                        ginCtx.AbortWithStatusJSON(status, models.HTTPError{Message: errMsg})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "transaction details", Payload: journalEntries})</span>
        }
}

// BalanceFiatPaginated will handle an HTTP request to retrieve a balance for all currency accounts held by a single
// client.
//
// If a user requests N records, N+1 records will be requested. This is used to calculate if any further records are
// available for retrieval. The page cursor will be the encrypted N+1'th record to retrieve in the subsequent call.
//
//        @Summary                Retrieve all the currency balances for a specific client.
//        @Description        Retrieves all the currency balances for a specific client. The initial request will only contain (optionally) the page size. Subsequent requests will require a cursors to the next page that will be returned in a previous call to the endpoint. The user may choose to change the page size in any sequence of calls.
//        @Tags                        fiat currency balance
//        @Id                                balanceCurrencyFiatPaginated
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        pageCursor        query                string                                false        "The page cursor into the query results records."
//        @Param                        pageSize        query                int                                        false        "The number of records to retrieve on this page."
//        @Success                200                        {object}        models.HTTPSuccess        "a message to with a page of account balances for the client's accounts"
//        @Failure                400                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                        {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /fiat/info/balance [get]
func BalanceFiatPaginated(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov8" title="9">{
        return func(ginCtx *gin.Context) </span><span class="cov8" title="9">{
                var (
                        accDetails  *models.HTTPFiatDetailsPaginated
                        clientID    uuid.UUID
                        err         error
                        httpStatus  int
                        httpMessage string
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov8" title="8">if accDetails, httpStatus, httpMessage, err = common.HTTPFiatBalancePaginated(auth, db, logger,
                        clientID, ginCtx.Query("pageCursor"), ginCtx.Query("pageSize"), true); err != nil </span><span class="cov5" title="4">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage})

                        return
                }</span>

                <span class="cov5" title="4">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "account balances", Payload: accDetails})</span>
        }
}

// TxDetailsFiatPaginated will handle an HTTP request to retrieve all transaction details for a currency account held by
// a single client for a given month.
//
// If a user requests N records, N+1 records will be requested. This is used to calculate if any further records are
// available for retrieval. The page cursor will be the encrypted date range for the month as well as the offset.
//
//        @Summary                Retrieve all the transactions for a currency account for a specific client during a specified month.
//        @Description        Retrieves all the transaction details for currency a specific client during the specified month. The initial request will contain (optionally) the page size and, month, year, and timezone (option, defaults to UTC). Subsequent requests will require a cursors to the next page that will be returned in the previous call to the endpoint. The user may choose to change the page size in any sequence of calls.
//        @Tags                        fiat currency transaction
//        @Id                                txDetailsCurrencyFiatPaginated
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        currencyCode        path                string                                true        "the currency code to retrieve the transaction details for."
//        @Param                        pageCursor                query                string                                false        "The page cursor into the query results records."
//        @Param                        timezone                query                string                                false        "The timezone for the month in question."
//        @Param                        month                        query                int                                        false        "The month for which transaction records are being requested."
//        @Param                        year                        query                int                                        false        "The year for the month for which transaction records are being requested."
//        @Param                        pageSize                query                int                                        false        "The number of records to retrieve on this page."
//        @Success                200                                {object}        models.HTTPSuccess        "a message to confirm the conversion of funds"
//        @Failure                400                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                403                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                404                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                416                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Failure                500                                {object}        models.HTTPError        "error message with any available details in payload"
//        @Router                        /fiat/info/transaction/all/{currencyCode}/ [get]
func TxDetailsFiatPaginated(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov8" title="8">{
        return func(ginCtx *gin.Context) </span><span class="cov8" title="8">{
                var (
                        journalEntries *models.HTTPFiatTransactionsPaginated
                        clientID       uuid.UUID
                        err            error
                        httpStatus     int
                        httpMessage    string
                        payload        any

                        params = common.HTTPPaginatedTxParams{
                                PageSizeStr:   ginCtx.Query("pageSize"),
                                PageCursorStr: ginCtx.Query("pageCursor"),
                                TimezoneStr:   ginCtx.Query("timezone"),
                                MonthStr:      ginCtx.Query("month"),
                                YearStr:       ginCtx.Query("year"),
                        }
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov7" title="7">if journalEntries, httpStatus, httpMessage, payload, err = common.HTTPFiatTransactionsPaginated(auth, db,
                        logger, clientID, ginCtx.Param("currencyCode"), &amp;params, true); err != nil </span><span class="cov6" title="5">{
                        ginCtx.AbortWithStatusJSON(httpStatus, models.HTTPError{Message: httpMessage, Payload: payload})

                        return
                }</span>

                <span class="cov3" title="2">ginCtx.JSON(http.StatusOK, models.HTTPSuccess{Message: "account transactions", Payload: journalEntries})</span>
        }
}
</pre>

		<pre class="file" id="file54" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/surahman/FTeX/pkg/common"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/redis"
)

// Healthcheck checks if the service is healthy by pinging the data tier comprised of Postgres and Redis.
//
//        @Summary                Healthcheck for service liveness.
//        @Description        This endpoint is exposed to allow load balancers etc. to check the health of the service.
//        @Description        This is achieved by the service pinging the data tier comprised of Postgres and Redis.
//        @Tags                        health healthcheck liveness
//        @Id                                healthcheck
//        @Produce                json
//        @Success                200        {object}        models.HTTPSuccess        "message: healthy"
//        @Failure                503        {object}        models.HTTPError        "error message with any available details"
//        @Router                        /health [get]
func Healthcheck(logger *logger.Logger, db postgres.Postgres, cache redis.Redis) gin.HandlerFunc <span class="cov10" title="3">{
        return func(context *gin.Context) </span><span class="cov10" title="3">{
                httpStatus, httpMsg, _ := common.HTTPHealthcheck(db, cache, logger)

                context.JSON(httpStatus, &amp;models.HTTPSuccess{Message: httpMsg})
        }</span>
}
</pre>

		<pre class="file" id="file55" style="display: none">package rest

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/gofrs/uuid"
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/common"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/models"
        modelsPostgres "github.com/surahman/FTeX/pkg/models/postgres"
        "github.com/surahman/FTeX/pkg/postgres"
)

// RegisterUser will handle an HTTP request to create a user.
//
//        @Summary                Register a user.
//        @Description        Creates a user account by inserting credentials into the database. A hashed password is stored.
//        @Tags                        user users register security
//        @Id                                registerUser
//        @Accept                        json
//        @Produce                json
//        @Param                        user        body                models.UserAccount                true        "Username, password, first and last name, email address of user"
//        @Success                201                {object}        models.JWTAuthResponse        "a valid JWT token for the new account"
//        @Failure                400                {object}        models.HTTPError                "error message with any available details in payload"
//        @Failure                404                {object}        models.HTTPError                "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                "error message with any available details in payload"
//        @Router                        /user/register [post]
func RegisterUser(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov7" title="5">{
        return func(ginCtx *gin.Context) </span><span class="cov7" title="5">{
                var (
                        authToken  *models.JWTAuthResponse
                        err        error
                        user       modelsPostgres.UserAccount
                        httpMsg    string
                        httpStatus int
                        payload    any
                )

                if err = ginCtx.ShouldBindJSON(&amp;user); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, &amp;models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov7" title="5">if authToken, httpMsg, httpStatus, payload, err = common.HTTPRegisterUser(auth, db, logger, &amp;user); err != nil </span><span class="cov6" title="4">{
                        ginCtx.AbortWithStatusJSON(httpStatus, &amp;models.HTTPError{Message: httpMsg, Payload: payload})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusCreated, authToken)</span>
        }
}

// LoginUser validates login credentials and generates a JWT.
//
//        @Summary                Login a user.
//        @Description        Logs in a user by validating credentials and returning a JWT.
//        @Tags                        user users login security
//        @Id                                loginUser
//        @Accept                        json
//        @Produce                json
//        @Param                        credentials        body                models.UserLoginCredentials        true        "Username and password to login with"
//        @Success                200                        {object}        models.JWTAuthResponse                "a valid JWT token for the new account"
//        @Failure                400                        {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                409                        {object}        models.HTTPError                        "error message with any available details in payload"
//        @Failure                500                        {object}        models.HTTPError                        "error message with any available details in payload"
//        @Router                        /user/login [post]
func LoginUser(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov7" title="5">{
        return func(ginCtx *gin.Context) </span><span class="cov7" title="5">{
                var (
                        err          error
                        authToken    *models.JWTAuthResponse
                        loginRequest modelsPostgres.UserLoginCredentials
                        httpMsg      string
                        httpStatus   int
                        payload      any
                )

                if err = ginCtx.ShouldBindJSON(&amp;loginRequest); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, &amp;models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov7" title="5">if authToken, httpMsg, httpStatus, payload, err = common.HTTPLoginUser(auth, db, logger, &amp;loginRequest); err != nil </span><span class="cov6" title="4">{
                        ginCtx.AbortWithStatusJSON(httpStatus, &amp;models.HTTPError{Message: httpMsg, Payload: payload})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, authToken)</span>
        }
}

// LoginRefresh validates a JWT token and issues a fresh token.
//
//        @Summary                Refresh a user's JWT by extending its expiration time.
//        @Description        Refreshes a user's JWT by validating it and then issuing a fresh JWT with an extended validity time. JWT must be expiring in under 60 seconds.
//        @Tags                        user users login refresh security
//        @Id                                loginRefresh
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Success                200        {object}        models.JWTAuthResponse        "A new valid JWT"
//        @Failure                403        {object}        models.HTTPError                "error message with any available details in payload"
//        @Failure                500        {object}        models.HTTPError                "error message with any available details in payload"
//        @Failure                510        {object}        models.HTTPError                "error message with any available details in payload"
//        @Router                        /user/refresh [post]
func LoginRefresh(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov8" title="7">{
        return func(ginCtx *gin.Context) </span><span class="cov8" title="7">{
                var (
                        err        error
                        clientID   uuid.UUID
                        expiresAt  int64
                        freshToken *models.JWTAuthResponse
                        httpMsg    string
                        httpStatus int
                )

                if clientID, expiresAt, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov3" title="2">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                <span class="cov7" title="5">if freshToken, httpMsg, httpStatus, err = common.HTTPRefreshLogin(auth, db, logger, clientID, expiresAt); err != nil </span><span class="cov6" title="4">{
                        ginCtx.AbortWithStatusJSON(httpStatus, &amp;models.HTTPError{Message: httpMsg})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusOK, freshToken)</span>
        }
}

// DeleteUser will mark a user as deleted in the database.
//
//        @Summary                Deletes a user. The user must supply their credentials as well as a confirmation message.
//        @Description        Deletes a user stored in the database by marking it as deleted. The user must supply their login credentials as well as complete the following confirmation message:
//        @Description        "I understand the consequences, delete my user account USERNAME HERE"
//        @Tags                        user users delete security
//        @Id                                deleteUser
//        @Accept                        json
//        @Produce                json
//        @Security                ApiKeyAuth
//        @Param                        request        body                models.HTTPDeleteUserRequest        true        "The request payload for deleting an account"
//        @Success                204                {object}        models.HTTPSuccess                                "message with a confirmation of a deleted user account"
//        @Failure                400                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Failure                403                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Failure                500                {object}        models.HTTPError                                "error message with any available details in payload"
//        @Router                        /user/delete [delete]
func DeleteUser(logger *logger.Logger, auth auth.Auth, db postgres.Postgres) gin.HandlerFunc <span class="cov10" title="9">{
        return func(ginCtx *gin.Context) </span><span class="cov10" title="9">{
                var (
                        clientID      uuid.UUID
                        deleteRequest models.HTTPDeleteUserRequest
                        err           error
                        httpMsg       string
                        httpStatus    int
                        payload       any
                )

                if clientID, _, err = auth.TokenInfoFromGinCtx(ginCtx); err != nil </span><span class="cov1" title="1">{
                        ginCtx.AbortWithStatusJSON(http.StatusForbidden, &amp;models.HTTPError{Message: "malformed authentication token"})

                        return
                }</span>

                // Get the deletion request from the message body and validate it.
                <span class="cov9" title="8">if err = ginCtx.ShouldBindJSON(&amp;deleteRequest); err != nil </span><span class="cov0" title="0">{
                        ginCtx.AbortWithStatusJSON(http.StatusBadRequest, &amp;models.HTTPError{Message: err.Error()})

                        return
                }</span>

                <span class="cov9" title="8">if httpMsg, httpStatus, payload, err = common.HTTPDeleteUser(auth, db, logger, clientID, &amp;deleteRequest); err != nil </span><span class="cov8" title="7">{
                        ginCtx.AbortWithStatusJSON(httpStatus, &amp;models.HTTPError{Message: httpMsg, Payload: payload})

                        return
                }</span>

                <span class="cov1" title="1">ginCtx.JSON(http.StatusNoContent, models.HTTPSuccess{Message: "account successfully deleted"})</span>
        }
}
</pre>

		<pre class="file" id="file56" style="display: none">package rest

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"

        "github.com/gin-gonic/gin"
        "github.com/spf13/afero"
        _ "github.com/surahman/FTeX/docs" // Swaggo generated Swagger documentation
        "github.com/surahman/FTeX/pkg/auth"
        "github.com/surahman/FTeX/pkg/logger"
        "github.com/surahman/FTeX/pkg/postgres"
        "github.com/surahman/FTeX/pkg/quotes"
        "github.com/surahman/FTeX/pkg/redis"
        restHandlers "github.com/surahman/FTeX/pkg/rest/handlers"
        swaggerfiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "go.uber.org/zap"
)

// Format and generate Swagger UI files using makefile.
//go:generate make -C ../../ swagger

// Server is the HTTP REST server.
type Server struct {
        auth   auth.Auth
        cache  redis.Redis
        db     postgres.Postgres
        quotes quotes.Quotes
        conf   *config
        logger *logger.Logger
        router *gin.Engine
        wg     *sync.WaitGroup
}

// NewServer will create a new REST server instance in a non-running state.
func NewServer(fs *afero.Fs, auth auth.Auth, postgres postgres.Postgres, redis redis.Redis, quotes quotes.Quotes,
        logger *logger.Logger, wg *sync.WaitGroup) (server *Server, err error) <span class="cov8" title="1">{
        // Load configurations.
        conf := newConfig()
        if err = conf.Load(*fs); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return &amp;Server{
                        conf:   conf,
                        auth:   auth,
                        cache:  redis,
                        db:     postgres,
                        quotes: quotes,
                        logger: logger,
                        wg:     wg,
                },
                err</span>
}

// initialize will configure the HTTP server routes.
func (s *Server) initialize() <span class="cov0" title="0">{
        s.router = gin.Default()

        //        @title                                                FTeX, Inc. (Formerly Crypto-Bro's Bank, Inc.)
        //        @version                                        1.1.1
        //        @description                                FTeX Fiat and Cryptocurrency Banking API.
        //        @description                                Bank, buy, and sell Fiat and Cryptocurrencies. Prices for all currencies are retrieved from real-time quote providers.
        //
        //        @schemes                                        http
        //        @host                                                localhost:33723
        //        @BasePath                                        /api/rest/v1
        //
        //        @accept                                                json
        //        @produce                                        json
        //
        //        @contact.name                                Saad Ur Rahman
        //        @contact.url                                https://www.linkedin.com/in/saad-ur-rahman/
        //        @contact.email                                saad.ur.rahman@gmail.com
        //
        //        @license.name                                GPL-3.0
        //        @license.url                                https://opensource.org/licenses/GPL-3.0
        //
        //        @securityDefinitions.apikey        ApiKeyAuth
        //        @in                                                        header
        //        @name                                                Authorization

        s.router.GET(s.conf.Server.SwaggerPath, ginSwagger.WrapHandler(swaggerfiles.Handler))

        // Endpoint configurations
        authMiddleware := restHandlers.AuthMiddleware(s.auth, s.db, s.logger, s.conf.Authorization.HeaderKey)
        api := s.router.Group(s.conf.Server.BasePath)

        api.GET("/health", restHandlers.Healthcheck(s.logger, s.db, s.cache))

        userGroup := api.Group("/user")
        userGroup.POST("/register", restHandlers.RegisterUser(s.logger, s.auth, s.db))
        userGroup.POST("/login", restHandlers.LoginUser(s.logger, s.auth, s.db))
        userGroup.
                Use(authMiddleware).
                POST("/refresh", restHandlers.LoginRefresh(s.logger, s.auth, s.db))
        userGroup.
                Use(authMiddleware).
                DELETE("/delete", restHandlers.DeleteUser(s.logger, s.auth, s.db))

        fiatGroup := api.Group("/fiat").Use(authMiddleware)
        fiatGroup.POST("/open", restHandlers.OpenFiat(s.logger, s.auth, s.db))
        fiatGroup.POST("/deposit", restHandlers.DepositFiat(s.logger, s.auth, s.db))
        fiatGroup.POST("/exchange/offer", restHandlers.ExchangeOfferFiat(s.logger, s.auth, s.cache, s.quotes))
        fiatGroup.POST("/exchange/transfer", restHandlers.ExchangeTransferFiat(s.logger, s.auth, s.cache, s.db))
        fiatGroup.GET("/info/balance/:ticker", restHandlers.BalanceFiat(s.logger, s.auth, s.db))
        fiatGroup.GET("/info/balance/", restHandlers.BalanceFiatPaginated(s.logger, s.auth, s.db))
        fiatGroup.GET("/info/transaction/:transactionID", restHandlers.TxDetailsFiat(s.logger, s.auth, s.db))
        fiatGroup.GET("/info/transaction/all/:currencyCode", restHandlers.TxDetailsFiatPaginated(s.logger, s.auth, s.db))

        cryptoGroup := api.Group("/crypto").Use(authMiddleware)
        cryptoGroup.POST("/open", restHandlers.OpenCrypto(s.logger, s.auth, s.db))
        cryptoGroup.POST("/offer", restHandlers.OfferCrypto(s.logger, s.auth, s.cache, s.quotes))
        cryptoGroup.POST("/exchange", restHandlers.ExchangeCrypto(s.logger, s.auth, s.cache, s.db))
        cryptoGroup.GET("/info/balance/:ticker", restHandlers.BalanceCrypto(s.logger, s.auth, s.db))
        cryptoGroup.GET("/info/transaction/:transactionID", restHandlers.TxDetailsCrypto(s.logger, s.auth, s.db))
        cryptoGroup.GET("/info/balance/", restHandlers.BalanceCryptoPaginated(s.logger, s.auth, s.db))
        cryptoGroup.GET("/info/transaction/all/:ticker", restHandlers.TxDetailsCryptoPaginated(s.logger, s.auth, s.db))
}</span>

// Run brings the HTTP service up.
func (s *Server) Run() <span class="cov0" title="0">{
        // Indicate to bootstrapping thread to wait for completion.
        defer s.wg.Done()

        // Configure routes.
        s.initialize()

        // Create server.
        srv := &amp;http.Server{
                ReadTimeout:       s.conf.Server.ReadTimeout,
                WriteTimeout:      s.conf.Server.WriteTimeout,
                ReadHeaderTimeout: s.conf.Server.ReadHeaderTimeout,
                Addr:              fmt.Sprintf(":%d", s.conf.Server.PortNumber),
                Handler:           s.router,
        }

        // Error channel for failed server start.
        serverErr := make(chan error, 1)

        // Wait for interrupt signal to gracefully shut down the server.
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        // Start HTTP listener.
        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        serverErr &lt;- err
                }</span>
        }()

        // Check for server start failure or shutdown signal.
        <span class="cov0" title="0">select </span>{
        case err := &lt;-serverErr:<span class="cov0" title="0">
                s.logger.Error(fmt.Sprintf("REST server failed to listen on port %d", s.conf.Server.PortNumber), zap.Error(err))

                return</span>
        case &lt;-quit:<span class="cov0" title="0">
                s.logger.Info("Shutting down REST server...", zap.Duration("waiting", s.conf.Server.ShutdownDelay))</span>
        }

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), s.conf.Server.ShutdownDelay)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                s.logger.Panic("Failed to shutdown REST server", zap.Error(err))
        }</span>

        // 5 second wait to exit.
        <span class="cov0" title="0">&lt;-ctx.Done()

        s.logger.Info("REST server exited")</span>
}
</pre>

		<pre class="file" id="file57" style="display: none">package rest

// configTestData will return a map of test data containing valid and invalid REST configs.
func configTestData() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "empty": ``,

                "valid": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  swaggerPath: /swagger/*any
  readTimeout: 3s
  writeTimeout: 3s
  readHeaderTimeout: 3s
authorization:
  headerKey: Authorization`,

                "out of range port": `
server:
  portNumber: 99
  shutdownDelay: 5s
  basePath: api/rest/v1
  swaggerPath: /swagger/*any
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "out of range time delay": `
server:
  portNumber: 44243
  shutdownDelay: 0s
  basePath: api/rest/v1
  swaggerPath: /swagger/*any
  readTimeout: 0s
  writeTimeout: 0s
  readHeaderTimeout: 0s
authorization:
  headerKey: Authorization`,

                "no base path": `
server:
  portNumber: 44243
  shutdownDelay: 5s
  swaggerPath: /swagger/*any
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no swagger path": `
server:
  portNumber: 44243
  shutdownDelay: 5s
  basePath: api/rest/v1
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no read timeout": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  swaggerPath: /swagger/*any
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no write timeout": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  swaggerPath: /swagger/*any
  readTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no read header timeout": `
server:
  portNumber: 33723
  shutdownDelay: 5s
  basePath: api/rest/v1
  swaggerPath: /swagger/*any
  readTimeout: 1s
  writeTimeout: 1s
authorization:
  headerKey: Authorization`,

                "no auth header": `
server:
  portNumber: 44243
  shutdownDelay: 5s
  basePath: api/rest/v1
  swaggerPath:  /swagger/*any
  readTimeout: 1s
  writeTimeout: 1s
  readHeaderTimeout: 1s
authorization:
  headerKey:`,
        }
}</span>
</pre>

		<pre class="file" id="file58" style="display: none">package validator

import (
        "bytes"
        "fmt"
)

// FieldError contains information on JSON validation errors.
type FieldError struct {
        Field string `json:"field" yaml:"field"` // Field name where the validation error occurred.
        Tag   string `json:"tag"   yaml:"tag"`   // The reason for the validation failure.
        Value any    `json:"value" yaml:"value"` // The value(s) associated with the failure.
}

// Error will output the validation error for a single structs data member.
func (err *FieldError) Error() string <span class="cov10" title="7">{
        return fmt.Sprintf("Field: %s, Tag: %s, Value: %s\n", err.Field, err.Tag, err.Value)
}</span>

// ValidationError contains all the validation errors found in a struct.
type ValidationError struct {
        // A list of all data members that failed validation.
        Errors []*FieldError `json:"validationErrors" yaml:"validationErrors"`
}

// Error will output the validation error for all struct data members.
func (err *ValidationError) Error() string <span class="cov6" title="3">{
        var buffer bytes.Buffer
        for _, item := range err.Errors </span><span class="cov6" title="3">{
                buffer.WriteString(item.Error())
        }</span>

        <span class="cov6" title="3">return buffer.String()</span>
}
</pre>

		<pre class="file" id="file59" style="display: none">package validator

import (
        "errors"

        "github.com/go-playground/validator/v10"
)

// structValidator is the validator instance that is used for structure validation.
var structValidator *validator.Validate

// init the struct validator.
func init() <span class="cov1" title="1">{
        structValidator = validator.New()
}</span>

// ValidateStruct will validate a struct and list all deficiencies.
func ValidateStruct(body any) error <span class="cov9" title="6">{
        var (
                validationErr ValidationError
                errs          validator.ValidationErrors
        )

        if errors.As(structValidator.Struct(body), &amp;errs) </span><span class="cov8" title="5">{
                for _, issue := range errs </span><span class="cov10" title="7">{
                        var ev FieldError
                        ev.Field = issue.Field()
                        ev.Tag = issue.Tag()
                        ev.Value = issue.Value()
                        validationErr.Errors = append(validationErr.Errors, &amp;ev)
                }</span>
        }

        <span class="cov9" title="6">if validationErr.Errors == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov8" title="5">return &amp;validationErr</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
